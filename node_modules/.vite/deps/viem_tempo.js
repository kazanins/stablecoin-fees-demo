import {
  createClient,
  createTransport
} from "./chunk-BAIJZHBX.js";
import {
  getTransactionReceipt,
  hashMessage,
  hashTypedData,
  multicall,
  parseEventLogs,
  sendTransaction,
  sendTransactionSync,
  waitForTransactionReceipt,
  watchContractEvent,
  writeContract,
  writeContractSync,
  zeroAddress
} from "./chunk-TK2Y6RPA.js";
import "./chunk-GPXG2F4E.js";
import {
  Formatters_exports,
  KeyAuthorization_exports,
  PoolId_exports,
  SignatureEnvelope_exports,
  Tick_exports,
  TokenId_exports,
  TokenRole_exports,
  Transaction_exports,
  TxEnvelopeTempo_exports,
  createCredential,
  deserialize,
  getPublicKey as getPublicKey2,
  getSignPayload,
  p256,
  randomPrivateKey as randomPrivateKey2,
  serialize,
  sign as sign2,
  sign2 as sign3
} from "./chunk-ZHUZU25O.js";
import {
  checksum,
  from as from2,
  fromHex,
  fromPublicKey,
  getPublicKey,
  hashAuthorization,
  isEqual,
  keccak256 as keccak2562,
  randomPrivateKey,
  readContract,
  sign,
  toHex,
  toHex3 as toHex2
} from "./chunk-XO67QMZH.js";
import {
  assert,
  concat3 as concat,
  encodeFunctionData,
  from,
  fromArray,
  fromNumber,
  fromString,
  fromString2,
  keccak256,
  padLeft,
  parseAccount,
  random,
  slice2 as slice,
  slice3 as slice2,
  toBigInt
} from "./chunk-CLTBMHAB.js";
import "./chunk-NFNOCDIA.js";
import "./chunk-YULNK4Y2.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/viem/_esm/tempo/Abis.js
var Abis_exports = {};
__export(Abis_exports, {
  accountKeychain: () => accountKeychain,
  feeAmm: () => feeAmm,
  feeManager: () => feeManager,
  nonce: () => nonce,
  stablecoinDex: () => stablecoinDex,
  tip20: () => tip20,
  tip20Factory: () => tip20Factory,
  tip403Registry: () => tip403Registry,
  validator: () => validator
});
var tip20 = [
  {
    name: "name",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    name: "symbol",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    name: "decimals",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint8" }]
  },
  {
    name: "totalSupply",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "quoteToken",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "address" }]
  },
  {
    name: "nextQuoteToken",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "address" }]
  },
  {
    name: "balanceOf",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "account" }],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "transfer",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "approve",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "spender" },
      { type: "uint256", name: "amount" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "allowance",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "owner" },
      { type: "address", name: "spender" }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "transferFrom",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "from" },
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "mint",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" }
    ],
    outputs: []
  },
  {
    name: "burn",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint256", name: "amount" }],
    outputs: []
  },
  {
    name: "currency",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    name: "supplyCap",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "paused",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "bool" }]
  },
  {
    name: "transferPolicyId",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint64" }]
  },
  {
    name: "burnBlocked",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "from" },
      { type: "uint256", name: "amount" }
    ],
    outputs: []
  },
  {
    name: "mintWithMemo",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" },
      { type: "bytes32", name: "memo" }
    ],
    outputs: []
  },
  {
    name: "burnWithMemo",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "uint256", name: "amount" },
      { type: "bytes32", name: "memo" }
    ],
    outputs: []
  },
  {
    name: "transferWithMemo",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" },
      { type: "bytes32", name: "memo" }
    ],
    outputs: []
  },
  {
    name: "transferFromWithMemo",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "from" },
      { type: "address", name: "to" },
      { type: "uint256", name: "amount" },
      { type: "bytes32", name: "memo" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "changeTransferPolicyId",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint64", name: "newPolicyId" }],
    outputs: []
  },
  {
    name: "setSupplyCap",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint256", name: "newSupplyCap" }],
    outputs: []
  },
  {
    name: "pause",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [],
    outputs: []
  },
  {
    name: "unpause",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [],
    outputs: []
  },
  {
    name: "setNextQuoteToken",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "newQuoteToken" }],
    outputs: []
  },
  {
    name: "completeQuoteTokenUpdate",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [],
    outputs: []
  },
  {
    name: "PAUSE_ROLE",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "UNPAUSE_ROLE",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "ISSUER_ROLE",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "BURN_BLOCKED_ROLE",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "distributeReward",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint256", name: "amount" }],
    outputs: []
  },
  {
    name: "setRewardRecipient",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "recipient" }],
    outputs: []
  },
  {
    name: "claimRewards",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "optedInSupply",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint128" }]
  },
  {
    name: "globalRewardPerToken",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "userRewardInfo",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "account" }],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "address", name: "rewardRecipient" },
          { type: "uint256", name: "rewardPerToken" },
          { type: "uint256", name: "rewardBalance" }
        ]
      }
    ]
  },
  {
    name: "getPendingRewards",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "account" }],
    outputs: [{ type: "uint128" }]
  },
  {
    name: "Transfer",
    type: "event",
    inputs: [
      { type: "address", name: "from", indexed: true },
      { type: "address", name: "to", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "Approval",
    type: "event",
    inputs: [
      { type: "address", name: "owner", indexed: true },
      { type: "address", name: "spender", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "Mint",
    type: "event",
    inputs: [
      { type: "address", name: "to", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "Burn",
    type: "event",
    inputs: [
      { type: "address", name: "from", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "BurnBlocked",
    type: "event",
    inputs: [
      { type: "address", name: "from", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "TransferWithMemo",
    type: "event",
    inputs: [
      { type: "address", name: "from", indexed: true },
      { type: "address", name: "to", indexed: true },
      { type: "uint256", name: "amount" },
      { type: "bytes32", name: "memo", indexed: true }
    ]
  },
  {
    name: "TransferPolicyUpdate",
    type: "event",
    inputs: [
      { type: "address", name: "updater", indexed: true },
      { type: "uint64", name: "newPolicyId", indexed: true }
    ]
  },
  {
    name: "SupplyCapUpdate",
    type: "event",
    inputs: [
      { type: "address", name: "updater", indexed: true },
      { type: "uint256", name: "newSupplyCap", indexed: true }
    ]
  },
  {
    name: "PauseStateUpdate",
    type: "event",
    inputs: [
      { type: "address", name: "updater", indexed: true },
      { type: "bool", name: "isPaused" }
    ]
  },
  {
    name: "NextQuoteTokenSet",
    type: "event",
    inputs: [
      { type: "address", name: "updater", indexed: true },
      { type: "address", name: "nextQuoteToken", indexed: true }
    ]
  },
  {
    name: "QuoteTokenUpdate",
    type: "event",
    inputs: [
      { type: "address", name: "updater", indexed: true },
      { type: "address", name: "newQuoteToken", indexed: true }
    ]
  },
  {
    name: "RewardDistributed",
    type: "event",
    inputs: [
      { type: "address", name: "funder", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  {
    name: "RewardRecipientSet",
    type: "event",
    inputs: [
      { type: "address", name: "holder", indexed: true },
      { type: "address", name: "recipient", indexed: true }
    ]
  },
  {
    name: "InsufficientBalance",
    type: "error",
    inputs: [
      { type: "uint256", name: "available" },
      { type: "uint256", name: "required" },
      { type: "address", name: "token" }
    ]
  },
  { name: "InsufficientAllowance", type: "error", inputs: [] },
  { name: "SupplyCapExceeded", type: "error", inputs: [] },
  { name: "InvalidSupplyCap", type: "error", inputs: [] },
  { name: "InvalidPayload", type: "error", inputs: [] },
  { name: "StringTooLong", type: "error", inputs: [] },
  { name: "PolicyForbids", type: "error", inputs: [] },
  { name: "InvalidRecipient", type: "error", inputs: [] },
  { name: "ContractPaused", type: "error", inputs: [] },
  { name: "InvalidCurrency", type: "error", inputs: [] },
  { name: "InvalidQuoteToken", type: "error", inputs: [] },
  { name: "TransfersDisabled", type: "error", inputs: [] },
  { name: "InvalidAmount", type: "error", inputs: [] },
  { name: "NoOptedInSupply", type: "error", inputs: [] },
  { name: "Unauthorized", type: "error", inputs: [] },
  { name: "ProtectedAddress", type: "error", inputs: [] },
  { name: "InvalidToken", type: "error", inputs: [] },
  { name: "Uninitialized", type: "error", inputs: [] },
  { name: "InvalidTransferPolicyId", type: "error", inputs: [] },
  {
    name: "hasRole",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "account" },
      { type: "bytes32", name: "role" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "getRoleAdmin",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes32", name: "role" }],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "grantRole",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "bytes32", name: "role" },
      { type: "address", name: "account" }
    ],
    outputs: []
  },
  {
    name: "revokeRole",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "bytes32", name: "role" },
      { type: "address", name: "account" }
    ],
    outputs: []
  },
  {
    name: "renounceRole",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "bytes32", name: "role" }],
    outputs: []
  },
  {
    name: "setRoleAdmin",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "bytes32", name: "role" },
      { type: "bytes32", name: "adminRole" }
    ],
    outputs: []
  },
  {
    name: "RoleMembershipUpdated",
    type: "event",
    inputs: [
      { type: "bytes32", name: "role", indexed: true },
      { type: "address", name: "account", indexed: true },
      { type: "address", name: "sender", indexed: true },
      { type: "bool", name: "hasRole" }
    ]
  },
  {
    name: "RoleAdminUpdated",
    type: "event",
    inputs: [
      { type: "bytes32", name: "role", indexed: true },
      { type: "bytes32", name: "newAdminRole", indexed: true },
      { type: "address", name: "sender", indexed: true }
    ]
  },
  { name: "Unauthorized", type: "error", inputs: [] }
];
var stablecoinDex = [
  {
    name: "createPair",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "base" }],
    outputs: [{ type: "bytes32", name: "key" }]
  },
  {
    name: "place",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "token" },
      { type: "uint128", name: "amount" },
      { type: "bool", name: "isBid" },
      { type: "int16", name: "tick" }
    ],
    outputs: [{ type: "uint128", name: "orderId" }]
  },
  {
    name: "placeFlip",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "token" },
      { type: "uint128", name: "amount" },
      { type: "bool", name: "isBid" },
      { type: "int16", name: "tick" },
      { type: "int16", name: "flipTick" }
    ],
    outputs: [{ type: "uint128", name: "orderId" }]
  },
  {
    name: "cancel",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint128", name: "orderId" }],
    outputs: []
  },
  {
    name: "cancelStaleOrder",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint128", name: "orderId" }],
    outputs: []
  },
  {
    name: "swapExactAmountIn",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "tokenIn" },
      { type: "address", name: "tokenOut" },
      { type: "uint128", name: "amountIn" },
      { type: "uint128", name: "minAmountOut" }
    ],
    outputs: [{ type: "uint128", name: "amountOut" }]
  },
  {
    name: "swapExactAmountOut",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "tokenIn" },
      { type: "address", name: "tokenOut" },
      { type: "uint128", name: "amountOut" },
      { type: "uint128", name: "maxAmountIn" }
    ],
    outputs: [{ type: "uint128", name: "amountIn" }]
  },
  {
    name: "quoteSwapExactAmountIn",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "tokenIn" },
      { type: "address", name: "tokenOut" },
      { type: "uint128", name: "amountIn" }
    ],
    outputs: [{ type: "uint128", name: "amountOut" }]
  },
  {
    name: "quoteSwapExactAmountOut",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "tokenIn" },
      { type: "address", name: "tokenOut" },
      { type: "uint128", name: "amountOut" }
    ],
    outputs: [{ type: "uint128", name: "amountIn" }]
  },
  {
    name: "balanceOf",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "user" },
      { type: "address", name: "token" }
    ],
    outputs: [{ type: "uint128" }]
  },
  {
    name: "withdraw",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "token" },
      { type: "uint128", name: "amount" }
    ],
    outputs: []
  },
  {
    name: "getOrder",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "uint128", name: "orderId" }],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "uint128", name: "orderId" },
          { type: "address", name: "maker" },
          { type: "bytes32", name: "bookKey" },
          { type: "bool", name: "isBid" },
          { type: "int16", name: "tick" },
          { type: "uint128", name: "amount" },
          { type: "uint128", name: "remaining" },
          { type: "uint128", name: "prev" },
          { type: "uint128", name: "next" },
          { type: "bool", name: "isFlip" },
          { type: "int16", name: "flipTick" }
        ]
      }
    ]
  },
  {
    name: "getTickLevel",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "base" },
      { type: "int16", name: "tick" },
      { type: "bool", name: "isBid" }
    ],
    outputs: [
      { type: "uint128", name: "head" },
      { type: "uint128", name: "tail" },
      { type: "uint128", name: "totalLiquidity" }
    ]
  },
  {
    name: "pairKey",
    type: "function",
    stateMutability: "pure",
    inputs: [
      { type: "address", name: "tokenA" },
      { type: "address", name: "tokenB" }
    ],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "nextOrderId",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint128" }]
  },
  {
    name: "books",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes32", name: "pairKey" }],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "address", name: "base" },
          { type: "address", name: "quote" },
          { type: "int16", name: "bestBidTick" },
          { type: "int16", name: "bestAskTick" }
        ]
      }
    ]
  },
  {
    name: "MIN_TICK",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "int16" }]
  },
  {
    name: "MAX_TICK",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "int16" }]
  },
  {
    name: "TICK_SPACING",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "int16" }]
  },
  {
    name: "PRICE_SCALE",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "uint32" }]
  },
  {
    name: "MIN_ORDER_AMOUNT",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "uint128" }]
  },
  {
    name: "MIN_PRICE",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "uint32" }]
  },
  {
    name: "MAX_PRICE",
    type: "function",
    stateMutability: "pure",
    inputs: [],
    outputs: [{ type: "uint32" }]
  },
  {
    name: "tickToPrice",
    type: "function",
    stateMutability: "pure",
    inputs: [{ type: "int16", name: "tick" }],
    outputs: [{ type: "uint32", name: "price" }]
  },
  {
    name: "priceToTick",
    type: "function",
    stateMutability: "pure",
    inputs: [{ type: "uint32", name: "price" }],
    outputs: [{ type: "int16", name: "tick" }]
  },
  {
    name: "PairCreated",
    type: "event",
    inputs: [
      { type: "bytes32", name: "key", indexed: true },
      { type: "address", name: "base", indexed: true },
      { type: "address", name: "quote", indexed: true }
    ]
  },
  {
    name: "OrderPlaced",
    type: "event",
    inputs: [
      { type: "uint128", name: "orderId", indexed: true },
      { type: "address", name: "maker", indexed: true },
      { type: "address", name: "token", indexed: true },
      { type: "uint128", name: "amount" },
      { type: "bool", name: "isBid" },
      { type: "int16", name: "tick" },
      { type: "bool", name: "isFlipOrder" },
      { type: "int16", name: "flipTick" }
    ]
  },
  {
    name: "OrderFilled",
    type: "event",
    inputs: [
      { type: "uint128", name: "orderId", indexed: true },
      { type: "address", name: "maker", indexed: true },
      { type: "address", name: "taker", indexed: true },
      { type: "uint128", name: "amountFilled" },
      { type: "bool", name: "partialFill" }
    ]
  },
  {
    name: "OrderCancelled",
    type: "event",
    inputs: [{ type: "uint128", name: "orderId", indexed: true }]
  },
  { name: "Unauthorized", type: "error", inputs: [] },
  { name: "PairDoesNotExist", type: "error", inputs: [] },
  { name: "PairAlreadyExists", type: "error", inputs: [] },
  { name: "OrderDoesNotExist", type: "error", inputs: [] },
  { name: "IdenticalTokens", type: "error", inputs: [] },
  { name: "InvalidToken", type: "error", inputs: [] },
  {
    name: "TickOutOfBounds",
    type: "error",
    inputs: [{ type: "int16", name: "tick" }]
  },
  { name: "InvalidTick", type: "error", inputs: [] },
  { name: "InvalidFlipTick", type: "error", inputs: [] },
  { name: "InsufficientBalance", type: "error", inputs: [] },
  { name: "InsufficientLiquidity", type: "error", inputs: [] },
  { name: "InsufficientOutput", type: "error", inputs: [] },
  { name: "MaxInputExceeded", type: "error", inputs: [] },
  {
    name: "BelowMinimumOrderSize",
    type: "error",
    inputs: [{ type: "uint128", name: "amount" }]
  },
  { name: "InvalidBaseToken", type: "error", inputs: [] },
  { name: "OrderNotStale", type: "error", inputs: [] }
];
var feeManager = [
  {
    name: "userTokens",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "user" }],
    outputs: [{ type: "address" }]
  },
  {
    name: "validatorTokens",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "validator" }],
    outputs: [{ type: "address" }]
  },
  {
    name: "setUserToken",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "token" }],
    outputs: []
  },
  {
    name: "setValidatorToken",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "token" }],
    outputs: []
  },
  {
    name: "distributeFees",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "validator" },
      { type: "address", name: "token" }
    ],
    outputs: []
  },
  {
    name: "collectedFees",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "validator" },
      { type: "address", name: "token" }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "UserTokenSet",
    type: "event",
    inputs: [
      { type: "address", name: "user", indexed: true },
      { type: "address", name: "token", indexed: true }
    ]
  },
  {
    name: "ValidatorTokenSet",
    type: "event",
    inputs: [
      { type: "address", name: "validator", indexed: true },
      { type: "address", name: "token", indexed: true }
    ]
  },
  {
    name: "FeesDistributed",
    type: "event",
    inputs: [
      { type: "address", name: "validator", indexed: true },
      { type: "address", name: "token", indexed: true },
      { type: "uint256", name: "amount" }
    ]
  },
  { name: "OnlyValidator", type: "error", inputs: [] },
  { name: "OnlySystemContract", type: "error", inputs: [] },
  { name: "InvalidToken", type: "error", inputs: [] },
  { name: "PoolDoesNotExist", type: "error", inputs: [] },
  { name: "InsufficientFeeTokenBalance", type: "error", inputs: [] },
  { name: "InternalError", type: "error", inputs: [] },
  { name: "CannotChangeWithinBlock", type: "error", inputs: [] },
  { name: "CannotChangeWithPendingFees", type: "error", inputs: [] },
  { name: "TokenPolicyForbids", type: "error", inputs: [] }
];
var feeAmm = [
  {
    name: "M",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "N",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "SCALE",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "MIN_LIQUIDITY",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "getPoolId",
    type: "function",
    stateMutability: "pure",
    inputs: [
      { type: "address", name: "userToken" },
      { type: "address", name: "validatorToken" }
    ],
    outputs: [{ type: "bytes32" }]
  },
  {
    name: "getPool",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "userToken" },
      { type: "address", name: "validatorToken" }
    ],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "uint128", name: "reserveUserToken" },
          { type: "uint128", name: "reserveValidatorToken" }
        ]
      }
    ]
  },
  {
    name: "pools",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes32", name: "poolId" }],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "uint128", name: "reserveUserToken" },
          { type: "uint128", name: "reserveValidatorToken" }
        ]
      }
    ]
  },
  {
    name: "mint",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "userToken" },
      { type: "address", name: "validatorToken" },
      { type: "uint256", name: "amountValidatorToken" },
      { type: "address", name: "to" }
    ],
    outputs: [{ type: "uint256", name: "liquidity" }]
  },
  {
    name: "burn",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "userToken" },
      { type: "address", name: "validatorToken" },
      { type: "uint256", name: "liquidity" },
      { type: "address", name: "to" }
    ],
    outputs: [
      { type: "uint256", name: "amountUserToken" },
      { type: "uint256", name: "amountValidatorToken" }
    ]
  },
  {
    name: "totalSupply",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes32", name: "poolId" }],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "liquidityBalances",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes32", name: "poolId" },
      { type: "address", name: "user" }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "rebalanceSwap",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "userToken" },
      { type: "address", name: "validatorToken" },
      { type: "uint256", name: "amountOut" },
      { type: "address", name: "to" }
    ],
    outputs: [{ type: "uint256", name: "amountIn" }]
  },
  {
    name: "Mint",
    type: "event",
    inputs: [
      { type: "address", name: "sender" },
      { type: "address", name: "to", indexed: true },
      { type: "address", name: "userToken", indexed: true },
      { type: "address", name: "validatorToken", indexed: true },
      { type: "uint256", name: "amountValidatorToken" },
      { type: "uint256", name: "liquidity" }
    ]
  },
  {
    name: "Burn",
    type: "event",
    inputs: [
      { type: "address", name: "sender", indexed: true },
      { type: "address", name: "userToken", indexed: true },
      { type: "address", name: "validatorToken", indexed: true },
      { type: "uint256", name: "amountUserToken" },
      { type: "uint256", name: "amountValidatorToken" },
      { type: "uint256", name: "liquidity" },
      { type: "address", name: "to" }
    ]
  },
  {
    name: "RebalanceSwap",
    type: "event",
    inputs: [
      { type: "address", name: "userToken", indexed: true },
      { type: "address", name: "validatorToken", indexed: true },
      { type: "address", name: "swapper", indexed: true },
      { type: "uint256", name: "amountIn" },
      { type: "uint256", name: "amountOut" }
    ]
  },
  { name: "IdenticalAddresses", type: "error", inputs: [] },
  { name: "InvalidToken", type: "error", inputs: [] },
  { name: "InsufficientLiquidity", type: "error", inputs: [] },
  { name: "InsufficientReserves", type: "error", inputs: [] },
  { name: "InvalidAmount", type: "error", inputs: [] },
  { name: "DivisionByZero", type: "error", inputs: [] },
  { name: "InvalidSwapCalculation", type: "error", inputs: [] }
];
var accountKeychain = [
  {
    name: "authorizeKey",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "keyId" },
      { type: "uint8", name: "signatureType" },
      { type: "uint64", name: "expiry" },
      { type: "bool", name: "enforceLimits" },
      {
        type: "tuple[]",
        name: "limits",
        components: [
          { type: "address", name: "token" },
          { type: "uint256", name: "amount" }
        ]
      }
    ],
    outputs: []
  },
  {
    name: "revokeKey",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "keyId" }],
    outputs: []
  },
  {
    name: "updateSpendingLimit",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "keyId" },
      { type: "address", name: "token" },
      { type: "uint256", name: "newLimit" }
    ],
    outputs: []
  },
  {
    name: "getKey",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "account" },
      { type: "address", name: "keyId" }
    ],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "uint8", name: "signatureType" },
          { type: "address", name: "keyId" },
          { type: "uint64", name: "expiry" },
          { type: "bool", name: "enforceLimits" },
          { type: "bool", name: "isRevoked" }
        ]
      }
    ]
  },
  {
    name: "getRemainingLimit",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "account" },
      { type: "address", name: "keyId" },
      { type: "address", name: "token" }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    name: "getTransactionKey",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "address" }]
  },
  {
    name: "KeyAuthorized",
    type: "event",
    inputs: [
      { type: "address", name: "account", indexed: true },
      { type: "address", name: "publicKey", indexed: true },
      { type: "uint8", name: "signatureType" },
      { type: "uint64", name: "expiry" }
    ]
  },
  {
    name: "KeyRevoked",
    type: "event",
    inputs: [
      { type: "address", name: "account", indexed: true },
      { type: "address", name: "publicKey", indexed: true }
    ]
  },
  {
    name: "SpendingLimitUpdated",
    type: "event",
    inputs: [
      { type: "address", name: "account", indexed: true },
      { type: "address", name: "publicKey", indexed: true },
      { type: "address", name: "token", indexed: true },
      { type: "uint256", name: "newLimit" }
    ]
  },
  { name: "UnauthorizedCaller", type: "error", inputs: [] },
  { name: "KeyAlreadyExists", type: "error", inputs: [] },
  { name: "KeyNotFound", type: "error", inputs: [] },
  { name: "KeyExpired", type: "error", inputs: [] },
  { name: "SpendingLimitExceeded", type: "error", inputs: [] },
  { name: "InvalidSignatureType", type: "error", inputs: [] },
  { name: "ZeroPublicKey", type: "error", inputs: [] },
  { name: "ExpiryInPast", type: "error", inputs: [] },
  { name: "KeyAlreadyRevoked", type: "error", inputs: [] }
];
var nonce = [
  {
    name: "getNonce",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "account" },
      { type: "uint256", name: "nonceKey" }
    ],
    outputs: [{ type: "uint64", name: "nonce" }]
  },
  {
    name: "NonceIncremented",
    type: "event",
    inputs: [
      { type: "address", name: "account", indexed: true },
      { type: "uint256", name: "nonceKey", indexed: true },
      { type: "uint64", name: "newNonce" }
    ]
  },
  { name: "ProtocolNonceNotSupported", type: "error", inputs: [] },
  { name: "InvalidNonceKey", type: "error", inputs: [] },
  { name: "NonceOverflow", type: "error", inputs: [] }
];
var tip20Factory = [
  {
    name: "createToken",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "string", name: "name" },
      { type: "string", name: "symbol" },
      { type: "string", name: "currency" },
      { type: "address", name: "quoteToken" },
      { type: "address", name: "admin" },
      { type: "bytes32", name: "salt" }
    ],
    outputs: [{ type: "address" }]
  },
  {
    name: "isTIP20",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "token" }],
    outputs: [{ type: "bool" }]
  },
  {
    name: "getTokenAddress",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "address", name: "sender" },
      { type: "bytes32", name: "salt" }
    ],
    outputs: [{ type: "address" }]
  },
  {
    name: "TokenCreated",
    type: "event",
    inputs: [
      { type: "address", name: "token", indexed: true },
      { type: "string", name: "name" },
      { type: "string", name: "symbol" },
      { type: "string", name: "currency" },
      { type: "address", name: "quoteToken" },
      { type: "address", name: "admin" },
      { type: "bytes32", name: "salt" }
    ]
  },
  { name: "AddressReserved", type: "error", inputs: [] },
  { name: "AddressNotReserved", type: "error", inputs: [] },
  { name: "InvalidQuoteToken", type: "error", inputs: [] },
  {
    name: "TokenAlreadyExists",
    type: "error",
    inputs: [{ type: "address", name: "token" }]
  }
];
var tip403Registry = [
  {
    name: "policyIdCounter",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint64" }]
  },
  {
    name: "policyExists",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "uint64", name: "policyId" }],
    outputs: [{ type: "bool" }]
  },
  {
    name: "policyData",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "uint64", name: "policyId" }],
    outputs: [
      { type: "uint8", name: "policyType" },
      { type: "address", name: "admin" }
    ]
  },
  {
    name: "isAuthorized",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "uint64", name: "policyId" },
      { type: "address", name: "user" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "createPolicy",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "admin" },
      { type: "uint8", name: "policyType" }
    ],
    outputs: [{ type: "uint64" }]
  },
  {
    name: "createPolicyWithAccounts",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "admin" },
      { type: "uint8", name: "policyType" },
      { type: "address[]", name: "accounts" }
    ],
    outputs: [{ type: "uint64" }]
  },
  {
    name: "setPolicyAdmin",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "uint64", name: "policyId" },
      { type: "address", name: "admin" }
    ],
    outputs: []
  },
  {
    name: "modifyPolicyWhitelist",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "uint64", name: "policyId" },
      { type: "address", name: "account" },
      { type: "bool", name: "allowed" }
    ],
    outputs: []
  },
  {
    name: "modifyPolicyBlacklist",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "uint64", name: "policyId" },
      { type: "address", name: "account" },
      { type: "bool", name: "restricted" }
    ],
    outputs: []
  },
  {
    name: "PolicyAdminUpdated",
    type: "event",
    inputs: [
      { type: "uint64", name: "policyId", indexed: true },
      { type: "address", name: "updater", indexed: true },
      { type: "address", name: "admin", indexed: true }
    ]
  },
  {
    name: "PolicyCreated",
    type: "event",
    inputs: [
      { type: "uint64", name: "policyId", indexed: true },
      { type: "address", name: "updater", indexed: true },
      { type: "uint8", name: "policyType" }
    ]
  },
  {
    name: "WhitelistUpdated",
    type: "event",
    inputs: [
      { type: "uint64", name: "policyId", indexed: true },
      { type: "address", name: "updater", indexed: true },
      { type: "address", name: "account", indexed: true },
      { type: "bool", name: "allowed" }
    ]
  },
  {
    name: "BlacklistUpdated",
    type: "event",
    inputs: [
      { type: "uint64", name: "policyId", indexed: true },
      { type: "address", name: "updater", indexed: true },
      { type: "address", name: "account", indexed: true },
      { type: "bool", name: "restricted" }
    ]
  },
  { name: "Unauthorized", type: "error", inputs: [] },
  { name: "IncompatiblePolicyType", type: "error", inputs: [] },
  { name: "PolicyNotFound", type: "error", inputs: [] }
];
var validator = [
  {
    name: "getValidators",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        type: "tuple[]",
        name: "validators",
        components: [
          { type: "bytes32", name: "publicKey" },
          { type: "bool", name: "active" },
          { type: "uint64", name: "index" },
          { type: "address", name: "validatorAddress" },
          { type: "string", name: "inboundAddress" },
          { type: "string", name: "outboundAddress" }
        ]
      }
    ]
  },
  {
    name: "addValidator",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "newValidatorAddress" },
      { type: "bytes32", name: "publicKey" },
      { type: "bool", name: "active" },
      { type: "string", name: "inboundAddress" },
      { type: "string", name: "outboundAddress" }
    ],
    outputs: []
  },
  {
    name: "updateValidator",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "newValidatorAddress" },
      { type: "bytes32", name: "publicKey" },
      { type: "string", name: "inboundAddress" },
      { type: "string", name: "outboundAddress" }
    ],
    outputs: []
  },
  {
    name: "changeValidatorStatus",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "validator" },
      { type: "bool", name: "active" }
    ],
    outputs: []
  },
  {
    name: "owner",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "address" }]
  },
  {
    name: "changeOwner",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "address", name: "newOwner" }],
    outputs: []
  },
  {
    name: "getNextFullDkgCeremony",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint64" }]
  },
  {
    name: "setNextFullDkgCeremony",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [{ type: "uint64", name: "epoch" }],
    outputs: []
  },
  {
    name: "validatorsArray",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "uint256", name: "index" }],
    outputs: [{ type: "address" }]
  },
  {
    name: "validators",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "address", name: "validator" }],
    outputs: [
      {
        type: "tuple",
        components: [
          { type: "bytes32", name: "publicKey" },
          { type: "bool", name: "active" },
          { type: "uint64", name: "index" },
          { type: "address", name: "validatorAddress" },
          { type: "string", name: "inboundAddress" },
          { type: "string", name: "outboundAddress" }
        ]
      }
    ]
  },
  {
    name: "validatorCount",
    type: "function",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint64" }]
  },
  { name: "Unauthorized", type: "error", inputs: [] },
  { name: "ValidatorAlreadyExists", type: "error", inputs: [] },
  { name: "ValidatorNotFound", type: "error", inputs: [] },
  { name: "InvalidPublicKey", type: "error", inputs: [] },
  {
    name: "NotHostPort",
    type: "error",
    inputs: [
      { type: "string", name: "field" },
      { type: "string", name: "input" },
      { type: "string", name: "backtrace" }
    ]
  },
  {
    name: "NotIpPort",
    type: "error",
    inputs: [
      { type: "string", name: "field" },
      { type: "string", name: "input" },
      { type: "string", name: "backtrace" }
    ]
  }
];

// node_modules/viem/_esm/tempo/Account.js
var Account_exports = {};
__export(Account_exports, {
  fromHeadlessWebAuthn: () => fromHeadlessWebAuthn,
  fromP256: () => fromP256,
  fromSecp256k1: () => fromSecp256k1,
  fromWebAuthnP256: () => fromWebAuthnP256,
  fromWebCryptoP256: () => fromWebCryptoP256,
  signKeyAuthorization: () => signKeyAuthorization,
  z_KeyAuthorization: () => KeyAuthorization_exports,
  z_SignatureEnvelope: () => SignatureEnvelope_exports,
  z_TxEnvelopeTempo: () => TxEnvelopeTempo_exports
});

// node_modules/ox/_esm/core/WebCryptoP256.js
async function createKeyPair(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from2(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function sign4(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r = toBigInt(slice(signature_bytes, 0, 32));
  let s = toBigInt(slice(signature_bytes, 32, 64));
  if (s > p256.CURVE.n / 2n)
    s = p256.CURVE.n - s;
  return { r, s };
}

// node_modules/viem/_esm/tempo/Account.js
function fromHeadlessWebAuthn(privateKey, options) {
  const { access, rpId, origin } = options;
  const publicKey = getPublicKey2({ privateKey });
  return from3({
    access,
    keyType: "webAuthn",
    publicKey,
    async sign({ hash }) {
      const { metadata, payload } = getSignPayload({
        ...options,
        challenge: hash,
        rpId,
        origin
      });
      const signature = sign2({
        payload,
        privateKey,
        hash: true
      });
      return SignatureEnvelope_exports.serialize({
        metadata,
        signature,
        publicKey,
        type: "webAuthn"
      });
    }
  });
}
function fromP256(privateKey, options = {}) {
  const { access } = options;
  const publicKey = getPublicKey2({ privateKey });
  return from3({
    access,
    keyType: "p256",
    publicKey,
    async sign({ hash }) {
      const signature = sign2({ payload: hash, privateKey });
      return SignatureEnvelope_exports.serialize({
        signature,
        publicKey,
        type: "p256"
      });
    }
  });
}
function fromSecp256k1(privateKey, options = {}) {
  const { access } = options;
  const publicKey = getPublicKey({ privateKey });
  return from3({
    access,
    keyType: "secp256k1",
    publicKey,
    async sign(parameters) {
      const { hash } = parameters;
      const signature = sign({ payload: hash, privateKey });
      return toHex2(signature);
    }
  });
}
function fromWebAuthnP256(credential, options = {}) {
  const { id } = credential;
  const publicKey = fromHex(credential.publicKey);
  return from3({
    keyType: "webAuthn",
    publicKey,
    async sign({ hash }) {
      const { metadata, signature } = await sign3({
        ...options,
        challenge: hash,
        credentialId: id
      });
      return SignatureEnvelope_exports.serialize({
        publicKey,
        metadata,
        signature,
        type: "webAuthn"
      });
    }
  });
}
function fromWebCryptoP256(keyPair, options = {}) {
  const { access } = options;
  const { publicKey, privateKey } = keyPair;
  return from3({
    access,
    keyType: "p256",
    publicKey,
    async sign({ hash }) {
      const signature = await sign4({ payload: hash, privateKey });
      return SignatureEnvelope_exports.serialize({
        signature,
        prehash: true,
        publicKey,
        type: "p256"
      });
    }
  });
}
async function signKeyAuthorization(account, parameters) {
  const { key, expiry, limits } = parameters;
  const { accessKeyAddress, keyType: type } = key;
  const signature = await account.sign({
    hash: KeyAuthorization_exports.getSignPayload({
      address: accessKeyAddress,
      expiry,
      limits,
      type
    })
  });
  return KeyAuthorization_exports.from({
    address: accessKeyAddress,
    expiry,
    limits,
    signature: SignatureEnvelope_exports.from(signature),
    type
  });
}
function fromBase(parameters) {
  const { keyType = "secp256k1", parentAddress, source = "privateKey" } = parameters;
  const address = parentAddress ?? fromPublicKey(parameters.publicKey);
  const publicKey = toHex(parameters.publicKey, {
    includePrefix: false
  });
  async function sign5({ hash }) {
    const signature = await parameters.sign({ hash });
    if (parentAddress)
      return SignatureEnvelope_exports.serialize(SignatureEnvelope_exports.from({
        userAddress: parentAddress,
        inner: SignatureEnvelope_exports.from(signature),
        type: "keychain"
      }));
    if (keyType === "secp256k1")
      return signature;
    return concat(signature, SignatureEnvelope_exports.magicBytes);
  }
  return {
    address: checksum(address),
    keyType,
    sign: sign5,
    async signAuthorization(parameters2) {
      const { chainId, nonce: nonce2 } = parameters2;
      const address2 = parameters2.contractAddress ?? parameters2.address;
      const signature = await sign5({
        hash: hashAuthorization({ address: address2, chainId, nonce: nonce2 })
      });
      const envelope = SignatureEnvelope_exports.from(signature);
      if (envelope.type !== "secp256k1")
        throw new Error("Unsupported signature type. Expected `secp256k1` but got `" + envelope.type + "`.");
      const { r, s, yParity } = envelope.signature;
      return {
        address: address2,
        chainId,
        nonce: nonce2,
        r: fromNumber(r, { size: 32 }),
        s: fromNumber(s, { size: 32 }),
        yParity
      };
    },
    async signMessage(parameters2) {
      const { message } = parameters2;
      return await sign5({ hash: hashMessage(message) });
    },
    async signTransaction(transaction, options) {
      const { serializer = serialize } = options ?? {};
      const signature = await sign5({
        hash: keccak256(await serializer(transaction))
      });
      const envelope = SignatureEnvelope_exports.from(signature);
      return await serializer(transaction, envelope);
    },
    async signTypedData(typedData) {
      return await sign5({ hash: hashTypedData(typedData) });
    },
    publicKey,
    source,
    type: "local"
  };
}
function fromRoot(parameters) {
  const account = fromBase(parameters);
  return {
    ...account,
    source: "root",
    async signKeyAuthorization(key, parameters2 = {}) {
      const { expiry, limits } = parameters2;
      const { accessKeyAddress, keyType: type } = key;
      const signature = await account.sign({
        hash: KeyAuthorization_exports.getSignPayload({
          address: accessKeyAddress,
          expiry,
          limits,
          type
        })
      });
      const keyAuthorization = KeyAuthorization_exports.from({
        address: accessKeyAddress,
        expiry,
        limits,
        signature: SignatureEnvelope_exports.from(signature),
        type
      });
      return keyAuthorization;
    }
  };
}
function fromAccessKey(parameters) {
  const { access } = parameters;
  const { address: parentAddress } = parseAccount(access);
  const account = fromBase({ ...parameters, parentAddress });
  return {
    ...account,
    accessKeyAddress: fromPublicKey(parameters.publicKey),
    source: "accessKey"
  };
}
function from3(parameters) {
  const { access } = parameters;
  if (access)
    return fromAccessKey(parameters);
  return fromRoot(parameters);
}

// node_modules/viem/_esm/tempo/Addresses.js
var Addresses_exports = {};
__export(Addresses_exports, {
  accountImplementation: () => accountImplementation,
  accountRegistrar: () => accountRegistrar,
  feeManager: () => feeManager2,
  nonceManager: () => nonceManager,
  pathUsd: () => pathUsd,
  stablecoinDex: () => stablecoinDex2,
  tip20Factory: () => tip20Factory2,
  tip403Registry: () => tip403Registry2,
  validator: () => validator2
});
var accountImplementation = "0x7702c00000000000000000000000000000000000";
var accountRegistrar = "0x7702ac0000000000000000000000000000000000";
var feeManager2 = "0xfeec000000000000000000000000000000000000";
var nonceManager = "0x4e4F4E4345000000000000000000000000000000";
var pathUsd = "0x20c0000000000000000000000000000000000000";
var stablecoinDex2 = "0xdec0000000000000000000000000000000000000";
var tip20Factory2 = "0x20fc000000000000000000000000000000000000";
var tip403Registry2 = "0x403c000000000000000000000000000000000000";
var validator2 = "0xcccccccc00000000000000000000000000000000";

// node_modules/viem/_esm/tempo/actions/index.js
var actions_exports = {};
__export(actions_exports, {
  amm: () => amm_exports,
  dex: () => dex_exports,
  faucet: () => faucet_exports,
  fee: () => fee_exports,
  nonce: () => nonce_exports,
  policy: () => policy_exports,
  reward: () => reward_exports,
  token: () => token_exports,
  validator: () => validator_exports
});

// node_modules/viem/_esm/tempo/actions/amm.js
var amm_exports = {};
__export(amm_exports, {
  burn: () => burn,
  burnSync: () => burnSync,
  getLiquidityBalance: () => getLiquidityBalance,
  getPool: () => getPool,
  mint: () => mint,
  mintSync: () => mintSync,
  rebalanceSwap: () => rebalanceSwap,
  rebalanceSwapSync: () => rebalanceSwapSync,
  watchBurn: () => watchBurn,
  watchMint: () => watchMint,
  watchRebalanceSwap: () => watchRebalanceSwap
});

// node_modules/viem/_esm/tempo/internal/utils.js
function defineCall(call) {
  return {
    ...call,
    data: encodeFunctionData(call),
    to: call.address
  };
}

// node_modules/viem/_esm/tempo/actions/amm.js
async function getPool(client, parameters) {
  const { userToken, validatorToken, ...rest } = parameters;
  const [pool, totalSupply] = await multicall(client, {
    ...rest,
    contracts: getPool.calls({ userToken, validatorToken }),
    allowFailure: false,
    deployless: true
  });
  return {
    reserveUserToken: pool.reserveUserToken,
    reserveValidatorToken: pool.reserveValidatorToken,
    totalSupply
  };
}
(function(getPool2) {
  function calls(args) {
    const { userToken, validatorToken } = args;
    return [
      defineCall({
        address: feeManager2,
        abi: feeAmm,
        args: [TokenId_exports.toAddress(userToken), TokenId_exports.toAddress(validatorToken)],
        functionName: "getPool"
      }),
      defineCall({
        address: feeManager2,
        abi: feeAmm,
        args: [PoolId_exports.from({ userToken, validatorToken })],
        functionName: "totalSupply"
      })
    ];
  }
  getPool2.calls = calls;
})(getPool || (getPool = {}));
async function getLiquidityBalance(client, parameters) {
  const { address, poolId, userToken, validatorToken, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getLiquidityBalance.call({
      address,
      poolId,
      userToken,
      validatorToken
    })
  });
}
(function(getLiquidityBalance2) {
  function call(args) {
    const { address } = args;
    const poolId = (() => {
      if ("poolId" in args && args.poolId)
        return args.poolId;
      if ("userToken" in args && "validatorToken" in args)
        return PoolId_exports.from({
          userToken: args.userToken,
          validatorToken: args.validatorToken
        });
      throw new Error("`poolId`, or `userToken` and `validatorToken` must be provided.");
    })();
    return defineCall({
      address: feeManager2,
      abi: feeAmm,
      args: [poolId, address],
      functionName: "liquidityBalances"
    });
  }
  getLiquidityBalance2.call = call;
})(getLiquidityBalance || (getLiquidityBalance = {}));
async function rebalanceSwap(client, parameters) {
  return rebalanceSwap.inner(writeContract, client, parameters);
}
(function(rebalanceSwap2) {
  async function inner(action, client, parameters) {
    const { userToken, validatorToken, amountOut, to, ...rest } = parameters;
    const call2 = rebalanceSwap2.call({
      userToken,
      validatorToken,
      amountOut,
      to
    });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  rebalanceSwap2.inner = inner;
  function call(args) {
    const { userToken, validatorToken, amountOut, to } = args;
    return defineCall({
      address: feeManager2,
      abi: feeAmm,
      functionName: "rebalanceSwap",
      args: [
        TokenId_exports.toAddress(userToken),
        TokenId_exports.toAddress(validatorToken),
        amountOut,
        to
      ]
    });
  }
  rebalanceSwap2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: feeAmm,
      logs,
      eventName: "RebalanceSwap",
      strict: true
    });
    if (!log)
      throw new Error("`RebalanceSwap` event not found.");
    return log;
  }
  rebalanceSwap2.extractEvent = extractEvent;
})(rebalanceSwap || (rebalanceSwap = {}));
async function rebalanceSwapSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await rebalanceSwap.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = rebalanceSwap.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function mint(client, parameters) {
  return mint.inner(writeContract, client, parameters);
}
(function(mint3) {
  async function inner(action, client, parameters) {
    const { to, userTokenAddress, validatorTokenAddress, validatorTokenAmount, ...rest } = parameters;
    const call2 = mint3.call({
      to,
      userTokenAddress,
      validatorTokenAddress,
      validatorTokenAmount
    });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  mint3.inner = inner;
  function call(args) {
    const { to, userTokenAddress, validatorTokenAddress, validatorTokenAmount } = args;
    return defineCall({
      address: feeManager2,
      abi: feeAmm,
      functionName: "mint",
      args: [
        TokenId_exports.toAddress(userTokenAddress),
        TokenId_exports.toAddress(validatorTokenAddress),
        validatorTokenAmount,
        to
      ]
    });
  }
  mint3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: feeAmm,
      logs,
      eventName: "Mint",
      strict: true
    });
    if (!log)
      throw new Error("`Mint` event not found.");
    return log;
  }
  mint3.extractEvent = extractEvent;
})(mint || (mint = {}));
async function mintSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await mint.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = mint.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function burn(client, parameters) {
  return burn.inner(writeContract, client, parameters);
}
(function(burn3) {
  async function inner(action, client, parameters) {
    const { liquidity, to, userToken, validatorToken, ...rest } = parameters;
    const call2 = burn3.call({ liquidity, to, userToken, validatorToken });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  burn3.inner = inner;
  function call(args) {
    const { liquidity, to, userToken, validatorToken } = args;
    return defineCall({
      address: feeManager2,
      abi: feeAmm,
      functionName: "burn",
      args: [
        TokenId_exports.toAddress(userToken),
        TokenId_exports.toAddress(validatorToken),
        liquidity,
        to
      ]
    });
  }
  burn3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: feeAmm,
      logs,
      eventName: "Burn",
      strict: true
    });
    if (!log)
      throw new Error("`Burn` event not found.");
    return log;
  }
  burn3.extractEvent = extractEvent;
})(burn || (burn = {}));
async function burnSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await burn.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = burn.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
function watchRebalanceSwap(client, parameters) {
  const { onRebalanceSwap, userToken, validatorToken, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: feeManager2,
    abi: feeAmm,
    eventName: "RebalanceSwap",
    args: userToken !== void 0 && validatorToken !== void 0 ? {
      userToken: TokenId_exports.toAddress(userToken),
      validatorToken: TokenId_exports.toAddress(validatorToken)
    } : void 0,
    onLogs: (logs) => {
      for (const log of logs)
        onRebalanceSwap(log.args, log);
    },
    strict: true
  });
}
function watchMint(client, parameters) {
  const { onMint, to, userToken, validatorToken, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: feeManager2,
    abi: feeAmm,
    eventName: "Mint",
    args: {
      to,
      ...userToken !== void 0 && {
        userToken: TokenId_exports.toAddress(userToken)
      },
      ...validatorToken !== void 0 && {
        validatorToken: TokenId_exports.toAddress(validatorToken)
      }
    },
    onLogs: (logs) => {
      for (const log of logs)
        onMint(log.args, log);
    },
    strict: true
  });
}
function watchBurn(client, parameters) {
  const { onBurn, userToken, validatorToken, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: feeManager2,
    abi: feeAmm,
    eventName: "Burn",
    args: userToken !== void 0 && validatorToken !== void 0 ? {
      userToken: TokenId_exports.toAddress(userToken),
      validatorToken: TokenId_exports.toAddress(validatorToken)
    } : void 0,
    onLogs: (logs) => {
      for (const log of logs)
        onBurn(log.args, log);
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/dex.js
var dex_exports = {};
__export(dex_exports, {
  buy: () => buy,
  buySync: () => buySync,
  cancel: () => cancel,
  cancelStale: () => cancelStale,
  cancelStaleSync: () => cancelStaleSync,
  cancelSync: () => cancelSync,
  createPair: () => createPair,
  createPairSync: () => createPairSync,
  getBalance: () => getBalance,
  getBuyQuote: () => getBuyQuote,
  getOrder: () => getOrder,
  getOrderbook: () => getOrderbook,
  getSellQuote: () => getSellQuote,
  getTickLevel: () => getTickLevel,
  place: () => place,
  placeFlip: () => placeFlip,
  placeFlipSync: () => placeFlipSync,
  placeSync: () => placeSync,
  sell: () => sell,
  sellSync: () => sellSync,
  watchFlipOrderPlaced: () => watchFlipOrderPlaced,
  watchOrderCancelled: () => watchOrderCancelled,
  watchOrderFilled: () => watchOrderFilled,
  watchOrderPlaced: () => watchOrderPlaced,
  withdraw: () => withdraw,
  withdrawSync: () => withdrawSync
});
async function buy(client, parameters) {
  return buy.inner(writeContract, client, parameters);
}
(function(buy2) {
  async function inner(action, client, parameters) {
    const { tokenIn, tokenOut, amountOut, maxAmountIn, ...rest } = parameters;
    const call2 = buy2.call({ tokenIn, tokenOut, amountOut, maxAmountIn });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  buy2.inner = inner;
  function call(args) {
    const { tokenIn, tokenOut, amountOut, maxAmountIn } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "swapExactAmountOut",
      args: [tokenIn, tokenOut, amountOut, maxAmountIn]
    });
  }
  buy2.call = call;
})(buy || (buy = {}));
async function buySync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await buy.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
async function cancel(client, parameters) {
  return cancel.inner(writeContract, client, parameters);
}
(function(cancel2) {
  async function inner(action, client, parameters) {
    const { orderId, ...rest } = parameters;
    const call2 = cancel2.call({ orderId });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  cancel2.inner = inner;
  function call(args) {
    const { orderId } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "cancel",
      args: [orderId]
    });
  }
  cancel2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: stablecoinDex,
      logs,
      eventName: "OrderCancelled",
      strict: true
    });
    if (!log)
      throw new Error("`OrderCancelled` event not found.");
    return log;
  }
  cancel2.extractEvent = extractEvent;
})(cancel || (cancel = {}));
async function cancelSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await cancel.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = cancel.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function cancelStale(client, parameters) {
  return cancelStale.inner(writeContract, client, parameters);
}
(function(cancelStale2) {
  async function inner(action, client, parameters) {
    const { orderId, ...rest } = parameters;
    const call2 = cancelStale2.call({ orderId });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  cancelStale2.inner = inner;
  function call(args) {
    const { orderId } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "cancelStaleOrder",
      args: [orderId]
    });
  }
  cancelStale2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: stablecoinDex,
      logs,
      eventName: "OrderCancelled",
      strict: true
    });
    if (!log)
      throw new Error("`OrderCancelled` event not found.");
    return log;
  }
  cancelStale2.extractEvent = extractEvent;
})(cancelStale || (cancelStale = {}));
async function cancelStaleSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await cancelStale.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = cancelStale.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function createPair(client, parameters) {
  return createPair.inner(writeContract, client, parameters);
}
(function(createPair2) {
  async function inner(action, client, parameters) {
    const { base, ...rest } = parameters;
    const call2 = createPair2.call({ base });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  createPair2.inner = inner;
  function call(args) {
    const { base } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "createPair",
      args: [base]
    });
  }
  createPair2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: stablecoinDex,
      logs,
      eventName: "PairCreated",
      strict: true
    });
    if (!log)
      throw new Error("`PairCreated` event not found.");
    return log;
  }
  createPair2.extractEvent = extractEvent;
})(createPair || (createPair = {}));
async function createPairSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await createPair.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = createPair.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function getBalance(client, parameters) {
  const { account: acc = client.account, token, ...rest } = parameters;
  const address = acc ? parseAccount(acc).address : void 0;
  if (!address)
    throw new Error("account is required.");
  return readContract(client, {
    ...rest,
    ...getBalance.call({ account: address, token })
  });
}
(function(getBalance3) {
  function call(args) {
    const { account, token } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [account, token],
      functionName: "balanceOf"
    });
  }
  getBalance3.call = call;
})(getBalance || (getBalance = {}));
async function getBuyQuote(client, parameters) {
  const { tokenIn, tokenOut, amountOut, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getBuyQuote.call({ tokenIn, tokenOut, amountOut })
  });
}
(function(getBuyQuote2) {
  function call(args) {
    const { tokenIn, tokenOut, amountOut } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [tokenIn, tokenOut, amountOut],
      functionName: "quoteSwapExactAmountOut"
    });
  }
  getBuyQuote2.call = call;
})(getBuyQuote || (getBuyQuote = {}));
async function getOrder(client, parameters) {
  const { orderId, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getOrder.call({ orderId })
  });
}
(function(getOrder2) {
  function call(args) {
    const { orderId } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [orderId],
      functionName: "getOrder"
    });
  }
  getOrder2.call = call;
})(getOrder || (getOrder = {}));
async function getOrderbook(client, parameters) {
  const { base, quote, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getOrderbook.call({ base, quote })
  });
}
(function(getOrderbook2) {
  function call(args) {
    const { base, quote } = args;
    const pairKey = getPairKey(base, quote);
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [pairKey],
      functionName: "books"
    });
  }
  getOrderbook2.call = call;
})(getOrderbook || (getOrderbook = {}));
async function getTickLevel(client, parameters) {
  const { base, tick, isBid, ...rest } = parameters;
  const [head, tail, totalLiquidity] = await readContract(client, {
    ...rest,
    ...getTickLevel.call({ base, tick, isBid })
  });
  return { head, tail, totalLiquidity };
}
(function(getTickLevel2) {
  function call(args) {
    const { base, tick, isBid } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [base, tick, isBid],
      functionName: "getTickLevel"
    });
  }
  getTickLevel2.call = call;
})(getTickLevel || (getTickLevel = {}));
async function getSellQuote(client, parameters) {
  const { tokenIn, tokenOut, amountIn, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getSellQuote.call({ tokenIn, tokenOut, amountIn })
  });
}
(function(getSellQuote2) {
  function call(args) {
    const { tokenIn, tokenOut, amountIn } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      args: [tokenIn, tokenOut, amountIn],
      functionName: "quoteSwapExactAmountIn"
    });
  }
  getSellQuote2.call = call;
})(getSellQuote || (getSellQuote = {}));
async function place(client, parameters) {
  return place.inner(writeContract, client, parameters);
}
(function(place2) {
  async function inner(action, client, parameters) {
    const { amount, token, type, tick, ...rest } = parameters;
    const call2 = place2.call({ amount, token, type, tick });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  place2.inner = inner;
  function call(args) {
    const { token, amount, type, tick } = args;
    const isBid = type === "buy";
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "place",
      args: [token, amount, isBid, tick]
    });
  }
  place2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: stablecoinDex,
      logs,
      eventName: "OrderPlaced",
      strict: true
    });
    if (!log)
      throw new Error("`OrderPlaced` event not found.");
    return log;
  }
  place2.extractEvent = extractEvent;
})(place || (place = {}));
async function placeFlip(client, parameters) {
  return placeFlip.inner(writeContract, client, parameters);
}
(function(placeFlip2) {
  async function inner(action, client, parameters) {
    const { amount, flipTick, tick, token, type, ...rest } = parameters;
    const call2 = placeFlip2.call({ amount, flipTick, tick, token, type });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  placeFlip2.inner = inner;
  function call(args) {
    const { token, amount, type, tick, flipTick } = args;
    const isBid = type === "buy";
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "placeFlip",
      args: [token, amount, isBid, tick, flipTick]
    });
  }
  placeFlip2.call = call;
  function extractEvent(logs) {
    const parsedLogs = parseEventLogs({
      abi: stablecoinDex,
      logs,
      eventName: "OrderPlaced",
      strict: true
    });
    const log = parsedLogs.find((l) => l.args.isFlipOrder);
    if (!log)
      throw new Error("`OrderPlaced` event (flip order) not found.");
    return log;
  }
  placeFlip2.extractEvent = extractEvent;
})(placeFlip || (placeFlip = {}));
async function placeFlipSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await placeFlip.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = placeFlip.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function placeSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await place.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = place.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function sell(client, parameters) {
  return sell.inner(writeContract, client, parameters);
}
(function(sell2) {
  async function inner(action, client, parameters) {
    const { tokenIn, tokenOut, amountIn, minAmountOut, ...rest } = parameters;
    const call2 = sell2.call({ tokenIn, tokenOut, amountIn, minAmountOut });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  sell2.inner = inner;
  function call(args) {
    const { tokenIn, tokenOut, amountIn, minAmountOut } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "swapExactAmountIn",
      args: [tokenIn, tokenOut, amountIn, minAmountOut]
    });
  }
  sell2.call = call;
})(sell || (sell = {}));
async function sellSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await sell.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
function watchFlipOrderPlaced(client, parameters) {
  const { onFlipOrderPlaced, maker, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: stablecoinDex2,
    abi: stablecoinDex,
    eventName: "OrderPlaced",
    args: {
      ...maker !== void 0 && { maker },
      ...token !== void 0 && { token }
    },
    onLogs: (logs) => {
      for (const log of logs) {
        if (log.args.isFlipOrder)
          onFlipOrderPlaced(log.args, log);
      }
    },
    strict: true
  });
}
function watchOrderCancelled(client, parameters) {
  const { onOrderCancelled, orderId, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: stablecoinDex2,
    abi: stablecoinDex,
    eventName: "OrderCancelled",
    args: orderId !== void 0 ? { orderId } : void 0,
    onLogs: (logs) => {
      for (const log of logs)
        onOrderCancelled(log.args, log);
    },
    strict: true
  });
}
function watchOrderFilled(client, parameters) {
  const { onOrderFilled, maker, taker, orderId, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: stablecoinDex2,
    abi: stablecoinDex,
    eventName: "OrderFilled",
    args: {
      ...orderId !== void 0 && { orderId },
      ...maker !== void 0 && { maker },
      ...taker !== void 0 && { taker }
    },
    onLogs: (logs) => {
      for (const log of logs)
        onOrderFilled(log.args, log);
    },
    strict: true
  });
}
function watchOrderPlaced(client, parameters) {
  const { onOrderPlaced, maker, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: stablecoinDex2,
    abi: stablecoinDex,
    eventName: "OrderPlaced",
    args: {
      ...maker !== void 0 && { maker },
      ...token !== void 0 && { token }
    },
    onLogs: (logs) => {
      for (const log of logs)
        onOrderPlaced(log.args, log);
    },
    strict: true
  });
}
async function withdraw(client, parameters) {
  return withdraw.inner(writeContract, client, parameters);
}
(function(withdraw2) {
  async function inner(action, client, parameters) {
    const { token, amount, ...rest } = parameters;
    const call2 = withdraw2.call({ token, amount });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  withdraw2.inner = inner;
  function call(args) {
    const { token, amount } = args;
    return defineCall({
      address: stablecoinDex2,
      abi: stablecoinDex,
      functionName: "withdraw",
      args: [token, amount]
    });
  }
  withdraw2.call = call;
})(withdraw || (withdraw = {}));
async function withdrawSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await withdraw.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
function getPairKey(base, quote) {
  return keccak2562(concat(base, quote));
}

// node_modules/viem/_esm/tempo/actions/faucet.js
var faucet_exports = {};
__export(faucet_exports, {
  fund: () => fund,
  fundSync: () => fundSync
});
async function fund(client, parameters) {
  const account = parseAccount(parameters.account);
  return client.request({
    method: "tempo_fundAddress",
    params: [account.address]
  });
}
async function fundSync(client, parameters) {
  const { timeout = 1e4 } = parameters;
  const account = parseAccount(parameters.account);
  const hashes = await client.request({
    method: "tempo_fundAddress",
    params: [account.address]
  });
  const receipts = await Promise.all(hashes.map((hash) => waitForTransactionReceipt(client, {
    hash,
    checkReplacement: false,
    timeout
  })));
  return receipts;
}

// node_modules/viem/_esm/tempo/actions/fee.js
var fee_exports = {};
__export(fee_exports, {
  getUserToken: () => getUserToken,
  getValidatorToken: () => getValidatorToken,
  setUserToken: () => setUserToken,
  setUserTokenSync: () => setUserTokenSync,
  setValidatorToken: () => setValidatorToken,
  setValidatorTokenSync: () => setValidatorTokenSync,
  watchSetUserToken: () => watchSetUserToken,
  watchSetValidatorToken: () => watchSetValidatorToken
});
async function getUserToken(client, ...parameters) {
  const { account: account_ = client.account, ...rest } = parameters[0] ?? {};
  if (!account_)
    throw new Error("account is required.");
  const account = parseAccount(account_);
  const address = await readContract(client, {
    ...rest,
    ...getUserToken.call({ account: account.address })
  });
  if (address === zeroAddress)
    return null;
  return {
    address,
    id: TokenId_exports.fromAddress(address)
  };
}
(function(getUserToken2) {
  function call(args) {
    const { account } = args;
    return defineCall({
      address: feeManager2,
      abi: feeManager,
      args: [account],
      functionName: "userTokens"
    });
  }
  getUserToken2.call = call;
})(getUserToken || (getUserToken = {}));
async function setUserToken(client, parameters) {
  return setUserToken.inner(writeContract, client, parameters);
}
(function(setUserToken2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = setUserToken2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setUserToken2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: feeManager2,
      abi: feeManager,
      functionName: "setUserToken",
      args: [TokenId_exports.toAddress(token)]
    });
  }
  setUserToken2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: feeManager,
      logs,
      eventName: "UserTokenSet",
      strict: true
    });
    if (!log)
      throw new Error("`UserTokenSet` event not found.");
    return log;
  }
  setUserToken2.extractEvent = extractEvent;
})(setUserToken || (setUserToken = {}));
async function setUserTokenSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setUserToken.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setUserToken.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
function watchSetUserToken(client, parameters) {
  const { onUserTokenSet, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: feeManager2,
    abi: feeManager,
    eventName: "UserTokenSet",
    onLogs: (logs) => {
      for (const log of logs)
        onUserTokenSet(log.args, log);
    },
    strict: true
  });
}
async function getValidatorToken(client, parameters) {
  const { validator: validator3, ...rest } = parameters;
  const address = await readContract(client, {
    ...rest,
    ...getValidatorToken.call({ validator: validator3 })
  });
  if (address === zeroAddress)
    return null;
  return {
    address,
    id: TokenId_exports.fromAddress(address)
  };
}
(function(getValidatorToken2) {
  function call(args) {
    const { validator: validator3 } = args;
    return defineCall({
      address: feeManager2,
      abi: feeManager,
      args: [validator3],
      functionName: "validatorTokens"
    });
  }
  getValidatorToken2.call = call;
})(getValidatorToken || (getValidatorToken = {}));
async function setValidatorToken(client, parameters) {
  return setValidatorToken.inner(writeContract, client, parameters);
}
(function(setValidatorToken2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = setValidatorToken2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setValidatorToken2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: feeManager2,
      abi: feeManager,
      functionName: "setValidatorToken",
      args: [TokenId_exports.toAddress(token)]
    });
  }
  setValidatorToken2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: feeManager,
      logs,
      eventName: "ValidatorTokenSet",
      strict: true
    });
    if (!log)
      throw new Error("`ValidatorTokenSet` event not found.");
    return log;
  }
  setValidatorToken2.extractEvent = extractEvent;
})(setValidatorToken || (setValidatorToken = {}));
async function setValidatorTokenSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setValidatorToken.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setValidatorToken.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
function watchSetValidatorToken(client, parameters) {
  const { onValidatorTokenSet, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: feeManager2,
    abi: feeManager,
    eventName: "ValidatorTokenSet",
    onLogs: (logs) => {
      for (const log of logs)
        onValidatorTokenSet(log.args, log);
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/nonce.js
var nonce_exports = {};
__export(nonce_exports, {
  getNonce: () => getNonce,
  watchNonceIncremented: () => watchNonceIncremented
});
async function getNonce(client, parameters) {
  const { account, nonceKey, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getNonce.call({ account, nonceKey })
  });
}
(function(getNonce2) {
  function call(args) {
    const { account, nonceKey } = args;
    return defineCall({
      address: nonceManager,
      abi: nonce,
      args: [account, nonceKey],
      functionName: "getNonce"
    });
  }
  getNonce2.call = call;
})(getNonce || (getNonce = {}));
function watchNonceIncremented(client, parameters) {
  const { onNonceIncremented, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: nonceManager,
    abi: nonce,
    eventName: "NonceIncremented",
    onLogs: (logs) => {
      for (const log of logs)
        onNonceIncremented(log.args, log);
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/policy.js
var policy_exports = {};
__export(policy_exports, {
  create: () => create,
  createSync: () => createSync,
  getData: () => getData,
  isAuthorized: () => isAuthorized,
  modifyBlacklist: () => modifyBlacklist,
  modifyBlacklistSync: () => modifyBlacklistSync,
  modifyWhitelist: () => modifyWhitelist,
  modifyWhitelistSync: () => modifyWhitelistSync,
  setAdmin: () => setAdmin,
  setAdminSync: () => setAdminSync,
  watchAdminUpdated: () => watchAdminUpdated,
  watchBlacklistUpdated: () => watchBlacklistUpdated,
  watchCreate: () => watchCreate,
  watchWhitelistUpdated: () => watchWhitelistUpdated
});
var policyTypeMap = {
  whitelist: 0,
  blacklist: 1
};
async function create(client, parameters) {
  return create.inner(writeContract, client, parameters);
}
(function(create3) {
  async function inner(action, client, parameters) {
    const { account = client.account, addresses, chain = client.chain, type, ...rest } = parameters;
    if (!account)
      throw new Error("`account` is required");
    const admin = parseAccount(account).address;
    const call2 = create3.call({ admin, type, addresses });
    return action(client, {
      ...rest,
      account,
      chain,
      ...call2
    });
  }
  create3.inner = inner;
  function call(args) {
    const { admin, type, addresses } = args;
    const config = (() => {
      if (addresses)
        return {
          functionName: "createPolicyWithAccounts",
          args: [admin, policyTypeMap[type], addresses]
        };
      return {
        functionName: "createPolicy",
        args: [admin, policyTypeMap[type]]
      };
    })();
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      ...config
    });
  }
  create3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip403Registry,
      logs,
      eventName: "PolicyCreated",
      strict: true
    });
    if (!log)
      throw new Error("`PolicyCreated` event not found.");
    return log;
  }
  create3.extractEvent = extractEvent;
})(create || (create = {}));
async function createSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await create.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = create.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function setAdmin(client, parameters) {
  return setAdmin.inner(writeContract, client, parameters);
}
(function(setAdmin2) {
  async function inner(action, client, parameters) {
    const { policyId, admin, ...rest } = parameters;
    const call2 = setAdmin2.call({ policyId, admin });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setAdmin2.inner = inner;
  function call(args) {
    const { policyId, admin } = args;
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      functionName: "setPolicyAdmin",
      args: [policyId, admin]
    });
  }
  setAdmin2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip403Registry,
      logs,
      eventName: "PolicyAdminUpdated",
      strict: true
    });
    if (!log)
      throw new Error("`PolicyAdminUpdated` event not found.");
    return log;
  }
  setAdmin2.extractEvent = extractEvent;
})(setAdmin || (setAdmin = {}));
async function setAdminSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setAdmin.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setAdmin.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function modifyWhitelist(client, parameters) {
  return modifyWhitelist.inner(writeContract, client, parameters);
}
(function(modifyWhitelist2) {
  async function inner(action, client, parameters) {
    const { address: targetAccount, allowed, policyId, ...rest } = parameters;
    const call2 = modifyWhitelist2.call({
      address: targetAccount,
      allowed,
      policyId
    });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  modifyWhitelist2.inner = inner;
  function call(args) {
    const { policyId, address, allowed } = args;
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      functionName: "modifyPolicyWhitelist",
      args: [policyId, address, allowed]
    });
  }
  modifyWhitelist2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip403Registry,
      logs,
      eventName: "WhitelistUpdated",
      strict: true
    });
    if (!log)
      throw new Error("`WhitelistUpdated` event not found.");
    return log;
  }
  modifyWhitelist2.extractEvent = extractEvent;
})(modifyWhitelist || (modifyWhitelist = {}));
async function modifyWhitelistSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await modifyWhitelist.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = modifyWhitelist.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function modifyBlacklist(client, parameters) {
  return modifyBlacklist.inner(writeContract, client, parameters);
}
(function(modifyBlacklist2) {
  async function inner(action, client, parameters) {
    const { address: targetAccount, policyId, restricted, ...rest } = parameters;
    const call2 = modifyBlacklist2.call({
      address: targetAccount,
      policyId,
      restricted
    });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  modifyBlacklist2.inner = inner;
  function call(args) {
    const { policyId, address, restricted } = args;
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      functionName: "modifyPolicyBlacklist",
      args: [policyId, address, restricted]
    });
  }
  modifyBlacklist2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip403Registry,
      logs,
      eventName: "BlacklistUpdated",
      strict: true
    });
    if (!log)
      throw new Error("`BlacklistUpdated` event not found.");
    return log;
  }
  modifyBlacklist2.extractEvent = extractEvent;
})(modifyBlacklist || (modifyBlacklist = {}));
async function modifyBlacklistSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await modifyBlacklist.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = modifyBlacklist.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function getData(client, parameters) {
  const { policyId, ...rest } = parameters;
  const result = await readContract(client, {
    ...rest,
    ...getData.call({ policyId })
  });
  return {
    admin: result[1],
    type: result[0] === 0 ? "whitelist" : "blacklist"
  };
}
(function(getData2) {
  function call(args) {
    const { policyId } = args;
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      args: [policyId],
      functionName: "policyData"
    });
  }
  getData2.call = call;
})(getData || (getData = {}));
async function isAuthorized(client, parameters) {
  const { policyId, user, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...isAuthorized.call({ policyId, user })
  });
}
(function(isAuthorized2) {
  function call(args) {
    const { policyId, user } = args;
    return defineCall({
      address: tip403Registry2,
      abi: tip403Registry,
      args: [policyId, user],
      functionName: "isAuthorized"
    });
  }
  isAuthorized2.call = call;
})(isAuthorized || (isAuthorized = {}));
function watchCreate(client, parameters) {
  const { onPolicyCreated, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: tip403Registry2,
    abi: tip403Registry,
    eventName: "PolicyCreated",
    onLogs: (logs) => {
      for (const log of logs)
        onPolicyCreated({
          ...log.args,
          type: log.args.policyType === 0 ? "whitelist" : "blacklist"
        }, log);
    },
    strict: true
  });
}
function watchAdminUpdated(client, parameters) {
  const { onAdminUpdated, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: tip403Registry2,
    abi: tip403Registry,
    eventName: "PolicyAdminUpdated",
    onLogs: (logs) => {
      for (const log of logs)
        onAdminUpdated(log.args, log);
    },
    strict: true
  });
}
function watchWhitelistUpdated(client, parameters) {
  const { onWhitelistUpdated, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: tip403Registry2,
    abi: tip403Registry,
    eventName: "WhitelistUpdated",
    onLogs: (logs) => {
      for (const log of logs)
        onWhitelistUpdated(log.args, log);
    },
    strict: true
  });
}
function watchBlacklistUpdated(client, parameters) {
  const { onBlacklistUpdated, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: tip403Registry2,
    abi: tip403Registry,
    eventName: "BlacklistUpdated",
    onLogs: (logs) => {
      for (const log of logs)
        onBlacklistUpdated(log.args, log);
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/reward.js
var reward_exports = {};
__export(reward_exports, {
  claim: () => claim,
  claimSync: () => claimSync,
  distribute: () => distribute,
  distributeSync: () => distributeSync,
  getGlobalRewardPerToken: () => getGlobalRewardPerToken,
  getPendingRewards: () => getPendingRewards,
  getUserRewardInfo: () => getUserRewardInfo,
  setRecipient: () => setRecipient,
  setRecipientSync: () => setRecipientSync,
  watchRewardDistributed: () => watchRewardDistributed,
  watchRewardRecipientSet: () => watchRewardRecipientSet
});
async function claim(client, parameters) {
  return claim.inner(writeContract, client, parameters);
}
(function(claim2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = claim2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  claim2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [],
      functionName: "claimRewards"
    });
  }
  claim2.call = call;
})(claim || (claim = {}));
async function claimSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await claim.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return {
    receipt
  };
}
async function distribute(client, parameters) {
  return distribute.inner(writeContract, client, parameters);
}
async function distributeSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await distribute.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = distribute.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
(function(distribute2) {
  async function inner(action, client, parameters) {
    const { amount, token, ...rest } = parameters;
    const call2 = distribute2.call({ amount, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  distribute2.inner = inner;
  function call(args) {
    const { amount, token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [amount],
      functionName: "distributeReward"
    });
  }
  distribute2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RewardDistributed",
      strict: true
    });
    if (!log)
      throw new Error("`RewardDistributed` event not found.");
    return log;
  }
  distribute2.extractEvent = extractEvent;
})(distribute || (distribute = {}));
async function getGlobalRewardPerToken(client, parameters) {
  return readContract(client, {
    ...parameters,
    ...getGlobalRewardPerToken.call(parameters)
  });
}
(function(getGlobalRewardPerToken2) {
  function call(args) {
    const { token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [],
      functionName: "globalRewardPerToken"
    });
  }
  getGlobalRewardPerToken2.call = call;
})(getGlobalRewardPerToken || (getGlobalRewardPerToken = {}));
async function getPendingRewards(client, parameters) {
  return readContract(client, {
    ...parameters,
    ...getPendingRewards.call(parameters)
  });
}
(function(getPendingRewards2) {
  function call(args) {
    const { account, token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [account],
      functionName: "getPendingRewards"
    });
  }
  getPendingRewards2.call = call;
})(getPendingRewards || (getPendingRewards = {}));
async function getUserRewardInfo(client, parameters) {
  return readContract(client, {
    ...parameters,
    ...getUserRewardInfo.call(parameters)
  });
}
(function(getUserRewardInfo2) {
  function call(args) {
    const { account, token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [account],
      functionName: "userRewardInfo"
    });
  }
  getUserRewardInfo2.call = call;
})(getUserRewardInfo || (getUserRewardInfo = {}));
async function setRecipient(client, parameters) {
  return setRecipient.inner(writeContract, client, parameters);
}
async function setRecipientSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setRecipient.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setRecipient.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
(function(setRecipient2) {
  async function inner(action, client, parameters) {
    const { recipient, token, ...rest } = parameters;
    const call2 = setRecipient2.call({ recipient, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setRecipient2.inner = inner;
  function call(args) {
    const { recipient, token } = args;
    return defineCall({
      address: token,
      abi: tip20,
      args: [recipient],
      functionName: "setRewardRecipient"
    });
  }
  setRecipient2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RewardRecipientSet",
      strict: true
    });
    if (!log)
      throw new Error("`RewardRecipientSet` event not found.");
    return log;
  }
  setRecipient2.extractEvent = extractEvent;
})(setRecipient || (setRecipient = {}));
function watchRewardDistributed(client, parameters) {
  const { onRewardDistributed, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: token,
    abi: tip20,
    eventName: "RewardDistributed",
    onLogs: (logs) => {
      for (const log of logs)
        onRewardDistributed(log.args, log);
    },
    strict: true
  });
}
function watchRewardRecipientSet(client, parameters) {
  const { onRewardRecipientSet, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: token,
    abi: tip20,
    eventName: "RewardRecipientSet",
    onLogs: (logs) => {
      for (const log of logs)
        onRewardRecipientSet(log.args, log);
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/token.js
var token_exports = {};
__export(token_exports, {
  approve: () => approve,
  approveSync: () => approveSync,
  burn: () => burn2,
  burnBlocked: () => burnBlocked,
  burnBlockedSync: () => burnBlockedSync,
  burnSync: () => burnSync2,
  changeTransferPolicy: () => changeTransferPolicy,
  changeTransferPolicySync: () => changeTransferPolicySync,
  create: () => create2,
  createSync: () => createSync2,
  getAllowance: () => getAllowance,
  getBalance: () => getBalance2,
  getMetadata: () => getMetadata,
  getRoleAdmin: () => getRoleAdmin,
  grantRoles: () => grantRoles,
  grantRolesSync: () => grantRolesSync,
  hasRole: () => hasRole,
  mint: () => mint2,
  mintSync: () => mintSync2,
  pause: () => pause,
  pauseSync: () => pauseSync,
  prepareUpdateQuoteToken: () => prepareUpdateQuoteToken,
  prepareUpdateQuoteTokenSync: () => prepareUpdateQuoteTokenSync,
  renounceRoles: () => renounceRoles,
  renounceRolesSync: () => renounceRolesSync,
  revokeRoles: () => revokeRoles,
  revokeRolesSync: () => revokeRolesSync,
  setRoleAdmin: () => setRoleAdmin,
  setRoleAdminSync: () => setRoleAdminSync,
  setSupplyCap: () => setSupplyCap,
  setSupplyCapSync: () => setSupplyCapSync,
  transfer: () => transfer,
  transferSync: () => transferSync,
  unpause: () => unpause,
  unpauseSync: () => unpauseSync,
  updateQuoteToken: () => updateQuoteToken,
  updateQuoteTokenSync: () => updateQuoteTokenSync,
  watchAdminRole: () => watchAdminRole,
  watchApprove: () => watchApprove,
  watchBurn: () => watchBurn2,
  watchCreate: () => watchCreate2,
  watchMint: () => watchMint2,
  watchRole: () => watchRole,
  watchTransfer: () => watchTransfer,
  watchUpdateQuoteToken: () => watchUpdateQuoteToken
});
async function approve(client, parameters) {
  const { token, ...rest } = parameters;
  return approve.inner(writeContract, client, parameters, { ...rest, token });
}
(function(approve2) {
  async function inner(action, client, parameters, args) {
    const call2 = approve2.call(args);
    return await action(client, {
      ...parameters,
      ...call2
    });
  }
  approve2.inner = inner;
  function call(args) {
    const { spender, amount, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "approve",
      args: [spender, amount]
    });
  }
  approve2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "Approval"
    });
    if (!log)
      throw new Error("`Approval` event not found.");
    return log;
  }
  approve2.extractEvent = extractEvent;
})(approve || (approve = {}));
async function approveSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await approve.inner(writeContractSync, client, { ...parameters, throwOnReceiptRevert }, rest);
  const { args } = approve.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function burnBlocked(client, parameters) {
  return burnBlocked.inner(writeContract, client, parameters);
}
(function(burnBlocked2) {
  async function inner(action, client, parameters) {
    const { amount, from: from5, token, ...rest } = parameters;
    const call2 = burnBlocked2.call({ amount, from: from5, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  burnBlocked2.inner = inner;
  function call(args) {
    const { from: from5, amount, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "burnBlocked",
      args: [from5, amount]
    });
  }
  burnBlocked2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "BurnBlocked"
    });
    if (!log)
      throw new Error("`BurnBlocked` event not found.");
    return log;
  }
  burnBlocked2.extractEvent = extractEvent;
})(burnBlocked || (burnBlocked = {}));
async function burnBlockedSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await burnBlocked.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = burnBlocked.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function burn2(client, parameters) {
  return burn2.inner(writeContract, client, parameters);
}
(function(burn3) {
  async function inner(action, client, parameters) {
    const { amount, memo, token, ...rest } = parameters;
    const call2 = burn3.call({ amount, memo, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  burn3.inner = inner;
  function call(args) {
    const { amount, memo, token } = args;
    const callArgs = memo ? {
      functionName: "burnWithMemo",
      args: [amount, padLeft(memo, 32)]
    } : {
      functionName: "burn",
      args: [amount]
    };
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      ...callArgs
    });
  }
  burn3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "Burn"
    });
    if (!log)
      throw new Error("`Burn` event not found.");
    return log;
  }
  burn3.extractEvent = extractEvent;
})(burn2 || (burn2 = {}));
async function burnSync2(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await burn2.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = burn2.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function changeTransferPolicy(client, parameters) {
  return changeTransferPolicy.inner(writeContract, client, parameters);
}
(function(changeTransferPolicy2) {
  async function inner(action, client, parameters) {
    const { policyId, token, ...rest } = parameters;
    const call2 = changeTransferPolicy2.call({ policyId, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  changeTransferPolicy2.inner = inner;
  function call(args) {
    const { token, policyId } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "changeTransferPolicyId",
      args: [policyId]
    });
  }
  changeTransferPolicy2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "TransferPolicyUpdate"
    });
    if (!log)
      throw new Error("`TransferPolicyUpdate` event not found.");
    return log;
  }
  changeTransferPolicy2.extractEvent = extractEvent;
})(changeTransferPolicy || (changeTransferPolicy = {}));
async function changeTransferPolicySync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await changeTransferPolicy.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = changeTransferPolicy.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function create2(client, parameters) {
  return create2.inner(writeContract, client, parameters);
}
(function(create3) {
  async function inner(action, client, parameters) {
    const { account = client.account, admin: admin_ = client.account, chain = client.chain, ...rest } = parameters;
    const admin = admin_ ? parseAccount(admin_) : void 0;
    if (!admin)
      throw new Error("admin is required.");
    const call2 = create3.call({ ...rest, admin: admin.address });
    return await action(client, {
      ...parameters,
      account,
      chain,
      ...call2
    });
  }
  create3.inner = inner;
  function call(args) {
    const { name, symbol, currency, quoteToken = pathUsd, admin, salt = random(32) } = args;
    return defineCall({
      address: tip20Factory2,
      abi: tip20Factory,
      args: [
        name,
        symbol,
        currency,
        TokenId_exports.toAddress(quoteToken),
        admin,
        salt
      ],
      functionName: "createToken"
    });
  }
  create3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20Factory,
      logs,
      eventName: "TokenCreated",
      strict: true
    });
    if (!log)
      throw new Error("`TokenCreated` event not found.");
    return log;
  }
  create3.extractEvent = extractEvent;
})(create2 || (create2 = {}));
async function createSync2(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await create2.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = create2.extractEvent(receipt.logs);
  const tokenId = TokenId_exports.fromAddress(args.token);
  return {
    ...args,
    receipt,
    tokenId
  };
}
async function getAllowance(client, parameters) {
  const { account = client.account } = parameters;
  const address = account ? parseAccount(account).address : void 0;
  if (!address)
    throw new Error("account is required.");
  return readContract(client, {
    ...parameters,
    ...getAllowance.call({ ...parameters, account: address })
  });
}
(function(getAllowance2) {
  function call(args) {
    const { account, spender, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "allowance",
      args: [account, spender]
    });
  }
  getAllowance2.call = call;
})(getAllowance || (getAllowance = {}));
async function getBalance2(client, parameters) {
  const { account = client.account, ...rest } = parameters;
  const address = account ? parseAccount(account).address : void 0;
  if (!address)
    throw new Error("account is required.");
  return readContract(client, {
    ...rest,
    ...getBalance2.call({ account: address, ...rest })
  });
}
(function(getBalance3) {
  function call(args) {
    const { account, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "balanceOf",
      args: [account]
    });
  }
  getBalance3.call = call;
})(getBalance2 || (getBalance2 = {}));
async function getMetadata(client, parameters) {
  const { token, ...rest } = parameters;
  const address = TokenId_exports.toAddress(token);
  const abi = tip20;
  if (TokenId_exports.from(token) === TokenId_exports.fromAddress(pathUsd))
    return multicall(client, {
      ...rest,
      contracts: [
        {
          address,
          abi,
          functionName: "currency"
        },
        {
          address,
          abi,
          functionName: "decimals"
        },
        {
          address,
          abi,
          functionName: "name"
        },
        {
          address,
          abi,
          functionName: "symbol"
        },
        {
          address,
          abi,
          functionName: "totalSupply"
        }
      ],
      allowFailure: false,
      deployless: true
    }).then(([currency, decimals, name, symbol, totalSupply]) => ({
      name,
      symbol,
      currency,
      decimals,
      totalSupply
    }));
  return multicall(client, {
    ...rest,
    contracts: [
      {
        address,
        abi,
        functionName: "currency"
      },
      {
        address,
        abi,
        functionName: "decimals"
      },
      {
        address,
        abi,
        functionName: "quoteToken"
      },
      {
        address,
        abi,
        functionName: "name"
      },
      {
        address,
        abi,
        functionName: "paused"
      },
      {
        address,
        abi,
        functionName: "supplyCap"
      },
      {
        address,
        abi,
        functionName: "symbol"
      },
      {
        address,
        abi,
        functionName: "totalSupply"
      },
      {
        address,
        abi,
        functionName: "transferPolicyId"
      }
    ],
    allowFailure: false,
    deployless: true
  }).then(([currency, decimals, quoteToken, name, paused, supplyCap, symbol, totalSupply, transferPolicyId]) => ({
    name,
    symbol,
    currency,
    decimals,
    quoteToken,
    totalSupply,
    paused,
    supplyCap,
    transferPolicyId
  }));
}
async function getRoleAdmin(client, parameters) {
  return readContract(client, {
    ...parameters,
    ...getRoleAdmin.call(parameters)
  });
}
(function(getRoleAdmin2) {
  function call(args) {
    const { role, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "getRoleAdmin",
      args: [TokenRole_exports.serialize(role)]
    });
  }
  getRoleAdmin2.call = call;
})(getRoleAdmin || (getRoleAdmin = {}));
async function hasRole(client, parameters) {
  const { account = client.account } = parameters;
  const address = account ? parseAccount(account).address : void 0;
  if (!address)
    throw new Error("account is required.");
  return readContract(client, {
    ...parameters,
    ...hasRole.call({ ...parameters, account: address })
  });
}
(function(hasRole2) {
  function call(args) {
    const { account, role, token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "hasRole",
      args: [account, TokenRole_exports.serialize(role)]
    });
  }
  hasRole2.call = call;
})(hasRole || (hasRole = {}));
async function grantRoles(client, parameters) {
  return grantRoles.inner(sendTransaction, client, parameters);
}
(function(grantRoles2) {
  async function inner(action, client, parameters) {
    return await action(client, {
      ...parameters,
      calls: parameters.roles.map((role) => {
        const call2 = grantRoles2.call({ ...parameters, role });
        return {
          ...call2,
          data: encodeFunctionData(call2)
        };
      })
    });
  }
  grantRoles2.inner = inner;
  function call(args) {
    const { token, to, role } = args;
    const roleHash = TokenRole_exports.serialize(role);
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "grantRole",
      args: [roleHash, to]
    });
  }
  grantRoles2.call = call;
  function extractEvents(logs) {
    const events = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RoleMembershipUpdated"
    });
    if (events.length === 0)
      throw new Error("`RoleMembershipUpdated` events not found.");
    return events;
  }
  grantRoles2.extractEvents = extractEvents;
})(grantRoles || (grantRoles = {}));
async function grantRolesSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await grantRoles.inner(sendTransactionSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const events = grantRoles.extractEvents(receipt.logs);
  const value = events.map((event) => event.args);
  return {
    receipt,
    value
  };
}
async function mint2(client, parameters) {
  return mint2.inner(writeContract, client, parameters);
}
(function(mint3) {
  async function inner(action, client, parameters) {
    const call2 = mint3.call(parameters);
    return await action(client, {
      ...parameters,
      ...call2
    });
  }
  mint3.inner = inner;
  function call(args) {
    const { to, amount, memo, token } = args;
    const callArgs = memo ? {
      functionName: "mintWithMemo",
      args: [to, amount, padLeft(memo, 32)]
    } : {
      functionName: "mint",
      args: [to, amount]
    };
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      ...callArgs
    });
  }
  mint3.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "Mint"
    });
    if (!log)
      throw new Error("`Mint` event not found.");
    return log;
  }
  mint3.extractEvent = extractEvent;
})(mint2 || (mint2 = {}));
async function mintSync2(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await mint2.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = mint2.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function pause(client, parameters) {
  return pause.inner(writeContract, client, parameters);
}
(function(pause2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = pause2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  pause2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "pause",
      args: []
    });
  }
  pause2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "PauseStateUpdate"
    });
    if (!log)
      throw new Error("`PauseStateUpdate` event not found.");
    return log;
  }
  pause2.extractEvent = extractEvent;
})(pause || (pause = {}));
async function pauseSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await pause.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = pause.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function renounceRoles(client, parameters) {
  return renounceRoles.inner(sendTransaction, client, parameters);
}
(function(renounceRoles2) {
  async function inner(action, client, parameters) {
    return await action(client, {
      ...parameters,
      calls: parameters.roles.map((role) => {
        const call2 = renounceRoles2.call({ ...parameters, role });
        return {
          ...call2,
          data: encodeFunctionData(call2)
        };
      })
    });
  }
  renounceRoles2.inner = inner;
  function call(args) {
    const { token, role } = args;
    const roleHash = TokenRole_exports.serialize(role);
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "renounceRole",
      args: [roleHash]
    });
  }
  renounceRoles2.call = call;
  function extractEvents(logs) {
    const events = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RoleMembershipUpdated"
    });
    if (events.length === 0)
      throw new Error("`RoleMembershipUpdated` events not found.");
    return events;
  }
  renounceRoles2.extractEvents = extractEvents;
})(renounceRoles || (renounceRoles = {}));
async function renounceRolesSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await renounceRoles.inner(sendTransactionSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const events = renounceRoles.extractEvents(receipt.logs);
  const value = events.map((event) => event.args);
  return {
    receipt,
    value
  };
}
async function revokeRoles(client, parameters) {
  return revokeRoles.inner(sendTransaction, client, parameters);
}
(function(revokeRoles2) {
  async function inner(action, client, parameters) {
    return await action(client, {
      ...parameters,
      calls: parameters.roles.map((role) => {
        const call2 = revokeRoles2.call({ ...parameters, role });
        return {
          ...call2,
          data: encodeFunctionData(call2)
        };
      })
    });
  }
  revokeRoles2.inner = inner;
  function call(args) {
    const { token, from: from5, role } = args;
    const roleHash = TokenRole_exports.serialize(role);
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "revokeRole",
      args: [roleHash, from5]
    });
  }
  revokeRoles2.call = call;
  function extractEvents(logs) {
    const events = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RoleMembershipUpdated"
    });
    if (events.length === 0)
      throw new Error("`RoleMembershipUpdated` events not found.");
    return events;
  }
  revokeRoles2.extractEvents = extractEvents;
})(revokeRoles || (revokeRoles = {}));
async function revokeRolesSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await revokeRoles.inner(sendTransactionSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const events = revokeRoles.extractEvents(receipt.logs);
  const value = events.map((event) => event.args);
  return {
    receipt,
    value
  };
}
async function setSupplyCap(client, parameters) {
  return setSupplyCap.inner(writeContract, client, parameters);
}
(function(setSupplyCap2) {
  async function inner(action, client, parameters) {
    const { supplyCap, token, ...rest } = parameters;
    const call2 = setSupplyCap2.call({ supplyCap, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setSupplyCap2.inner = inner;
  function call(args) {
    const { token, supplyCap } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "setSupplyCap",
      args: [supplyCap]
    });
  }
  setSupplyCap2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "SupplyCapUpdate"
    });
    if (!log)
      throw new Error("`SupplyCapUpdate` event not found.");
    return log;
  }
  setSupplyCap2.extractEvent = extractEvent;
})(setSupplyCap || (setSupplyCap = {}));
async function setSupplyCapSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setSupplyCap.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setSupplyCap.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function setRoleAdmin(client, parameters) {
  return setRoleAdmin.inner(writeContract, client, parameters);
}
(function(setRoleAdmin2) {
  async function inner(action, client, parameters) {
    const { adminRole, role, token, ...rest } = parameters;
    const call2 = setRoleAdmin2.call({ adminRole, role, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  setRoleAdmin2.inner = inner;
  function call(args) {
    const { token, role, adminRole } = args;
    const roleHash = TokenRole_exports.serialize(role);
    const adminRoleHash = TokenRole_exports.serialize(adminRole);
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "setRoleAdmin",
      args: [roleHash, adminRoleHash]
    });
  }
  setRoleAdmin2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "RoleAdminUpdated"
    });
    if (!log)
      throw new Error("`RoleAdminUpdated` event not found.");
    return log;
  }
  setRoleAdmin2.extractEvent = extractEvent;
})(setRoleAdmin || (setRoleAdmin = {}));
async function setRoleAdminSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setRoleAdmin.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = setRoleAdmin.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function transfer(client, parameters) {
  return transfer.inner(writeContract, client, parameters);
}
(function(transfer2) {
  async function inner(action, client, parameters) {
    const { amount, from: from5, memo, token, to, ...rest } = parameters;
    const call2 = transfer2.call({ amount, from: from5, memo, token, to });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  transfer2.inner = inner;
  function call(args) {
    const { amount, from: from5, memo, token, to } = args;
    const callArgs = (() => {
      if (memo && from5)
        return {
          functionName: "transferFromWithMemo",
          args: [from5, to, amount, padLeft(memo, 32)]
        };
      if (memo)
        return {
          functionName: "transferWithMemo",
          args: [to, amount, padLeft(memo, 32)]
        };
      if (from5)
        return {
          functionName: "transferFrom",
          args: [from5, to, amount]
        };
      return {
        functionName: "transfer",
        args: [to, amount]
      };
    })();
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      ...callArgs
    });
  }
  transfer2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "Transfer"
    });
    if (!log)
      throw new Error("`Transfer` event not found.");
    return log;
  }
  transfer2.extractEvent = extractEvent;
})(transfer || (transfer = {}));
async function transferSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await transfer.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = transfer.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function unpause(client, parameters) {
  return unpause.inner(writeContract, client, parameters);
}
(function(unpause2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = unpause2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  unpause2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "unpause",
      args: []
    });
  }
  unpause2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "PauseStateUpdate"
    });
    if (!log)
      throw new Error("`PauseStateUpdate` event not found.");
    return log;
  }
  unpause2.extractEvent = extractEvent;
})(unpause || (unpause = {}));
async function unpauseSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await unpause.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  const { args } = unpause.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function prepareUpdateQuoteToken(client, parameters) {
  return prepareUpdateQuoteToken.inner(writeContract, client, parameters);
}
(function(prepareUpdateQuoteToken2) {
  async function inner(action, client, parameters) {
    const { quoteToken, token, ...rest } = parameters;
    const call2 = prepareUpdateQuoteToken2.call({ quoteToken, token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  prepareUpdateQuoteToken2.inner = inner;
  function call(args) {
    const { token, quoteToken } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "setNextQuoteToken",
      args: [TokenId_exports.toAddress(quoteToken)]
    });
  }
  prepareUpdateQuoteToken2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "NextQuoteTokenSet"
    });
    if (!log)
      throw new Error("`NextQuoteTokenSet` event not found.");
    return log;
  }
  prepareUpdateQuoteToken2.extractEvent = extractEvent;
})(prepareUpdateQuoteToken || (prepareUpdateQuoteToken = {}));
async function prepareUpdateQuoteTokenSync(client, parameters) {
  const receipt = await prepareUpdateQuoteToken.inner(writeContractSync, client, parameters);
  const { args } = prepareUpdateQuoteToken.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
async function updateQuoteToken(client, parameters) {
  return updateQuoteToken.inner(writeContract, client, parameters);
}
(function(updateQuoteToken2) {
  async function inner(action, client, parameters) {
    const { token, ...rest } = parameters;
    const call2 = updateQuoteToken2.call({ token });
    return await action(client, {
      ...rest,
      ...call2
    });
  }
  updateQuoteToken2.inner = inner;
  function call(args) {
    const { token } = args;
    return defineCall({
      address: TokenId_exports.toAddress(token),
      abi: tip20,
      functionName: "completeQuoteTokenUpdate",
      args: []
    });
  }
  updateQuoteToken2.call = call;
  function extractEvent(logs) {
    const [log] = parseEventLogs({
      abi: tip20,
      logs,
      eventName: "QuoteTokenUpdate"
    });
    if (!log)
      throw new Error("`QuoteTokenUpdateCompleted` event not found.");
    return log;
  }
  updateQuoteToken2.extractEvent = extractEvent;
})(updateQuoteToken || (updateQuoteToken = {}));
async function updateQuoteTokenSync(client, parameters) {
  const receipt = await updateQuoteToken.inner(writeContractSync, client, parameters);
  const { args } = updateQuoteToken.extractEvent(receipt.logs);
  return {
    ...args,
    receipt
  };
}
function watchApprove(client, parameters) {
  const { onApproval, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "Approval",
    onLogs: (logs) => {
      for (const log of logs)
        onApproval(log.args, log);
    },
    strict: true
  });
}
function watchBurn2(client, parameters) {
  const { onBurn, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "Burn",
    onLogs: (logs) => {
      for (const log of logs)
        onBurn(log.args, log);
    },
    strict: true
  });
}
function watchCreate2(client, parameters) {
  const { onTokenCreated, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: tip20Factory2,
    abi: tip20Factory,
    eventName: "TokenCreated",
    onLogs: (logs) => {
      for (const log of logs)
        onTokenCreated(log.args, log);
    },
    strict: true
  });
}
function watchMint2(client, parameters) {
  const { onMint, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "Mint",
    onLogs: (logs) => {
      for (const log of logs)
        onMint(log.args, log);
    },
    strict: true
  });
}
function watchAdminRole(client, parameters) {
  const { onRoleAdminUpdated, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "RoleAdminUpdated",
    onLogs: (logs) => {
      for (const log of logs)
        onRoleAdminUpdated(log.args, log);
    },
    strict: true
  });
}
function watchRole(client, parameters) {
  const { onRoleUpdated, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "RoleMembershipUpdated",
    onLogs: (logs) => {
      for (const log of logs) {
        const type = log.args.hasRole ? "granted" : "revoked";
        onRoleUpdated({ ...log.args, type }, log);
      }
    },
    strict: true
  });
}
function watchTransfer(client, parameters) {
  const { onTransfer, token, ...rest } = parameters;
  return watchContractEvent(client, {
    ...rest,
    address: TokenId_exports.toAddress(token),
    abi: tip20,
    eventName: "Transfer",
    onLogs: (logs) => {
      for (const log of logs)
        onTransfer(log.args, log);
    },
    strict: true
  });
}
function watchUpdateQuoteToken(client, parameters) {
  const { onUpdateQuoteToken, token, ...rest } = parameters;
  const address = TokenId_exports.toAddress(token);
  return watchContractEvent(client, {
    ...rest,
    address,
    abi: tip20,
    onLogs: (logs) => {
      for (const log of logs) {
        if (log.eventName !== "NextQuoteTokenSet" && log.eventName !== "QuoteTokenUpdate")
          continue;
        onUpdateQuoteToken({
          ...log.args,
          completed: log.eventName === "QuoteTokenUpdate"
        }, log);
      }
    },
    strict: true
  });
}

// node_modules/viem/_esm/tempo/actions/validator.js
var validator_exports = {};
__export(validator_exports, {
  add: () => add,
  addSync: () => addSync,
  changeOwner: () => changeOwner,
  changeOwnerSync: () => changeOwnerSync,
  changeStatus: () => changeStatus,
  changeStatusSync: () => changeStatusSync,
  get: () => get,
  getByIndex: () => getByIndex,
  getCount: () => getCount,
  getNextFullDkgCeremony: () => getNextFullDkgCeremony,
  getOwner: () => getOwner,
  list: () => list,
  setNextFullDkgCeremony: () => setNextFullDkgCeremony,
  setNextFullDkgCeremonySync: () => setNextFullDkgCeremonySync,
  update: () => update,
  updateSync: () => updateSync
});
async function add(client, parameters) {
  return add.inner(writeContract, client, parameters);
}
(function(add2) {
  async function inner(action, client, parameters) {
    const { newValidatorAddress, publicKey, active, inboundAddress, outboundAddress, ...rest } = parameters;
    const callData = add2.call({
      newValidatorAddress,
      publicKey,
      active,
      inboundAddress,
      outboundAddress
    });
    return await action(client, {
      ...rest,
      ...callData
    });
  }
  add2.inner = inner;
  function call(args) {
    const { newValidatorAddress, publicKey, active, inboundAddress, outboundAddress } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [
        newValidatorAddress,
        publicKey,
        active,
        inboundAddress,
        outboundAddress
      ],
      functionName: "addValidator"
    });
  }
  add2.call = call;
})(add || (add = {}));
async function addSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await add.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
async function changeOwner(client, parameters) {
  return changeOwner.inner(writeContract, client, parameters);
}
(function(changeOwner2) {
  async function inner(action, client, parameters) {
    const { newOwner, ...rest } = parameters;
    const callData = changeOwner2.call({ newOwner });
    return await action(client, {
      ...rest,
      ...callData
    });
  }
  changeOwner2.inner = inner;
  function call(args) {
    const { newOwner } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [newOwner],
      functionName: "changeOwner"
    });
  }
  changeOwner2.call = call;
})(changeOwner || (changeOwner = {}));
async function changeOwnerSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await changeOwner.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
async function changeStatus(client, parameters) {
  return changeStatus.inner(writeContract, client, parameters);
}
(function(changeStatus2) {
  async function inner(action, client, parameters) {
    const { validator: validator3, active, ...rest } = parameters;
    const callData = changeStatus2.call({ validator: validator3, active });
    return await action(client, {
      ...rest,
      ...callData
    });
  }
  changeStatus2.inner = inner;
  function call(args) {
    const { validator: validator3, active } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [validator3, active],
      functionName: "changeValidatorStatus"
    });
  }
  changeStatus2.call = call;
})(changeStatus || (changeStatus = {}));
async function changeStatusSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await changeStatus.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
async function getNextFullDkgCeremony(client, parameters = {}) {
  return readContract(client, {
    ...parameters,
    ...getNextFullDkgCeremony.call()
  });
}
(function(getNextFullDkgCeremony2) {
  function call() {
    return defineCall({
      address: validator2,
      abi: validator,
      args: [],
      functionName: "getNextFullDkgCeremony"
    });
  }
  getNextFullDkgCeremony2.call = call;
})(getNextFullDkgCeremony || (getNextFullDkgCeremony = {}));
async function getOwner(client, parameters = {}) {
  return readContract(client, {
    ...parameters,
    ...getOwner.call()
  });
}
(function(getOwner2) {
  function call() {
    return defineCall({
      address: validator2,
      abi: validator,
      args: [],
      functionName: "owner"
    });
  }
  getOwner2.call = call;
})(getOwner || (getOwner = {}));
async function get(client, parameters) {
  const { validator: validator3, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...get.call({ validator: validator3 })
  });
}
(function(get2) {
  function call(args) {
    const { validator: validator3 } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [validator3],
      functionName: "validators"
    });
  }
  get2.call = call;
})(get || (get = {}));
async function getByIndex(client, parameters) {
  const { index, ...rest } = parameters;
  return readContract(client, {
    ...rest,
    ...getByIndex.call({ index })
  });
}
(function(getByIndex2) {
  function call(args) {
    const { index } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [index],
      functionName: "validatorsArray"
    });
  }
  getByIndex2.call = call;
})(getByIndex || (getByIndex = {}));
async function getCount(client, parameters = {}) {
  return readContract(client, {
    ...parameters,
    ...getCount.call()
  });
}
(function(getCount2) {
  function call() {
    return defineCall({
      address: validator2,
      abi: validator,
      args: [],
      functionName: "validatorCount"
    });
  }
  getCount2.call = call;
})(getCount || (getCount = {}));
async function list(client, parameters = {}) {
  return readContract(client, {
    ...parameters,
    ...list.call()
  });
}
(function(list2) {
  function call() {
    return defineCall({
      address: validator2,
      abi: validator,
      args: [],
      functionName: "getValidators"
    });
  }
  list2.call = call;
})(list || (list = {}));
async function setNextFullDkgCeremony(client, parameters) {
  return setNextFullDkgCeremony.inner(writeContract, client, parameters);
}
(function(setNextFullDkgCeremony2) {
  async function inner(action, client, parameters) {
    const { epoch, ...rest } = parameters;
    const callData = setNextFullDkgCeremony2.call({ epoch });
    return await action(client, {
      ...rest,
      ...callData
    });
  }
  setNextFullDkgCeremony2.inner = inner;
  function call(args) {
    const { epoch } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [epoch],
      functionName: "setNextFullDkgCeremony"
    });
  }
  setNextFullDkgCeremony2.call = call;
})(setNextFullDkgCeremony || (setNextFullDkgCeremony = {}));
async function setNextFullDkgCeremonySync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await setNextFullDkgCeremony.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}
async function update(client, parameters) {
  return update.inner(writeContract, client, parameters);
}
(function(update2) {
  async function inner(action, client, parameters) {
    const { newValidatorAddress, publicKey, inboundAddress, outboundAddress, ...rest } = parameters;
    const callData = update2.call({
      newValidatorAddress,
      publicKey,
      inboundAddress,
      outboundAddress
    });
    return await action(client, {
      ...rest,
      ...callData
    });
  }
  update2.inner = inner;
  function call(args) {
    const { newValidatorAddress, publicKey, inboundAddress, outboundAddress } = args;
    return defineCall({
      address: validator2,
      abi: validator,
      args: [newValidatorAddress, publicKey, inboundAddress, outboundAddress],
      functionName: "updateValidator"
    });
  }
  update2.call = call;
})(update || (update = {}));
async function updateSync(client, parameters) {
  const { throwOnReceiptRevert = true, ...rest } = parameters;
  const receipt = await update.inner(writeContractSync, client, {
    ...rest,
    throwOnReceiptRevert
  });
  return { receipt };
}

// node_modules/viem/_esm/tempo/Capabilities.js
var Capabilities_exports = {};

// node_modules/viem/_esm/tempo/Decorator.js
function decorator() {
  return (client) => {
    return {
      amm: {
        getPool: (parameters) => getPool(client, parameters),
        getLiquidityBalance: (parameters) => getLiquidityBalance(client, parameters),
        burn: (parameters) => burn(client, parameters),
        burnSync: (parameters) => burnSync(client, parameters),
        mint: (parameters) => mint(client, parameters),
        mintSync: (parameters) => mintSync(client, parameters),
        rebalanceSwap: (parameters) => rebalanceSwap(client, parameters),
        rebalanceSwapSync: (parameters) => rebalanceSwapSync(client, parameters),
        watchBurn: (parameters) => watchBurn(client, parameters),
        watchMint: (parameters) => watchMint(client, parameters),
        watchRebalanceSwap: (parameters) => watchRebalanceSwap(client, parameters)
      },
      dex: {
        buy: (parameters) => buy(client, parameters),
        buySync: (parameters) => buySync(client, parameters),
        cancel: (parameters) => cancel(client, parameters),
        cancelSync: (parameters) => cancelSync(client, parameters),
        cancelStale: (parameters) => cancelStale(client, parameters),
        cancelStaleSync: (parameters) => cancelStaleSync(client, parameters),
        createPair: (parameters) => createPair(client, parameters),
        createPairSync: (parameters) => createPairSync(client, parameters),
        getBalance: (parameters) => getBalance(client, parameters),
        getBuyQuote: (parameters) => getBuyQuote(client, parameters),
        getOrder: (parameters) => getOrder(client, parameters),
        getTickLevel: (parameters) => getTickLevel(client, parameters),
        getSellQuote: (parameters) => getSellQuote(client, parameters),
        place: (parameters) => place(client, parameters),
        placeSync: (parameters) => placeSync(client, parameters),
        placeFlip: (parameters) => placeFlip(client, parameters),
        placeFlipSync: (parameters) => placeFlipSync(client, parameters),
        sell: (parameters) => sell(client, parameters),
        sellSync: (parameters) => sellSync(client, parameters),
        withdraw: (parameters) => withdraw(client, parameters),
        withdrawSync: (parameters) => withdrawSync(client, parameters),
        watchFlipOrderPlaced: (parameters) => watchFlipOrderPlaced(client, parameters),
        watchOrderCancelled: (parameters) => watchOrderCancelled(client, parameters),
        watchOrderFilled: (parameters) => watchOrderFilled(client, parameters),
        watchOrderPlaced: (parameters) => watchOrderPlaced(client, parameters)
      },
      faucet: {
        fund: (parameters) => fund(client, parameters),
        fundSync: (parameters) => fundSync(client, parameters)
      },
      nonce: {
        getNonce: (parameters) => getNonce(client, parameters),
        watchNonceIncremented: (parameters) => watchNonceIncremented(client, parameters)
      },
      fee: {
        // @ts-expect-error
        getUserToken: (parameters) => (
          // @ts-expect-error
          getUserToken(client, parameters)
        ),
        setUserToken: (parameters) => setUserToken(client, parameters),
        setUserTokenSync: (parameters) => setUserTokenSync(client, parameters),
        watchSetUserToken: (parameters) => watchSetUserToken(client, parameters)
      },
      policy: {
        create: (parameters) => create(client, parameters),
        createSync: (parameters) => createSync(client, parameters),
        setAdmin: (parameters) => setAdmin(client, parameters),
        setAdminSync: (parameters) => setAdminSync(client, parameters),
        modifyWhitelist: (parameters) => modifyWhitelist(client, parameters),
        modifyWhitelistSync: (parameters) => modifyWhitelistSync(client, parameters),
        modifyBlacklist: (parameters) => modifyBlacklist(client, parameters),
        modifyBlacklistSync: (parameters) => modifyBlacklistSync(client, parameters),
        getData: (parameters) => getData(client, parameters),
        isAuthorized: (parameters) => isAuthorized(client, parameters),
        watchCreate: (parameters) => watchCreate(client, parameters),
        watchAdminUpdated: (parameters) => watchAdminUpdated(client, parameters),
        watchWhitelistUpdated: (parameters) => watchWhitelistUpdated(client, parameters),
        watchBlacklistUpdated: (parameters) => watchBlacklistUpdated(client, parameters)
      },
      reward: {
        claim: (parameters) => claim(client, parameters),
        claimSync: (parameters) => claimSync(client, parameters),
        distribute: (parameters) => distribute(client, parameters),
        distributeSync: (parameters) => distributeSync(client, parameters),
        getUserRewardInfo: (parameters) => getUserRewardInfo(client, parameters),
        setRecipient: (parameters) => setRecipient(client, parameters),
        setRecipientSync: (parameters) => setRecipientSync(client, parameters),
        watchRewardDistributed: (parameters) => watchRewardDistributed(client, parameters),
        watchRewardRecipientSet: (parameters) => watchRewardRecipientSet(client, parameters)
      },
      token: {
        approve: (parameters) => approve(client, parameters),
        approveSync: (parameters) => approveSync(client, parameters),
        burnBlocked: (parameters) => burnBlocked(client, parameters),
        burnBlockedSync: (parameters) => burnBlockedSync(client, parameters),
        burn: (parameters) => burn2(client, parameters),
        burnSync: (parameters) => burnSync2(client, parameters),
        changeTransferPolicy: (parameters) => changeTransferPolicy(client, parameters),
        changeTransferPolicySync: (parameters) => changeTransferPolicySync(client, parameters),
        create: (parameters) => create2(client, parameters),
        createSync: (parameters) => createSync2(client, parameters),
        getAllowance: (parameters) => getAllowance(client, parameters),
        getBalance: (parameters) => getBalance2(client, parameters),
        getMetadata: (parameters) => getMetadata(client, parameters),
        getRoleAdmin: (parameters) => getRoleAdmin(client, parameters),
        hasRole: (parameters) => hasRole(client, parameters),
        grantRoles: (parameters) => grantRoles(client, parameters),
        grantRolesSync: (parameters) => grantRolesSync(client, parameters),
        mint: (parameters) => mint2(client, parameters),
        mintSync: (parameters) => mintSync2(client, parameters),
        pause: (parameters) => pause(client, parameters),
        pauseSync: (parameters) => pauseSync(client, parameters),
        renounceRoles: (parameters) => renounceRoles(client, parameters),
        renounceRolesSync: (parameters) => renounceRolesSync(client, parameters),
        revokeRoles: (parameters) => revokeRoles(client, parameters),
        revokeRolesSync: (parameters) => revokeRolesSync(client, parameters),
        setSupplyCap: (parameters) => setSupplyCap(client, parameters),
        setSupplyCapSync: (parameters) => setSupplyCapSync(client, parameters),
        setRoleAdmin: (parameters) => setRoleAdmin(client, parameters),
        setRoleAdminSync: (parameters) => setRoleAdminSync(client, parameters),
        transfer: (parameters) => transfer(client, parameters),
        transferSync: (parameters) => transferSync(client, parameters),
        unpause: (parameters) => unpause(client, parameters),
        unpauseSync: (parameters) => unpauseSync(client, parameters),
        watchApprove: (parameters) => watchApprove(client, parameters),
        watchBurn: (parameters) => watchBurn2(client, parameters),
        watchCreate: (parameters) => watchCreate2(client, parameters),
        watchMint: (parameters) => watchMint2(client, parameters),
        watchAdminRole: (parameters) => watchAdminRole(client, parameters),
        watchRole: (parameters) => watchRole(client, parameters),
        watchTransfer: (parameters) => watchTransfer(client, parameters)
      },
      validator: {
        add: (parameters) => add(client, parameters),
        addSync: (parameters) => addSync(client, parameters),
        changeOwner: (parameters) => changeOwner(client, parameters),
        changeOwnerSync: (parameters) => changeOwnerSync(client, parameters),
        changeStatus: (parameters) => changeStatus(client, parameters),
        changeStatusSync: (parameters) => changeStatusSync(client, parameters),
        get: (parameters) => get(client, parameters),
        getByIndex: (parameters) => getByIndex(client, parameters),
        getCount: (parameters) => getCount(client, parameters),
        getNextFullDkgCeremony: (parameters) => getNextFullDkgCeremony(client, parameters),
        getOwner: (parameters) => getOwner(client, parameters),
        list: (parameters) => list(client, parameters),
        setNextFullDkgCeremony: (parameters) => setNextFullDkgCeremony(client, parameters),
        setNextFullDkgCeremonySync: (parameters) => setNextFullDkgCeremonySync(client, parameters),
        update: (parameters) => update(client, parameters),
        updateSync: (parameters) => updateSync(client, parameters)
      }
    };
  };
}

// node_modules/viem/_esm/tempo/P256.js
var P256_exports2 = {};
__export(P256_exports2, {
  randomPrivateKey: () => randomPrivateKey2
});

// node_modules/viem/_esm/tempo/Secp256k1.js
var Secp256k1_exports2 = {};
__export(Secp256k1_exports2, {
  randomPrivateKey: () => randomPrivateKey
});

// node_modules/viem/_esm/tempo/TokenIds.js
var TokenIds_exports = {};
__export(TokenIds_exports, {
  pathUsd: () => pathUsd2
});
var pathUsd2 = 0n;

// node_modules/viem/_esm/tempo/Transport.js
var Transport_exports = {};
__export(Transport_exports, {
  walletNamespaceCompat: () => walletNamespaceCompat,
  withFeePayer: () => withFeePayer
});

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/ox/_esm/core/RpcResponse.js
var BaseError = class extends Error {
  constructor(errorObject) {
    const { cause, code, message, data, stack } = errorObject;
    super(message, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
    this.code = code;
    this.data = data;
    this.stack = stack ?? "";
  }
};
var InvalidInputError = class _InvalidInputError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError {
  constructor(parameters = {}) {
    super({
      cause: parameters.cause,
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error.",
      stack: parameters.stack
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError = class _ParseError extends BaseError {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/ox/_esm/core/Provider.js
var ProviderRpcError = class extends Error {
  constructor(code, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.details = message;
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
var SwitchChainError = class extends ProviderRpcError {
  constructor({ message = "An error occurred when attempting to switch chain." } = {}) {
    super(4902, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.SwitchChainError"
    });
  }
};
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
var UnsupportedNonOptionalCapabilityError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support a capability that was not marked as optional." } = {}) {
    super(5700, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedNonOptionalCapabilityError"
    });
  }
};
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
var UnsupportedChainIdError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support the requested chain ID." } = {}) {
    super(5710, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5710
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedChainIdError"
    });
  }
};
Object.defineProperty(UnsupportedChainIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
var DuplicateIdError = class extends ProviderRpcError {
  constructor({ message = "There is already a bundle submitted with this ID." } = {}) {
    super(5720, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5720
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DuplicateIdError"
    });
  }
};
Object.defineProperty(DuplicateIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
var UnknownBundleIdError = class extends ProviderRpcError {
  constructor({ message = "This bundle id is unknown / has not been submitted." } = {}) {
    super(5730, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5730
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnknownBundleIdError"
    });
  }
};
Object.defineProperty(UnknownBundleIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
var BundleTooLargeError = class extends ProviderRpcError {
  constructor({ message = "The call bundle is too large for the Wallet to process." } = {}) {
    super(5740, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5740
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.BundleTooLargeError"
    });
  }
};
Object.defineProperty(BundleTooLargeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
var AtomicReadyWalletRejectedUpgradeError = class extends ProviderRpcError {
  constructor({ message = "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade." } = {}) {
    super(5750, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5750
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicReadyWalletRejectedUpgradeError"
    });
  }
};
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
var AtomicityNotSupportedError = class extends ProviderRpcError {
  constructor({ message = "The wallet does not support atomic execution but the request requires it." } = {}) {
    super(5760, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5760
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicityNotSupportedError"
    });
  }
};
Object.defineProperty(AtomicityNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});

// node_modules/ox/_esm/core/RpcRequest.js
function from4(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/viem/_esm/tempo/Transport.js
function withFeePayer(defaultTransport, relayTransport, parameters) {
  const { policy = "sign-only" } = parameters ?? {};
  return (config) => {
    const transport_default = defaultTransport(config);
    const transport_relay = relayTransport(config);
    return createTransport({
      key: withFeePayer.type,
      name: "Relay Proxy",
      async request({ method, params }, options) {
        if (method === "eth_sendRawTransactionSync" || method === "eth_sendRawTransaction") {
          const serialized = params[0];
          const transaction = deserialize(serialized);
          if (transaction.feePayerSignature === null) {
            if (policy === "sign-and-broadcast")
              return transport_relay.request({ method, params }, options);
            {
              const signedTransaction = await transport_relay.request({
                method: "eth_signRawTransaction",
                params: [serialized]
              }, options);
              return transport_default.request({ method, params: [signedTransaction] }, options);
            }
          }
        }
        return await transport_default.request({ method, params }, options);
      },
      type: withFeePayer.type
    });
  };
}
function walletNamespaceCompat(transport, options) {
  const { account } = options;
  const sendCallsMagic = keccak2562(fromString2("TEMPO_5792"));
  return (options2) => {
    const t = transport(options2);
    const chain = options2.chain;
    return {
      ...t,
      async request(args) {
        const request = from4(args);
        const client = createClient({
          chain,
          transport
        });
        if (request.method === "wallet_sendCalls") {
          const params = request.params[0] ?? {};
          const { capabilities, chainId, from: from5 } = params;
          const { sync, ...properties } = capabilities ?? {};
          if (!chainId)
            throw new UnsupportedChainIdError();
          if (Number(chainId) !== client.chain.id)
            throw new UnsupportedChainIdError();
          if (from5 && !isEqual(from5, account.address))
            throw new DisconnectedError();
          const calls = (params.calls ?? []).map((call) => ({
            to: call.to,
            value: call.value ? BigInt(call.value) : void 0,
            data: call.data
          }));
          const hash = await (async () => {
            if (!sync)
              return sendTransaction(client, {
                account,
                ...properties ? properties : {},
                calls
              });
            const { transactionHash } = await sendTransactionSync(client, {
              account,
              ...properties ? properties : {},
              calls
            });
            return transactionHash;
          })();
          const id = concat(hash, padLeft(chainId, 32), sendCallsMagic);
          return {
            capabilities: { sync },
            id
          };
        }
        if (request.method === "wallet_getCallsStatus") {
          const [id] = request.params ?? [];
          if (!id)
            throw new Error("`id` not found");
          if (!id.endsWith(sendCallsMagic.slice(2)))
            throw new Error("`id` not supported");
          assert(id);
          const hash = slice2(id, 0, 32);
          const chainId = slice2(id, 32, 64);
          const receipt = await getTransactionReceipt(client, { hash });
          return {
            atomic: true,
            chainId: Number(chainId),
            id,
            receipts: [receipt],
            status: receipt.status === "success" ? 200 : 500,
            version: "2.0.0"
          };
        }
        return t.request(args);
      }
    };
  };
}

// node_modules/viem/_esm/tempo/WebAuthnP256.js
var WebAuthnP256_exports2 = {};
__export(WebAuthnP256_exports2, {
  createCredential: () => createCredential2,
  getCredential: () => getCredential
});
async function createCredential2(parameters) {
  const { createFn, label, rpId, userId } = parameters;
  const credential = await createCredential({
    ...parameters,
    authenticatorSelection: {
      ...parameters.authenticatorSelection,
      requireResidentKey: true,
      residentKey: "required",
      userVerification: "required"
    },
    createFn,
    extensions: {
      ...parameters.extensions,
      credProps: true
    },
    rp: rpId ? {
      id: rpId,
      name: rpId
    } : void 0,
    name: void 0,
    user: {
      displayName: label,
      id: new Uint8Array(userId ?? fromString(label)),
      name: label
    }
  });
  return {
    id: credential.id,
    publicKey: toHex(credential.publicKey, {
      includePrefix: false
    }),
    raw: credential.raw
  };
}
async function getCredential(parameters) {
  const { metadata, raw, signature } = await sign3({
    ...parameters,
    challenge: parameters.hash ?? "0x"
  });
  const publicKey = await parameters.getPublicKey(raw);
  return {
    id: raw.id,
    metadata,
    publicKey,
    raw,
    signature
  };
}

// node_modules/viem/_esm/tempo/WebCryptoP256.js
var WebCryptoP256_exports2 = {};
__export(WebCryptoP256_exports2, {
  createKeyPair: () => createKeyPair
});
export {
  Abis_exports as Abis,
  Account_exports as Account,
  actions_exports as Actions,
  Addresses_exports as Addresses,
  Capabilities_exports as Capabilities,
  Formatters_exports as Formatters,
  P256_exports2 as P256,
  Secp256k1_exports2 as Secp256k1,
  Tick_exports as Tick,
  TokenId_exports as TokenId,
  TokenIds_exports as TokenIds,
  Transaction_exports as Transaction,
  Transport_exports as Transport,
  WebAuthnP256_exports2 as WebAuthnP256,
  WebCryptoP256_exports2 as WebCryptoP256,
  decorator as tempoActions,
  walletNamespaceCompat,
  withFeePayer
};
//# sourceMappingURL=viem_tempo.js.map
