{
  "version": 3,
  "sources": ["../../ox/tempo/TokenId.ts", "../../ox/tempo/Tick.ts", "../../ox/tempo/AuthorizationTempo.ts", "../../ox/tempo/SignatureEnvelope.ts", "../../@noble/curves/src/nist.ts", "../../@noble/curves/src/p256.ts", "../../ox/core/P256.ts", "../../ox/core/Base64.ts", "../../ox/core/internal/webauthn.ts", "../../ox/core/WebAuthnP256.ts", "../../ox/tempo/KeyAuthorization.ts", "../../ox/tempo/PoolId.ts", "../../ox/tempo/TokenRole.ts", "../../ox/tempo/Transaction.ts", "../../ox/core/Transaction.ts", "../../ox/tempo/TransactionReceipt.ts", "../../ox/core/Log.ts", "../../ox/core/TransactionReceipt.ts", "../../ox/tempo/TransactionRequest.ts", "../../ox/core/TransactionRequest.ts", "../../ox/tempo/TxEnvelopeTempo.ts", "../../ox/core/AccessList.ts", "../../ox/core/Value.ts", "../../ox/core/TxEnvelope.ts", "../../viem/tempo/Transaction.ts", "../../viem/tempo/Formatters.ts"],
  "sourcesContent": ["import * as AbiParameters from '../core/AbiParameters.js'\nimport * as Address from '../core/Address.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\n\nconst tip20Prefix = '0x20c0'\n\nexport type TokenId = bigint\nexport type TokenIdOrAddress = TokenId | Address.Address\n\n/**\n * Converts a token ID or address to a token ID.\n *\n * TIP-20 is Tempo's native token standard for stablecoins with deterministic addresses\n * derived from sequential token IDs (prefix `0x20c0`).\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.from(1n)\n * ```\n *\n * @param tokenIdOrAddress - The token ID or address.\n * @returns The token ID.\n */\nexport function from(tokenIdOrAddress: TokenIdOrAddress | number): TokenId {\n  if (\n    typeof tokenIdOrAddress === 'bigint' ||\n    typeof tokenIdOrAddress === 'number'\n  )\n    return BigInt(tokenIdOrAddress)\n  return fromAddress(tokenIdOrAddress)\n}\n\n/**\n * Converts a TIP-20 token address to a token ID.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.fromAddress('0x20c00000000000000000000000000000000000000001')\n * ```\n *\n * @param address - The token address.\n * @returns The token ID.\n */\nexport function fromAddress(address: Address.Address): TokenId {\n  if (!address.toLowerCase().startsWith(tip20Prefix))\n    throw new Error('invalid tip20 address.')\n  return Hex.toBigInt(Hex.slice(address, tip20Prefix.length))\n}\n\n/**\n * Converts a TIP-20 token ID to an address.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const address = TokenId.toAddress(1n)\n * ```\n *\n * @param tokenId - The token ID.\n * @returns The address.\n */\nexport function toAddress(tokenId: TokenIdOrAddress): Address.Address {\n  if (typeof tokenId === 'string') {\n    Address.assert(tokenId)\n    return tokenId\n  }\n\n  const tokenIdHex = Hex.fromNumber(tokenId, { size: 18 })\n  return Hex.concat(tip20Prefix, tokenIdHex)\n}\n\n/**\n * Computes a deterministic TIP-20 token address from a sender address and salt.\n *\n * The address is computed as: `TIP20_PREFIX (12 bytes) || keccak256(abi.encode(sender, salt))[:8]`\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const id = TokenId.compute({\n *   sender: '0x1234567890123456789012345678901234567890',\n *   salt: '0x0000000000000000000000000000000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param value - The sender address and salt.\n * @returns The computed TIP-20 token id.\n */\nexport function compute(value: compute.Value): bigint {\n  const hash = Hash.keccak256(\n    AbiParameters.encode(AbiParameters.from('address, bytes32'), [\n      value.sender,\n      value.salt,\n    ]),\n  )\n  return Hex.toBigInt(Hex.slice(hash, 0, 8))\n}\n\nexport declare namespace compute {\n  export type Value = {\n    /** The salt (32 bytes). */\n    salt: Hex.Hex\n    /** The sender address. */\n    sender: Address.Address\n  }\n}\n", "import * as Errors from '../core/Errors.js'\n\n/**\n * Minimum allowed tick value (-2% from peg).\n *\n * [Stablecoin DEX Pricing](https://docs.tempo.xyz/protocol/exchange/spec#key-concepts)\n */\nexport const minTick = -2000\n\n/**\n * Maximum allowed tick value (+2% from peg).\n *\n * [Stablecoin DEX Pricing](https://docs.tempo.xyz/protocol/exchange/spec#key-concepts)\n */\nexport const maxTick = 2000\n\n/**\n * Price scaling factor (5 decimal places for 0.1 bps precision).\n *\n * The DEX uses a tick-based pricing system where `price = PRICE_SCALE + tick`.\n * Orders must be placed at ticks divisible by `TICK_SPACING = 10` (1 bp grid).\n *\n * [Stablecoin DEX Pricing](https://docs.tempo.xyz/protocol/exchange/spec#key-concepts)\n */\nexport const priceScale = 100_000\n\n/**\n * Tick type.\n */\nexport type Tick = number\n\n/**\n * Converts a tick to a price string.\n *\n * [Stablecoin DEX Pricing](https://docs.tempo.xyz/protocol/exchange/spec#key-concepts)\n *\n * @example\n * ```ts\n * import { Tick } from 'ox/tempo'\n *\n * // Tick 0 = price of 1.0\n * const price1 = Tick.toPrice(0) // \"1\"\n *\n * // Tick 100 = price of 1.001 (0.1% higher)\n * const price2 = Tick.toPrice(100) // \"1.001\"\n *\n * // Tick -100 = price of 0.999 (0.1% lower)\n * const price3 = Tick.toPrice(-100) // \"0.999\"\n * ```\n *\n * @param tick - The tick value (range: -2000 to +2000).\n * @returns The price as a string with exact decimal representation.\n * @throws `TickOutOfBoundsError` If tick is out of bounds.\n */\nexport function toPrice(tick: toPrice.Tick): toPrice.ReturnType {\n  if (tick < minTick || tick > maxTick) {\n    throw new TickOutOfBoundsError({ tick })\n  }\n  // Use integer arithmetic to avoid floating point errors\n  const price = priceScale + tick\n  const whole = Math.floor(price / priceScale)\n\n  let decimal = (price % priceScale).toString().padStart(5, '0')\n  decimal = decimal.replace(/0+$/, '')\n\n  if (decimal.length === 0) return whole.toString()\n  return `${whole}.${decimal}`\n}\n\nexport declare namespace toPrice {\n  export type Tick = number\n  export type ReturnType = string\n}\n\n/**\n * Converts a price string to a tick.\n *\n * [Stablecoin DEX Pricing](https://docs.tempo.xyz/protocol/exchange/spec#key-concepts)\n *\n * @example\n * ```ts\n * import { Tick } from 'ox/tempo'\n *\n * // Price of 1.0 = tick 0\n * const tick1 = Tick.fromPrice('1.0') // 0\n * const tick2 = Tick.fromPrice('1.00000') // 0\n *\n * // Price of 1.001 = tick 100\n * const tick3 = Tick.fromPrice('1.001') // 100\n *\n * // Price of 0.999 = tick -100\n * const tick4 = Tick.fromPrice('0.999') // -100\n * ```\n *\n * @param price - The price as a string (e.g., \"1.001\", \"0.999\").\n * @returns The tick value.\n */\nexport function fromPrice(price: fromPrice.Price): fromPrice.ReturnType {\n  const priceStr = price.trim()\n  if (!/^-?\\d+(\\.\\d+)?$/.test(priceStr))\n    throw new InvalidPriceFormatError({ price })\n\n  // Parse price using string manipulation to avoid float precision issues\n  const [w, d = '0'] = priceStr.split('.')\n  const whole = BigInt(w!)\n\n  // Pad or truncate decimal to exactly 5 digits\n  const decimal = BigInt(d.padEnd(5, '0').slice(0, 5))\n\n  // Calculate price\n  const priceInt = whole * BigInt(priceScale) + decimal\n\n  // Calculate tick\n  const tick = Number(priceInt - BigInt(priceScale))\n\n  if (tick < minTick || tick > maxTick)\n    throw new PriceOutOfBoundsError({ price, tick })\n\n  return tick\n}\n\nexport declare namespace fromPrice {\n  export type Price = string\n  export type ReturnType = number\n}\n\n/**\n * Error thrown when a tick value is out of the allowed bounds.\n */\nexport class TickOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Tick.TickOutOfBoundsError'\n\n  constructor(options: TickOutOfBoundsError.Options) {\n    super(`Tick ${options.tick} is out of bounds.`, {\n      metaMessages: [`Tick must be between ${minTick} and ${maxTick}.`],\n    })\n  }\n}\n\nexport declare namespace TickOutOfBoundsError {\n  export type Options = {\n    tick: number\n  }\n}\n\n/**\n * Error thrown when a price string has an invalid format.\n */\nexport class InvalidPriceFormatError extends Errors.BaseError {\n  override readonly name = 'Tick.InvalidPriceFormatError'\n\n  constructor(options: InvalidPriceFormatError.Options) {\n    super(`Invalid price format: \"${options.price}\".`, {\n      metaMessages: ['Price must be a decimal number string (e.g., \"1.001\").'],\n    })\n  }\n}\n\nexport declare namespace InvalidPriceFormatError {\n  export type Options = {\n    price: string\n  }\n}\n\n/**\n * Error thrown when a price string results in an out-of-bounds tick.\n */\nexport class PriceOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Tick.PriceOutOfBoundsError'\n\n  constructor(options: PriceOutOfBoundsError.Options) {\n    super(\n      `Price \"${options.price}\" results in tick ${options.tick} which is out of bounds.`,\n      {\n        metaMessages: [`Tick must be between ${minTick} and ${maxTick}.`],\n      },\n    )\n  }\n}\n\nexport declare namespace PriceOutOfBoundsError {\n  export type Options = {\n    price: string\n    tick: number\n  }\n}\n", "import type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute, Mutable } from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\n\n/**\n * Root type for a Tempo Authorization.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types,\n * enabling passkey-based account delegation.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n */\nexport type AuthorizationTempo<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** Address of the contract to set as code for the Authority. */\n    address: Address.Address\n    /** Chain ID to authorize. */\n    chainId: numberType\n    /** Nonce of the Authority to authorize. */\n    nonce: bigintType\n  } & (signed extends true\n    ? { signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType> }\n    : {\n        signature?:\n          | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n          | undefined\n      })\n>\n\n/** RPC representation of an {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type Rpc = Omit<\n  AuthorizationTempo<false, Hex.Hex, Hex.Hex>,\n  'signature'\n> & {\n  signature: SignatureEnvelope.SignatureEnvelopeRpc\n}\n\n/** List of {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type List<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<readonly AuthorizationTempo<signed, bigintType, numberType>[]>\n\n/** RPC representation of a list of AA Authorizations. */\nexport type ListRpc = readonly Rpc[]\n\n/** Signed representation of a list of AA Authorizations. */\nexport type ListSigned<bigintType = bigint, numberType = number> = List<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Signed representation of an AA Authorization. */\nexport type Signed<\n  bigintType = bigint,\n  numberType = number,\n> = AuthorizationTempo<true, bigintType, numberType>\n\n/** Tuple representation of an AA Authorization. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      chainId: Hex.Hex,\n      address: Hex.Hex,\n      nonce: Hex.Hex,\n      signature: Hex.Hex,\n    ]\n  : readonly [chainId: Hex.Hex, address: Hex.Hex, nonce: Hex.Hex]\n\n/** Tuple representation of a signed {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleSigned = Tuple<true>\n\n/** Tuple representation of a list of {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleList<signed extends boolean = boolean> =\n  readonly Tuple<signed>[]\n\n/** Tuple representation of a list of signed {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleListSigned = TupleList<true>\n\n/**\n * Converts an EIP-7702 Authorization object into a typed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n *\n * @example\n * An Authorization can be instantiated from an EIP-7702 Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256)\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = P256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: false,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256 WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = await WebCryptoP256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: AuthorizationTempo.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple in object format.\n * @param options - AA Authorization options.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function from<\n  const authorization extends AuthorizationTempo | Rpc,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  authorization: authorization | AuthorizationTempo,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.chainId === 'string')\n    return fromRpc(authorization as Rpc) as never\n  if (options.signature) {\n    return { ...authorization, signature: options.signature } as never\n  }\n  return authorization as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = {\n    /** The {@link ox#SignatureEnvelope.SignatureEnvelope} to attach to the AA Authorization. */\n    signature?: signature | SignatureEnvelope.SignatureEnvelope | undefined\n  }\n\n  type ReturnType<\n    authorization extends AuthorizationTempo | Rpc = AuthorizationTempo,\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted AA Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { address, chainId, nonce } = authorization\n  const signature = SignatureEnvelope.fromRpc(authorization.signature)\n  return {\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    signature,\n  } as never\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.ListRpc} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted AA Authorization list.\n * @returns A signed {@link ox#AuthorizationTempo.List}.\n */\nexport function fromRpcList(authorizationList: ListRpc): ListSigned {\n  return authorizationList.map((x) => fromRpc(x as unknown as Rpc))\n}\n\nexport declare namespace fromRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Tuple} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   signature: {\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [chainId, address, nonce, signatureSerialized] = tuple\n  const args: AuthorizationTempo = {\n    address,\n    chainId: chainId === '0x' ? 0 : Number(chainId),\n    nonce: nonce === '0x' ? 0n : BigInt(nonce),\n  }\n  if (signatureSerialized)\n    args.signature = SignatureEnvelope.deserialize(signatureSerialized)\n  return from(args) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    AuthorizationTempo<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.TupleList} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n * @returns An {@link ox#AuthorizationTempo.List}.\n */\nexport function fromTupleList<const tupleList extends TupleList>(\n  tupleList: tupleList,\n): fromTupleList.ReturnType<tupleList> {\n  const list: Mutable<List> = []\n  for (const tuple of tupleList) list.push(fromTuple(tuple))\n  return list as never\n}\n\nexport declare namespace fromTupleList {\n  type ReturnType<tupleList extends TupleList> = Compute<\n    TupleList<tupleList extends TupleList<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }\n * )\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = P256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: false,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: true,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const challenge = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge,\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: AuthorizationTempo): Hex.Hex {\n  return hash(authorization, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = AuthorizationTempo.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The hash.\n */\nexport function hash(\n  authorization: AuthorizationTempo,\n  options: hash.Options = {},\n): Hex.Hex {\n  const { presign } = options\n  return Hash.keccak256(\n    Hex.concat(\n      '0x05',\n      Rlp.fromHex(\n        toTuple(\n          presign\n            ? {\n                address: authorization.address,\n                chainId: authorization.chainId,\n                nonce: authorization.nonce,\n              }\n            : authorization,\n        ),\n      ),\n    ),\n  )\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /** Whether to hash this authorization for signing. @default false */\n    presign?: boolean | undefined\n  }\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - An AA Authorization.\n * @returns An RPC-formatted AA Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const { address, chainId, nonce, signature } = authorization\n\n  return {\n    address,\n    chainId: Hex.fromNumber(chainId),\n    nonce: Hex.fromNumber(nonce),\n    signature: SignatureEnvelope.toRpc(signature),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * }])\n * ```\n *\n * @param authorizationList - An AA Authorization List.\n * @returns An RPC-formatted AA Authorization List.\n */\nexport function toRpcList(authorizationList: ListSigned): ListRpc {\n  return authorizationList.map((x) => toRpc(x as unknown as Signed)) as never\n}\n\nexport declare namespace toRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = AuthorizationTempo.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n */\nexport function toTuple<const authorization extends AuthorizationTempo>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId, nonce } = authorization\n  const signature = authorization.signature\n    ? SignatureEnvelope.serialize(authorization.signature)\n    : undefined\n  return [\n    chainId ? Hex.fromNumber(chainId) : '0x',\n    address,\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    ...(signature ? [signature] : []),\n  ] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<\n    authorization extends AuthorizationTempo = AuthorizationTempo,\n  > = Compute<\n    Tuple<authorization extends AuthorizationTempo<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization_1 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = AuthorizationTempo.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#AuthorizationTempo.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n */\nexport function toTupleList<\n  const list extends\n    | readonly AuthorizationTempo<true>[]\n    | readonly AuthorizationTempo<false>[],\n>(list?: list | undefined): toTupleList.ReturnType<list> {\n  if (!list || list.length === 0) return []\n\n  const tupleList: Mutable<TupleList> = []\n  for (const authorization of list) tupleList.push(toTuple(authorization))\n\n  return tupleList as never\n}\n\nexport declare namespace toTupleList {\n  type ReturnType<\n    list extends\n      | readonly AuthorizationTempo<true>[]\n      | readonly AuthorizationTempo<false>[],\n  > = Compute<\n    TupleList<list extends readonly AuthorizationTempo<true>[] ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Address from '../core/Address.js'\nimport type * as Bytes from '../core/Bytes.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type {\n  Assign,\n  Compute,\n  IsNarrowable,\n  OneOf,\n  PartialBy,\n  UnionPartialBy,\n} from '../core/internal/types.js'\nimport * as Json from '../core/Json.js'\nimport * as ox_P256 from '../core/P256.js'\nimport type * as PublicKey from '../core/PublicKey.js'\nimport * as ox_Secp256k1 from '../core/Secp256k1.js'\nimport * as Signature from '../core/Signature.js'\nimport type * as WebAuthnP256 from '../core/WebAuthnP256.js'\nimport * as ox_WebAuthnP256 from '../core/WebAuthnP256.js'\n\n/** Signature type identifiers for encoding/decoding */\nconst serializedP256Type = '0x01'\nconst serializedWebAuthnType = '0x02'\nconst serializedKeychainType = '0x03'\n\n/** Serialized magic identifier for Tempo signature envelopes. */\nexport const magicBytes =\n  '0x7777777777777777777777777777777777777777777777777777777777777777' // 32 \"T\"s\n\n/**\n * Statically determines the signature type of an envelope at compile time.\n *\n * @example\n * ```ts twoslash\n * import type { SignatureEnvelope } from 'ox/tempo'\n *\n * type Type = SignatureEnvelope.GetType<{ r: bigint; s: bigint; yParity: number }>\n * // @log: 'secp256k1'\n * ```\n */\nexport type GetType<\n  envelope extends PartialBy<SignatureEnvelope, 'type'> | unknown,\n> = unknown extends envelope\n  ? envelope extends unknown\n    ? Type\n    : never\n  : envelope extends { type: infer T extends Type }\n    ? T\n    : envelope extends {\n          signature: { r: bigint; s: bigint }\n          prehash: boolean\n          publicKey: PublicKey.PublicKey\n        }\n      ? 'p256'\n      : envelope extends {\n            signature: { r: bigint; s: bigint }\n            metadata: any\n            publicKey: PublicKey.PublicKey\n          }\n        ? 'webAuthn'\n        : envelope extends { r: bigint; s: bigint; yParity: number }\n          ? 'secp256k1'\n          : envelope extends {\n                signature: { r: bigint; s: bigint; yParity: number }\n              }\n            ? 'secp256k1'\n            : envelope extends {\n                  userAddress: Address.Address\n                }\n              ? 'keychain'\n              : never\n\n/**\n * Represents a signature envelope that can contain different signature types.\n *\n * Tempo transactions support multiple signature types, each with different wire formats:\n *\n * - **secp256k1** (no type prefix, 65 bytes): Standard Ethereum ECDSA signature. The sender\n *   address is recovered via `ecrecover`. Base transaction cost: 21,000 gas.\n *\n * - **p256** (type `0x01`, 130 bytes): P256/secp256r1 curve signature for passkey accounts.\n *   Includes embedded public key (64 bytes) and prehash flag. Enables native WebCrypto\n *   key support. Additional gas cost: +5,000 gas over secp256k1.\n *\n * - **webAuthn** (type `0x02`, 129-2049 bytes): WebAuthn signature with authenticator data\n *   and clientDataJSON. Enables browser passkey authentication. The signature is also\n *   charged as calldata (16 gas/non-zero byte, 4 gas/zero byte).\n *\n * - **keychain** (type `0x03`): Access key signature that wraps an inner signature (secp256k1,\n *   p256, or webAuthn). Format: `0x03` + user_address (20 bytes) + inner signature. The\n *   protocol validates the access key authorization via the AccountKeychain precompile.\n *\n * [Signature Types Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n */\nexport type SignatureEnvelope<bigintType = bigint, numberType = number> = OneOf<\n  | Secp256k1<bigintType, numberType>\n  | P256<bigintType, numberType>\n  | WebAuthn<bigintType, numberType>\n  | Keychain<bigintType, numberType>\n>\n\n/**\n * RPC-formatted signature envelope.\n */\nexport type SignatureEnvelopeRpc = OneOf<\n  Secp256k1Rpc | P256Rpc | WebAuthnRpc | KeychainRpc\n>\n\nexport type Keychain<bigintType = bigint, numberType = number> = {\n  /** Root account address that this transaction is being executed for */\n  userAddress: Address.Address\n  /** The actual signature from the access key (can be Secp256k1, P256, or WebAuthn) */\n  inner: SignatureEnvelope<bigintType, numberType>\n  type: 'keychain'\n}\n\nexport type KeychainRpc = {\n  type: 'keychain'\n  userAddress: Address.Address\n  signature: SignatureEnvelopeRpc\n}\n\nexport type P256<bigintType = bigint, numberType = number> = {\n  prehash: boolean\n  publicKey: PublicKey.PublicKey\n  signature: Signature.Signature<false, bigintType, numberType>\n  type: 'p256'\n}\n\nexport type P256Rpc = {\n  preHash: boolean\n  pubKeyX: Hex.Hex\n  pubKeyY: Hex.Hex\n  r: Hex.Hex\n  s: Hex.Hex\n  type: 'p256'\n}\n\nexport type Secp256k1<bigintType = bigint, numberType = number> = {\n  signature: Signature.Signature<true, bigintType, numberType>\n  type: 'secp256k1'\n}\n\nexport type Secp256k1Rpc = Compute<\n  Signature.Rpc<true> & {\n    v?: Hex.Hex | undefined\n    type: 'secp256k1'\n  }\n>\n\nexport type Secp256k1Flat<\n  bigintType = bigint,\n  numberType = number,\n> = Signature.Signature<true, bigintType, numberType> & {\n  type?: 'secp256k1' | undefined\n}\n\nexport type WebAuthn<bigintType = bigint, numberType = number> = {\n  metadata: Pick<\n    WebAuthnP256.SignMetadata,\n    'authenticatorData' | 'clientDataJSON'\n  >\n  signature: Signature.Signature<false, bigintType, numberType>\n  publicKey: PublicKey.PublicKey\n  type: 'webAuthn'\n}\n\nexport type WebAuthnRpc = {\n  pubKeyX: Hex.Hex\n  pubKeyY: Hex.Hex\n  r: Hex.Hex\n  s: Hex.Hex\n  type: 'webAuthn'\n  webauthnData: Hex.Hex\n}\n\n/** Hex-encoded serialized signature envelope. */\nexport type Serialized = Hex.Hex\n\n/** List of supported signature types. */\nexport const types = ['secp256k1', 'p256', 'webAuthn'] as const\n\n/** Union type of supported signature types. */\nexport type Type = (typeof types)[number]\n\n/**\n * Asserts that a {@link ox#SignatureEnvelope.SignatureEnvelope} is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * SignatureEnvelope.assert({\n *   type: 'secp256k1',\n *   signature: {\n *     r: 0n,\n *     s: 0n,\n *     yParity: 0,\n *   },\n * })\n * ```\n *\n * @param envelope - The signature envelope to assert.\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nexport function assert(envelope: PartialBy<SignatureEnvelope, 'type'>): void {\n  const type = getType(envelope)\n\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    Signature.assert(secp256k1.signature)\n    return\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    const missing: string[] = []\n\n    if (typeof p256.signature?.r !== 'bigint') missing.push('signature.r')\n    if (typeof p256.signature?.s !== 'bigint') missing.push('signature.s')\n    if (typeof p256.prehash !== 'boolean') missing.push('prehash')\n    if (!p256.publicKey) missing.push('publicKey')\n    else {\n      if (typeof p256.publicKey.x !== 'bigint') missing.push('publicKey.x')\n      if (typeof p256.publicKey.y !== 'bigint') missing.push('publicKey.y')\n    }\n\n    if (missing.length > 0)\n      throw new MissingPropertiesError({ envelope, missing, type: 'p256' })\n    return\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    const missing: string[] = []\n\n    if (typeof webauthn.signature?.r !== 'bigint') missing.push('signature.r')\n    if (typeof webauthn.signature?.s !== 'bigint') missing.push('signature.s')\n    if (!webauthn.metadata) missing.push('metadata')\n    else {\n      if (!webauthn.metadata.authenticatorData)\n        missing.push('metadata.authenticatorData')\n      if (!webauthn.metadata.clientDataJSON)\n        missing.push('metadata.clientDataJSON')\n    }\n    if (!webauthn.publicKey) missing.push('publicKey')\n    else {\n      if (typeof webauthn.publicKey.x !== 'bigint') missing.push('publicKey.x')\n      if (typeof webauthn.publicKey.y !== 'bigint') missing.push('publicKey.y')\n    }\n\n    if (missing.length > 0)\n      throw new MissingPropertiesError({ envelope, missing, type: 'webAuthn' })\n    return\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    assert(keychain.inner)\n    return\n  }\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | CoercionError\n    | MissingPropertiesError\n    | Signature.assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a hex-encoded signature envelope into a typed signature object.\n *\n * Wire format detection:\n * - 65 bytes (no prefix): secp256k1 signature\n * - Type `0x01` + 129 bytes: P256 signature (r, s, pubKeyX, pubKeyY, prehash)\n * - Type `0x02` + variable: WebAuthn signature (webauthnData, r, s, pubKeyX, pubKeyY)\n * - Type `0x03` + 20 bytes + inner: Keychain signature (userAddress + inner signature)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.deserialize('0x...')\n * ```\n *\n * @param serialized - The hex-encoded signature envelope to deserialize.\n * @returns The deserialized signature envelope.\n * @throws `CoercionError` if the serialized value cannot be coerced to a valid signature envelope.\n */\nexport function deserialize(value: Serialized): SignatureEnvelope {\n  const serialized = value.endsWith(magicBytes.slice(2))\n    ? Hex.slice(value, 0, -Hex.size(magicBytes))\n    : value\n\n  const size = Hex.size(serialized)\n\n  // Backward compatibility: 65 bytes means secp256k1 without type identifier\n  if (size === 65) {\n    const signature = Signature.fromHex(serialized)\n    Signature.assert(signature)\n    return { signature, type: 'secp256k1' } satisfies Secp256k1\n  }\n\n  // For all other lengths, first byte is the type identifier\n  const typeId = Hex.slice(serialized, 0, 1)\n  const data = Hex.slice(serialized, 1)\n  const dataSize = Hex.size(data)\n\n  if (typeId === serializedP256Type) {\n    // P256: 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash) = 129 bytes\n    if (dataSize !== 129)\n      throw new InvalidSerializedError({\n        reason: `Invalid P256 signature envelope size: expected 129 bytes, got ${dataSize} bytes`,\n        serialized,\n      })\n\n    return {\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(Hex.slice(data, 64, 96)),\n        y: Hex.toBigInt(Hex.slice(data, 96, 128)),\n      },\n      prehash: Hex.toNumber(Hex.slice(data, 128, 129)) !== 0,\n      signature: {\n        r: Hex.toBigInt(Hex.slice(data, 0, 32)),\n        s: Hex.toBigInt(Hex.slice(data, 32, 64)),\n      },\n      type: 'p256',\n    } satisfies P256\n  }\n\n  if (typeId === serializedWebAuthnType) {\n    // WebAuthn: variable (webauthnData) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n    // Minimum: 128 bytes (at least some authenticator data + signature components)\n    if (dataSize < 128)\n      throw new InvalidSerializedError({\n        reason: `Invalid WebAuthn signature envelope size: expected at least 128 bytes, got ${dataSize} bytes`,\n        serialized,\n      })\n\n    const webauthnDataSize = dataSize - 128\n    const webauthnData = Hex.slice(data, 0, webauthnDataSize)\n\n    // Parse webauthnData into authenticatorData and clientDataJSON\n    // According to the Rust code, it's authenticatorData || clientDataJSON\n    // We need to find the split point (minimum authenticatorData is 37 bytes)\n    let authenticatorData: Hex.Hex | undefined\n    let clientDataJSON: string | undefined\n\n    // Try to find the JSON start (clientDataJSON should start with '{')\n    for (let split = 37; split < webauthnDataSize; split++) {\n      const potentialJson = Hex.toString(Hex.slice(webauthnData, split))\n      if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n        try {\n          JSON.parse(potentialJson)\n          authenticatorData = Hex.slice(webauthnData, 0, split)\n          clientDataJSON = potentialJson\n          break\n        } catch {}\n      }\n    }\n\n    if (!authenticatorData || !clientDataJSON)\n      throw new InvalidSerializedError({\n        reason:\n          'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n        serialized,\n      })\n\n    return {\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 64, webauthnDataSize + 96),\n        ),\n        y: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 96, webauthnDataSize + 128),\n        ),\n      },\n      metadata: {\n        authenticatorData,\n        clientDataJSON,\n      },\n      signature: {\n        r: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize, webauthnDataSize + 32),\n        ),\n        s: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 32, webauthnDataSize + 64),\n        ),\n      },\n      type: 'webAuthn',\n    } satisfies WebAuthn\n  }\n\n  if (typeId === serializedKeychainType) {\n    const userAddress = Hex.slice(data, 0, 20)\n    const inner = deserialize(Hex.slice(data, 20))\n\n    return {\n      userAddress,\n      inner,\n      type: 'keychain',\n    } satisfies Keychain\n  }\n\n  throw new InvalidSerializedError({\n    reason: `Unknown signature type identifier: ${typeId}. Expected ${serializedP256Type} (P256) or ${serializedWebAuthnType} (WebAuthn)`,\n    serialized,\n  })\n}\n\n/**\n * Coerces a value to a signature envelope.\n *\n * Accepts either a serialized hex string or an existing signature envelope object.\n * Use this to wrap raw signatures from {@link ox#Secp256k1.(sign:function)}, {@link ox#P256.(sign:function)},\n * {@link ox#WebCryptoP256.(sign:function)}, or {@link ox#WebAuthnP256.(sign:function)} into the envelope format\n * required by Tempo transactions.\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from(signature)\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n * })\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * SHA256 hashes the digest before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: '0xdeadbeef',\n *   credentialId: credential.id,\n * })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * ```\n *\n * @example\n * ### Keychain\n *\n * Wraps another signature type with a user address, used for delegated signing\n * via access keys on behalf of a root account.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   userAddress: '0x1234567890123456789012345678901234567890',\n *   inner: SignatureEnvelope.from(signature),\n * })\n * ```\n *\n * @param value - The value to coerce (either a hex string or signature envelope).\n * @returns The signature envelope.\n */\nexport function from<const value extends from.Value>(\n  value: value | from.Value,\n): from.ReturnValue<value> {\n  if (typeof value === 'string') return deserialize(value) as never\n\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    'r' in value &&\n    's' in value &&\n    'yParity' in value\n  )\n    return { signature: value, type: 'secp256k1' } as never\n\n  const type = getType(value)\n  return {\n    ...value,\n    ...(type === 'p256' ? { prehash: value.prehash } : {}),\n    type,\n  } as never\n}\n\nexport declare namespace from {\n  type Value =\n    | UnionPartialBy<SignatureEnvelope, 'prehash' | 'type'>\n    | Secp256k1Flat\n    | Serialized\n\n  type ReturnValue<value extends Value> = Compute<\n    OneOf<\n      value extends Serialized\n        ? SignatureEnvelope\n        : value extends Secp256k1Flat\n          ? Secp256k1\n          : IsNarrowable<value, SignatureEnvelope> extends true\n            ? SignatureEnvelope\n            : Assign<value, { readonly type: GetType<value> }>\n    >\n  >\n}\n\n/**\n * Converts an RPC-formatted signature envelope to a typed signature envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.fromRpc({\n *   r: '0x0',\n *   s: '0x0',\n *   yParity: '0x0',\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The RPC signature envelope to convert.\n * @returns The signature envelope with bigint values.\n */\nexport function fromRpc(envelope: SignatureEnvelopeRpc): SignatureEnvelope {\n  if (envelope.type === 'secp256k1')\n    return {\n      signature: Signature.fromRpc(envelope),\n      type: 'secp256k1',\n    }\n\n  if (envelope.type === 'p256') {\n    return {\n      prehash: envelope.preHash,\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(envelope.pubKeyX),\n        y: Hex.toBigInt(envelope.pubKeyY),\n      },\n      signature: {\n        r: Hex.toBigInt(envelope.r),\n        s: Hex.toBigInt(envelope.s),\n      },\n      type: 'p256',\n    }\n  }\n\n  if (envelope.type === 'webAuthn') {\n    const webauthnData = envelope.webauthnData\n    const webauthnDataSize = Hex.size(webauthnData)\n\n    // Parse webauthnData into authenticatorData and clientDataJSON\n    let authenticatorData: Hex.Hex | undefined\n    let clientDataJSON: string | undefined\n\n    // Try to find the JSON start (clientDataJSON should start with '{')\n    for (let split = 37; split < webauthnDataSize; split++) {\n      const potentialJson = Hex.toString(Hex.slice(webauthnData, split))\n      if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n        try {\n          JSON.parse(potentialJson)\n          authenticatorData = Hex.slice(webauthnData, 0, split)\n          clientDataJSON = potentialJson\n          break\n        } catch {}\n      }\n    }\n\n    if (!authenticatorData || !clientDataJSON)\n      throw new InvalidSerializedError({\n        reason:\n          'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n        serialized: webauthnData,\n      })\n\n    return {\n      metadata: {\n        authenticatorData,\n        clientDataJSON,\n      },\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(envelope.pubKeyX),\n        y: Hex.toBigInt(envelope.pubKeyY),\n      },\n      signature: {\n        r: Hex.toBigInt(envelope.r),\n        s: Hex.toBigInt(envelope.s),\n      },\n      type: 'webAuthn',\n    }\n  }\n\n  if (\n    envelope.type === 'keychain' ||\n    ('userAddress' in envelope && 'signature' in envelope)\n  )\n    return {\n      type: 'keychain',\n      userAddress: envelope.userAddress,\n      inner: fromRpc(envelope.signature),\n    }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace fromRpc {\n  type ErrorType =\n    | CoercionError\n    | InvalidSerializedError\n    | Signature.fromRpc.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Determines the signature type of an envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const type = SignatureEnvelope.getType({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n * })\n * // @log: 'secp256k1'\n * ```\n *\n * @param envelope - The signature envelope to inspect.\n * @returns The signature type ('secp256k1', 'p256', or 'webAuthn').\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nexport function getType<\n  envelope extends\n    | PartialBy<SignatureEnvelope, 'type'>\n    | Secp256k1Flat\n    | unknown,\n>(envelope: envelope): GetType<envelope> {\n  if (typeof envelope !== 'object' || envelope === null)\n    throw new CoercionError({ envelope })\n\n  if ('type' in envelope && envelope.type) return envelope.type as never\n\n  // Detect secp256k1 signature (backwards compatibility: also support flat structure)\n  if (\n    'signature' in envelope &&\n    !('publicKey' in envelope) &&\n    typeof envelope.signature === 'object' &&\n    envelope.signature !== null &&\n    'r' in envelope.signature &&\n    's' in envelope.signature &&\n    'yParity' in envelope.signature\n  )\n    return 'secp256k1' as never\n\n  // Detect secp256k1 signature (flat structure)\n  if ('r' in envelope && 's' in envelope && 'yParity' in envelope)\n    return 'secp256k1' as never\n\n  // Detect P256 signature\n  if (\n    'signature' in envelope &&\n    'prehash' in envelope &&\n    'publicKey' in envelope &&\n    typeof envelope.prehash === 'boolean'\n  )\n    return 'p256' as never\n\n  // Detect WebAuthn signature\n  if (\n    'signature' in envelope &&\n    'metadata' in envelope &&\n    'publicKey' in envelope\n  )\n    return 'webAuthn' as never\n\n  // Detect Keychain signature\n  if ('userAddress' in envelope && 'inner' in envelope)\n    return 'keychain' as never\n\n  throw new CoercionError({\n    envelope,\n  })\n}\n\n/**\n * Serializes a signature envelope to a hex-encoded string.\n *\n * Wire format:\n * - secp256k1: 65 bytes (no type prefix, for backward compatibility)\n * - P256: `0x01` + r (32) + s (32) + pubKeyX (32) + pubKeyY (32) + prehash (1) = 130 bytes\n * - WebAuthn: `0x02` + webauthnData (variable) + r (32) + s (32) + pubKeyX (32) + pubKeyY (32)\n * - Keychain: `0x03` + userAddress (20) + inner signature (recursive)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const serialized = SignatureEnvelope.serialize({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to serialize.\n * @returns The hex-encoded serialized signature.\n * @throws `CoercionError` if the envelope cannot be serialized.\n */\nexport function serialize(\n  envelope: UnionPartialBy<SignatureEnvelope, 'prehash'>,\n  options: serialize.Options = {},\n): Serialized {\n  const type = getType(envelope)\n\n  // Backward compatibility: no type identifier for secp256k1\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    return Hex.concat(\n      Signature.toHex(secp256k1.signature),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    // Format: 1 byte (type) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash)\n    return Hex.concat(\n      serializedP256Type,\n      Hex.fromNumber(p256.signature.r, { size: 32 }),\n      Hex.fromNumber(p256.signature.s, { size: 32 }),\n      Hex.fromNumber(p256.publicKey.x, { size: 32 }),\n      Hex.fromNumber(p256.publicKey.y, { size: 32 }),\n      Hex.fromNumber(p256.prehash ? 1 : 0, { size: 1 }),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    // Format: 1 byte (type) + variable (authenticatorData || clientDataJSON) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n    const webauthnData = Hex.concat(\n      webauthn.metadata.authenticatorData,\n      Hex.fromString(webauthn.metadata.clientDataJSON),\n    )\n\n    return Hex.concat(\n      serializedWebAuthnType,\n      webauthnData,\n      Hex.fromNumber(webauthn.signature.r, { size: 32 }),\n      Hex.fromNumber(webauthn.signature.s, { size: 32 }),\n      Hex.fromNumber(webauthn.publicKey.x, { size: 32 }),\n      Hex.fromNumber(webauthn.publicKey.y, { size: 32 }),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    return Hex.concat(\n      serializedKeychainType,\n      keychain.userAddress,\n      serialize(keychain.inner),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /**\n     * Whether to serialize the signature envelope with the Tempo magic identifier.\n     * This is useful for being able to distinguish between Tempo and non-Tempo (e.g. ERC-1271) signatures.\n     */\n    magic?: boolean | undefined\n  }\n}\n\n/**\n * Converts a signature envelope to RPC format.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const rpc = SignatureEnvelope.toRpc({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to convert.\n * @returns The RPC signature envelope with hex values.\n */\nexport function toRpc(envelope: SignatureEnvelope): SignatureEnvelopeRpc {\n  const type = getType(envelope)\n\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    return {\n      ...Signature.toRpc(secp256k1.signature),\n      type: 'secp256k1',\n    }\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    return {\n      preHash: p256.prehash,\n      pubKeyX: Hex.fromNumber(p256.publicKey.x, { size: 32 }),\n      pubKeyY: Hex.fromNumber(p256.publicKey.y, { size: 32 }),\n      r: Hex.fromNumber(p256.signature.r, { size: 32 }),\n      s: Hex.fromNumber(p256.signature.s, { size: 32 }),\n      type: 'p256',\n    }\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    const webauthnData = Hex.concat(\n      webauthn.metadata.authenticatorData,\n      Hex.fromString(webauthn.metadata.clientDataJSON),\n    )\n\n    return {\n      pubKeyX: Hex.fromNumber(webauthn.publicKey.x, { size: 32 }),\n      pubKeyY: Hex.fromNumber(webauthn.publicKey.y, { size: 32 }),\n      r: Hex.fromNumber(webauthn.signature.r, { size: 32 }),\n      s: Hex.fromNumber(webauthn.signature.s, { size: 32 }),\n      type: 'webAuthn',\n      webauthnData,\n    }\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    return {\n      type: 'keychain',\n      userAddress: keychain.userAddress,\n      signature: toRpc(keychain.inner),\n    }\n  }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace toRpc {\n  type ErrorType =\n    | CoercionError\n    | Signature.toRpc.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a signature envelope. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const valid = SignatureEnvelope.validate({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The signature envelope to validate.\n * @returns `true` if valid, `false` otherwise.\n */\nexport function validate(\n  envelope: PartialBy<SignatureEnvelope, 'type'>,\n): boolean {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature envelope against a digest/payload.\n *\n * Supports `secp256k1`, `p256`, and `webAuthn` signature types.\n *\n * :::warning\n * `keychain` signatures are not supported and will throw an error.\n * :::\n *\n * @example\n * ### Secp256k1\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from(signature)\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### P256\n *\n * For P256 signatures, the `address` or `publicKey` must match the embedded\n * public key in the signature envelope.\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = P256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: false, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebCryptoP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const payload = '0xdeadbeef'\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: true, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebAuthnP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * const payload = '0xdeadbeef'\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: payload,\n *   credentialId: credential.id,\n * })\n * const envelope = SignatureEnvelope.from({\n *   metadata,\n *   signature,\n *   publicKey: credential.publicKey,\n * })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey: credential.publicKey,\n * })\n * // @log: true\n * ```\n *\n * @param parameters - Verification parameters.\n * @returns `true` if the signature is valid, `false` otherwise.\n */\nexport function verify(\n  signature: SignatureEnvelope,\n  parameters: verify.Parameters,\n): boolean {\n  const { payload } = parameters\n\n  const address = (() => {\n    if (parameters.address) return parameters.address\n    if (parameters.publicKey) return Address.fromPublicKey(parameters.publicKey)\n    return undefined\n  })()\n  if (!address) return false\n\n  const envelope = from(signature)\n\n  if (envelope.type === 'secp256k1') {\n    if (!address) return false\n    return ox_Secp256k1.verify({\n      address,\n      payload,\n      signature: envelope.signature,\n    })\n  }\n\n  if (envelope.type === 'p256') {\n    const envelopeAddress = Address.fromPublicKey(envelope.publicKey)\n    if (!Address.isEqual(envelopeAddress, address)) return false\n    return ox_P256.verify({\n      hash: envelope.prehash,\n      publicKey: envelope.publicKey,\n      payload,\n      signature: envelope.signature,\n    })\n  }\n\n  if (envelope.type === 'webAuthn') {\n    const envelopeAddress = Address.fromPublicKey(envelope.publicKey)\n    if (!Address.isEqual(envelopeAddress, address)) return false\n    return ox_WebAuthnP256.verify({\n      challenge: Hex.from(payload),\n      metadata: envelope.metadata,\n      publicKey: envelope.publicKey,\n      signature: envelope.signature,\n    })\n  }\n\n  throw new VerificationError(\n    `Unable to verify signature envelope of type \"${envelope.type}\".`,\n  )\n}\n\nexport declare namespace verify {\n  type Parameters = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey\n      }\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n      }\n  >\n}\n\n/**\n * Error thrown when a signature envelope cannot be coerced to a valid type.\n */\nexport class CoercionError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.CoercionError'\n  constructor({ envelope }: { envelope: unknown }) {\n    super(\n      `Unable to coerce value (\\`${Json.stringify(envelope)}\\`) to a valid signature envelope.`,\n    )\n  }\n}\n\n/**\n * Error thrown when a signature envelope is missing required properties.\n */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.MissingPropertiesError'\n  constructor({\n    envelope,\n    missing,\n    type,\n  }: {\n    envelope: unknown\n    missing: string[]\n    type: Type\n  }) {\n    super(\n      `Signature envelope of type \"${type}\" is missing required properties: ${missing.map((m) => `\\`${m}\\``).join(', ')}.\\n\\nProvided: ${Json.stringify(envelope)}`,\n    )\n  }\n}\n\n/**\n * Error thrown when a serialized signature envelope cannot be deserialized.\n */\nexport class InvalidSerializedError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.InvalidSerializedError'\n  constructor({\n    reason,\n    serialized,\n  }: {\n    reason: string\n    serialized: Hex.Hex\n  }) {\n    super(`Unable to deserialize signature envelope: ${reason}`, {\n      metaMessages: [`Serialized: ${serialized}`],\n    })\n  }\n}\n\n/**\n * Error thrown when a signature envelope fails to verify.\n */\nexport class VerificationError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.VerificationError'\n}\n", "/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.ts';\n\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nexport const p256: CurveFnWithCreate = createCurve({\n  a: p256_a,\n  b: p256_b,\n  Fp: Fp256,\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha256);\n/** Alias to p256. */\nexport const secp256r1: CurveFnWithCreate = p256;\n\nconst p256_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n  }))();\n\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp384 = Field(\n  BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  )\n);\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nexport const p384: CurveFnWithCreate = createCurve({\n  a: p384_a,\n  b: p384_b,\n  Fp: Fp384,\n  n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n  Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n  Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha384);\n/** Alias to p384. */\nexport const secp384r1: CurveFnWithCreate = p384;\n\nconst p384_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n  }))();\n\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp384r1.ProjectivePoint, (scalars: bigint[]) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: sha384,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp521 = Field(\n  BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  )\n);\n\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt(\n  '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n);\n\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nexport const p521: CurveFnWithCreate = createCurve({\n  a: p521_a,\n  b: p521_b,\n  Fp: Fp521,\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n  h: BigInt(1),\n  lowS: false,\n  allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n} as const, sha512);\n/** Alias to p521. */\nexport const secp521r1: CurveFnWithCreate = p521;\n\nconst p521_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n  }))();\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp521r1.ProjectivePoint, (scalars: bigint[]) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: sha512,\n  }))();\n", "/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type HTFMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\nexport const p256: typeof p256n = p256n;\nexport const secp256r1: typeof p256n = p256n;\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n", "import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256r1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const privateKeyHex =\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2)\n  const sharedPoint = point.multiply(\n    secp256r1.utils.normPrivateKeyToScalar(privateKeyHex),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\nconst decoder = /*#__PURE__*/ new TextDecoder()\n\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(\n  Array.from(\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  ).map((a, i) => [i, a.charCodeAt(0)]),\n)\n\nconst characterToInteger = /*#__PURE__*/ {\n  ...Object.fromEntries(\n    Array.from(\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    ).map((a, i) => [a.charCodeAt(0), i]),\n  ),\n  ['='.charCodeAt(0)]: 0,\n  ['-'.charCodeAt(0)]: 62,\n  ['_'.charCodeAt(0)]: 63,\n} as Record<number, number>\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes, options: fromBytes.Options = {}) {\n  const { pad = true, url = false } = options\n\n  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4)\n\n  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n    const y = (value[j]! << 16) + (value[j + 1]! << 8) + (value[j + 2]! | 0)\n    encoded[i] = integerToCharacter[y >> 18]!\n    encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f]!\n    encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f]!\n    encoded[i + 3] = integerToCharacter[y & 0x3f]!\n  }\n\n  const k = value.length % 3\n  const end = Math.floor(value.length / 3) * 4 + (k && k + 1)\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end))\n  if (pad && k === 1) base64 += '=='\n  if (pad && k === 2) base64 += '='\n  if (url) base64 = base64.replaceAll('+', '-').replaceAll('/', '_')\n  return base64\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}) {\n  return fromBytes(Bytes.fromHex(value), options)\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromString(value: string, options: fromString.Options = {}) {\n  return fromBytes(Bytes.fromString(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  const base64 = value.replace(/=+$/, '')\n\n  const size = base64.length\n\n  const decoded = new Uint8Array(size + 3)\n  encoder.encodeInto(base64 + '===', decoded)\n\n  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n    const x =\n      (characterToInteger[decoded[i]!]! << 18) +\n      (characterToInteger[decoded[i + 1]!]! << 12) +\n      (characterToInteger[decoded[i + 2]!]! << 6) +\n      characterToInteger[decoded[i + 3]!]!\n    decoded[j] = x >> 16\n    decoded[j + 1] = (x >> 8) & 0xff\n    decoded[j + 2] = x & 0xff\n  }\n\n  const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1)\n  return new Uint8Array(decoded.buffer, 0, decodedSize)\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nexport function toHex(value: string): Hex.Hex {\n  return Hex.fromBytes(toBytes(value))\n}\n\nexport declare namespace toHex {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nexport function toString(value: string): string {\n  return Bytes.toString(toBytes(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n", "import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n", "import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex?: number | undefined\n  clientDataJSON: string\n  typeIndex?: number | undefined\n  userVerificationRequired?: boolean | undefined\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n  } = options\n\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    extensions,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge:\n        typeof challenge === 'string' ? Bytes.fromHex(challenge) : challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      ...(extensions && { extensions }),\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n    },\n  }\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | Hex.Hex\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    extensions,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: Array.isArray(credentialId)\n              ? credentialId.map((id) => ({\n                  id: Base64.toBytes(id),\n                  type: 'public-key',\n                }))\n              : [\n                  {\n                    id: Base64.toBytes(credentialId),\n                    type: 'public-key',\n                  },\n                ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      ...(extensions && { extensions }),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | string[] | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** List of Web Authentication API credentials to use during creation or authentication. */\n    extensions?:\n      | internal.PublicKeyCredentialRequestOptions['extensions']\n      | undefined\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion (if typeIndex is provided)\n  if (typeIndex !== undefined) {\n    const type = '\"type\":\"webauthn.get\"'\n    if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n      return false\n  }\n\n  // Extract and validate the challenge from clientDataJSON\n  const challengeMatch =\n    challengeIndex !== undefined\n      ? clientDataJSON\n          .slice(Number(challengeIndex))\n          .match(/^\"challenge\":\"(.*?)\"/)\n      : clientDataJSON.match(/\"challenge\":\"(.*?)\"/)\n  if (!challengeMatch) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = challengeMatch\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n\n// Export types required for inference.\nexport type {\n  AttestationConveyancePreference,\n  AuthenticationExtensionsClientInputs,\n  AuthenticatorAttachment,\n  AuthenticatorSelectionCriteria,\n  AuthenticatorTransport,\n  BufferSource,\n  COSEAlgorithmIdentifier,\n  Credential,\n  CredentialCreationOptions,\n  CredentialMediationRequirement,\n  CredentialRequestOptions,\n  LargeBlobSupport,\n  PrfExtension,\n  PublicKeyCredential,\n  PublicKeyCredentialCreationOptions,\n  PublicKeyCredentialDescriptor,\n  PublicKeyCredentialEntity,\n  PublicKeyCredentialParameters,\n  PublicKeyCredentialRequestOptions,\n  PublicKeyCredentialRpEntity,\n  PublicKeyCredentialType,\n  PublicKeyCredentialUserEntity,\n  ResidentKeyRequirement,\n  UserVerificationRequirement,\n} from './internal/webauthn.js'\n", "import type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute } from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\n\n/**\n * Key authorization for provisioning access keys.\n *\n * Access keys allow a root key (e.g., a passkey) to delegate transaction signing to secondary\n * keys with customizable permissions including expiry timestamps and per-TIP-20 token spending\n * limits. This enables a user to sign transactions without repeated passkey prompts.\n *\n * The root key signs a `KeyAuthorization` to grant an access key permission to sign transactions\n * on its behalf. The authorization is attached to a transaction (which can be signed by the access\n * key itself), and the protocol validates the authorization before storing the key in the\n * AccountKeychain precompile.\n *\n * Key authorization fields:\n * - `address`: Address derived from the access key's public key (the \"key ID\")\n * - `chainId`: Chain ID for replay protection (0 = valid on any chain)\n * - `expiry`: Unix timestamp when the key expires (undefined = never expires)\n * - `limits`: Per-TIP-20 token spending limits (only applies to `transfer()` and `approve()` calls)\n * - `type`: Key type (`secp256k1`, `p256`, or `webAuthn`)\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n */\nexport type KeyAuthorization<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = {\n  /** Address derived from the public key of the key type. */\n  address: Address.Address\n  /** Chain ID for replay protection (0 = valid on any chain). */\n  chainId?: bigintType | undefined\n  /** Unix timestamp when key expires (0 = never expires). */\n  expiry?: numberType | null | undefined\n  /** TIP20 spending limits for this key. */\n  limits?: readonly TokenLimit<bigintType>[] | undefined\n  /** Key type. (secp256k1, P256, WebAuthn). */\n  type: SignatureEnvelope.Type\n} & (signed extends true\n  ? { signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType> }\n  : {\n      signature?:\n        | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n        | undefined\n    })\n\n/** RPC representation of an {@link ox#KeyAuthorization.KeyAuthorization}. */\nexport type Rpc = Omit<\n  KeyAuthorization<false, Hex.Hex, Hex.Hex>,\n  'address' | 'signature' | 'type'\n> & {\n  keyId: Address.Address\n  keyType: SignatureEnvelope.Type\n  signature: SignatureEnvelope.SignatureEnvelopeRpc\n}\n\n/** Signed representation of a Key Authorization. */\nexport type Signed<bigintType = bigint, numberType = number> = KeyAuthorization<\n  true,\n  bigintType,\n  numberType\n>\n\ntype BaseTuple = readonly [\n  chainId: Hex.Hex,\n  keyType: Hex.Hex,\n  keyId: Address.Address,\n]\n\n/** Tuple representation of a Key Authorization. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      authorization:\n        | BaseTuple\n        | readonly [...BaseTuple, expiry: Hex.Hex]\n        | readonly [\n            ...BaseTuple,\n            expiry: Hex.Hex,\n            limits: readonly [token: Address.Address, limit: Hex.Hex][],\n          ],\n      signature: Hex.Hex,\n    ]\n  : readonly [\n      authorization:\n        | BaseTuple\n        | readonly [...BaseTuple, expiry: Hex.Hex]\n        | readonly [\n            ...BaseTuple,\n            expiry: Hex.Hex,\n            limits: readonly [token: Address.Address, limit: Hex.Hex][],\n          ],\n    ]\n\n/**\n * Token spending limit for access keys.\n *\n * Defines a per-TIP-20 token spending limit for an access key. Limits deplete as tokens\n * are spent and can be updated by the root key via `updateSpendingLimit()`.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n */\nexport type TokenLimit<bigintType = bigint> = {\n  /** Address of the TIP-20 token. */\n  token: Address.Address\n  /** Maximum spending amount for this token (enforced over the key's lifetime). */\n  limit: bigintType\n}\n\n/**\n * Converts a Key Authorization object into a typed {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * Use this to create an unsigned key authorization, then sign it with the root key using\n * {@link ox#KeyAuthorization.(getSignPayload:function)} and attach the signature. The signed authorization\n * can be included in a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} via the\n * `keyAuthorization` field to provision the access key on-chain.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ### Secp256k1 Key\n *\n * Standard Ethereum ECDSA key using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### WebCryptoP256 Key\n *\n * ```ts twoslash\n * import { Address, WebCryptoP256, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Attach a signature to a Key Authorization using a Secp256k1 private key to\n * authorize another Secp256k1 key on the account.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const rootPrivateKey = '0x...'\n * const signature = Secp256k1.sign({\n *   payload: KeyAuthorization.getSignPayload(authorization),\n *   privateKey: rootPrivateKey,\n * })\n *\n * const authorization_signed = KeyAuthorization.from(authorization, { signature })\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Attach a signature to a Key Authorization using a WebAuthn credential to\n * authorize a new WebCryptoP256 key on the account.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Address, Value, WebCryptoP256, WebAuthnP256 } from 'ox'\n * import { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: KeyAuthorization.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n *\n * const signatureEnvelope = SignatureEnvelope.from({ // [!code focus]\n *   signature, // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   metadata, // [!code focus]\n * })\n * const authorization_signed = KeyAuthorization.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - A Key Authorization tuple in object format.\n * @param options - Key Authorization options.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nexport function from<\n  const authorization extends KeyAuthorization | Rpc,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  authorization: authorization | KeyAuthorization,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.expiry === 'string')\n    return fromRpc(authorization as Rpc) as never\n  if (options.signature)\n    return {\n      ...authorization,\n      signature: SignatureEnvelope.from(options.signature),\n    } as never\n  return authorization as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = {\n    /** The {@link ox#SignatureEnvelope.SignatureEnvelope} to attach to the Key Authorization. */\n    signature?: signature | SignatureEnvelope.SignatureEnvelope | undefined\n  }\n\n  type ReturnType<\n    authorization extends KeyAuthorization | Rpc = KeyAuthorization,\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyAuthorization = KeyAuthorization.fromRpc({\n *   expiry: '0x174876e800',\n *   keyId: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   keyType: 'secp256k1',\n *   limits: [{ token: '0x20c0000000000000000000000000000000000001', limit: '0xf4240' }],\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0'\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Key Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { chainId = '0x0', keyId, expiry = 0, limits, keyType } = authorization\n  const signature = SignatureEnvelope.fromRpc(authorization.signature)\n  return {\n    address: keyId,\n    chainId: chainId === '0x' ? 0n : Hex.toBigInt(chainId),\n    expiry: Number(expiry),\n    limits: limits?.map((limit) => ({\n      token: limit.token,\n      limit: BigInt(limit.limit),\n    })),\n    signature,\n    type: keyType,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.Tuple} to an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * ```\n *\n * @example\n * Unsigned Key Authorization tuple (no signature):\n *\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n * ])\n * ```\n *\n * @param tuple - The Key Authorization tuple.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [authorization, signatureSerialized] = tuple\n  const [chainId, keyType_hex, keyId, expiry, limits] = authorization\n  const keyType = (() => {\n    switch (keyType_hex) {\n      case '0x':\n      case '0x00':\n        return 'secp256k1'\n      case '0x01':\n        return 'p256'\n      case '0x02':\n        return 'webAuthn'\n      default:\n        throw new Error(`Invalid key type: ${keyType_hex}`)\n    }\n  })()\n  const args: KeyAuthorization = {\n    address: keyId,\n    expiry: typeof expiry !== 'undefined' ? Hex.toNumber(expiry) : undefined,\n    type: keyType,\n    ...(chainId !== '0x' ? { chainId: Hex.toBigInt(chainId) } : {}),\n    ...(typeof expiry !== 'undefined' ? { expiry: Hex.toNumber(expiry) } : {}),\n    ...(typeof limits !== 'undefined'\n      ? {\n          limits: limits.map(([token, limit]) => ({\n            token,\n            limit: BigInt(limit),\n          })),\n        }\n      : {}),\n  }\n  if (signatureSerialized)\n    args.signature = SignatureEnvelope.deserialize(signatureSerialized)\n  return from(args) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    KeyAuthorization<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * The root key must sign this payload to authorize the access key. The resulting signature\n * is attached to the key authorization via {@link ox#KeyAuthorization.(from:function)} with the\n * `signature` option.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const payload = KeyAuthorization.getSignPayload(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: KeyAuthorization): Hex.Hex {\n  return hash(authorization)\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const hash = KeyAuthorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The hash.\n */\nexport function hash(authorization: KeyAuthorization): Hex.Hex {\n  const [authorizationTuple] = toTuple(authorization)\n  const serialized = Rlp.fromHex(authorizationTuple)\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.toRpc({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - A Key Authorization.\n * @returns An RPC-formatted Key Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const {\n    address,\n    chainId = 0n,\n    expiry,\n    limits,\n    type,\n    signature,\n  } = authorization\n\n  return {\n    chainId: chainId === 0n ? '0x' : Hex.fromNumber(chainId),\n    expiry: typeof expiry === 'number' ? Hex.fromNumber(expiry) : null,\n    limits: limits?.map(({ token, limit }) => ({\n      token,\n      limit: Hex.fromNumber(limit),\n    })),\n    keyId: address,\n    signature: SignatureEnvelope.toRpc(signature),\n    keyType: type,\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const tuple = KeyAuthorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   '0x174876e800',\n * // @log:   [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n * // @log:   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   'secp256k1',\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns A Tempo Key Authorization tuple.\n */\nexport function toTuple<const authorization extends KeyAuthorization>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId = 0n, expiry, limits } = authorization\n  const signature = authorization.signature\n    ? SignatureEnvelope.serialize(authorization.signature)\n    : undefined\n  const type = (() => {\n    switch (authorization.type) {\n      case 'secp256k1':\n        return '0x'\n      case 'p256':\n        return '0x01'\n      case 'webAuthn':\n        return '0x02'\n      default:\n        throw new Error(`Invalid key type: ${authorization.type}`)\n    }\n  })()\n  const authorizationTuple = [\n    chainId === 0n ? '0x' : Hex.fromNumber(chainId),\n    type,\n    address,\n    typeof expiry === 'number' ? Hex.fromNumber(expiry) : undefined,\n    limits?.map((limit) => [limit.token, Hex.fromNumber(limit.limit)]) ??\n      undefined,\n  ].filter(Boolean)\n  return [authorizationTuple, ...(signature ? [signature] : [])] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<authorization extends KeyAuthorization = KeyAuthorization> =\n    Compute<Tuple<authorization extends KeyAuthorization<true> ? true : false>>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport * as TokenId from './TokenId.js'\n\n/**\n * Converts a user token and validator token to a pool ID.\n *\n * Pool IDs are deterministic keys derived from two token addresses (order-independent)\n * used to identify trading pairs on Tempo's enshrined stablecoin DEX.\n *\n * [Stablecoin DEX Specification](https://docs.tempo.xyz/protocol/exchange/spec)\n *\n * @example\n * ```ts twoslash\n * import { PoolId } from 'ox/tempo'\n *\n * const poolId = PoolId.from({\n *   userToken: 1n,\n *   validatorToken: 2n,\n * })\n * ```\n *\n * @param value - User token and validator token.\n * @returns The pool ID.\n */\nexport function from(value: from.Value): Hex.Hex {\n  return Hash.keccak256(\n    Hex.concat(\n      Hex.padLeft(TokenId.toAddress(value.userToken), 32),\n      Hex.padLeft(TokenId.toAddress(value.validatorToken), 32),\n    ),\n  )\n}\n\nexport declare namespace from {\n  export type Value = {\n    /** User token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n}\n", "import * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\n\nexport const roles = [\n  'defaultAdmin',\n  'pause',\n  'unpause',\n  'issuer',\n  'burnBlocked',\n] as const\nexport type TokenRole = (typeof roles)[number]\n\nexport const toPreHashed = {\n  defaultAdmin: 'DEFAULT_ADMIN_ROLE',\n  pause: 'PAUSE_ROLE',\n  unpause: 'UNPAUSE_ROLE',\n  issuer: 'ISSUER_ROLE',\n  burnBlocked: 'BURN_BLOCKED_ROLE',\n} as const satisfies Record<TokenRole, string>\n\n/**\n * Serializes a token role to its keccak256 hash representation.\n *\n * TIP-20 includes a built-in RBAC system with roles like `ISSUER_ROLE` (mint/burn),\n * `PAUSE_ROLE`/`UNPAUSE_ROLE` (emergency controls), and `BURN_BLOCKED_ROLE` (compliance).\n *\n * [TIP-20 RBAC](https://docs.tempo.xyz/protocol/tip20/overview#role-based-access-control-rbac)\n *\n * @example\n * ```ts twoslash\n * import { TokenRole } from 'ox/tempo'\n *\n * const hash = TokenRole.serialize('issuer')\n * ```\n *\n * @param role - The token role to serialize.\n * @returns The keccak256 hash of the role.\n */\nexport function serialize(role: TokenRole) {\n  if (role === 'defaultAdmin')\n    return '0x0000000000000000000000000000000000000000000000000000000000000000'\n  return Hash.keccak256(\n    Hex.fromString(toPreHashed[role as keyof typeof toPreHashed] ?? role),\n  )\n}\n", "import type * as AccessList from '../core/AccessList.js'\nimport type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute, OneOf, UnionCompute } from '../core/internal/types.js'\nimport * as Signature from '../core/Signature.js'\nimport * as ox_Transaction from '../core/Transaction.js'\nimport * as AuthorizationTempo from './AuthorizationTempo.js'\nimport * as KeyAuthorization from './KeyAuthorization.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\nimport type { Call } from './TxEnvelopeTempo.js'\n\n/**\n * A Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n */\nexport type Transaction<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = UnionCompute<\n  OneOf<\n    | Tempo<pending, bigintType, numberType>\n    | ox_Transaction.Transaction<pending, bigintType, numberType>\n  >\n>\n\n/**\n * An RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Rpc<pending extends boolean = false> = UnionCompute<\n  OneOf<TempoRpc<pending> | ox_Transaction.Rpc<pending>>\n>\n\n/**\n * Native account abstraction transaction (type `0x76`).\n *\n * Features configurable fee tokens, call batching, fee sponsorship, access keys,\n * parallelizable nonces, and scheduled execution via `validAfter`/`validBefore`.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction Tempo Transaction Specification}\n */\nexport type Tempo<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'tempo',\n> = Compute<\n  Omit<\n    ox_Transaction.Base<type, pending, bigintType, numberType>,\n    // Tempo transactions don't have these properties.\n    'input' | 'to' | 'value' | 'v' | 'r' | 's' | 'yParity'\n  > & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** EIP-7702 Authorization list for the transaction. */\n    authorizationList?:\n      | AuthorizationTempo.ListSigned<bigintType, numberType>\n      | undefined\n    /** Array of calls to execute. */\n    calls: readonly Call<bigintType>[]\n    /** Fee payer signature. */\n    feePayerSignature?:\n      | {\n          /** ECDSA signature r. */\n          r: bigintType\n          /** ECDSA signature s. */\n          s: bigintType\n          /** ECDSA signature yParity. */\n          yParity: numberType\n          /** @deprecated ECDSA signature v (for backwards compatibility). */\n          v?: numberType | undefined\n        }\n      | undefined\n    /** Fee token preference. */\n    feeToken: Address.Address\n    /** Effective gas price paid by the sender in wei. */\n    gasPrice?: bigintType | undefined\n    /** Key authorization for provisioning a new access key. */\n    keyAuthorization?:\n      | KeyAuthorization.KeyAuthorization<true, bigintType, numberType>\n      | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n    /** Nonce key for 2D nonce system (192 bits). */\n    nonceKey?: bigintType | undefined\n    /** Sender signature. */\n    signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n    /** Transaction can only be included in a block before this timestamp. */\n    validBefore?: numberType | undefined\n    /** Transaction can only be included in a block after this timestamp. */\n    validAfter?: numberType | undefined\n  }\n>\n\n/**\n * Native account abstraction transaction in RPC format.\n */\nexport type TempoRpc<pending extends boolean = false> = Compute<\n  Omit<\n    Tempo<pending, Hex.Hex, Hex.Hex, ToRpcType['tempo']>,\n    'authorizationList' | 'calls' | 'keyAuthorization' | 'signature'\n  > & {\n    aaAuthorizationList?: AuthorizationTempo.ListRpc | undefined\n    calls:\n      | readonly {\n          input?: Hex.Hex | undefined\n          to?: Hex.Hex | undefined\n          value?: Hex.Hex | undefined\n        }[]\n      | undefined\n    keyAuthorization?: KeyAuthorization.Rpc | undefined\n    signature: SignatureEnvelope.SignatureEnvelopeRpc\n  }\n>\n\n/** Type to RPC Type mapping. */\nexport const toRpcType = {\n  ...ox_Transaction.toRpcType,\n  tempo: '0x76',\n} as const\n\n/** Type to RPC Type mapping. */\nexport type ToRpcType = typeof toRpcType & {\n  [type: string]: `0x${string}`\n}\n\n/** RPC Type to Type mapping. */\nexport const fromRpcType = {\n  ...ox_Transaction.fromRpcType,\n  '0x76': 'tempo',\n} as const\n\n/** RPC Type to Type mapping. */\n\nexport type FromRpcType = typeof fromRpcType & {\n  [type: `0x${string}`]: string\n}\n\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   calls: [\n *     {\n *       input: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: '0x9b6e64a8ec60000',\n *     },\n *   ],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   signature: {\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     type: 'secp256k1',\n *     yParity: '0x0',\n *   },\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x76',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nexport function fromRpc<\n  const transaction extends Rpc | null,\n  pending extends boolean = false,\n>(\n  transaction: transaction | Rpc<pending> | null,\n  _options: fromRpc.Options<pending> = {},\n): transaction extends Rpc<pending> ? Transaction<pending> : null {\n  if (!transaction) return null as never\n\n  const transaction_ = ox_Transaction.fromRpc(\n    transaction as ox_Transaction.Rpc<pending>,\n  ) as Transaction<pending>\n\n  transaction_.type = fromRpcType[transaction.type as keyof typeof fromRpcType]\n\n  if (transaction.aaAuthorizationList) {\n    transaction_.authorizationList = AuthorizationTempo.fromRpcList(\n      transaction.aaAuthorizationList,\n    )\n    delete (transaction_ as any).aaAuthorizationList\n  }\n  if (transaction.calls)\n    transaction_.calls = transaction.calls.map((call) => ({\n      to: call.to,\n      value: call.value && call.value !== '0x' ? BigInt(call.value) : undefined,\n      // @ts-expect-error\n      data: call.input || call.data || '0x',\n    }))\n  if (transaction.feeToken) transaction_.feeToken = transaction.feeToken\n  if (transaction.nonceKey) transaction_.nonceKey = BigInt(transaction.nonceKey)\n  if (transaction.signature)\n    transaction_.signature = SignatureEnvelope.fromRpc(transaction.signature)\n  if (transaction.validAfter)\n    transaction_.validAfter = Number(transaction.validAfter)\n  if (transaction.validBefore)\n    transaction_.validBefore = Number(transaction.validBefore)\n  if (transaction.keyAuthorization)\n    transaction_.keyAuthorization = KeyAuthorization.fromRpc(\n      transaction.keyAuthorization,\n    )\n  if (transaction.feePayerSignature) {\n    transaction_.feePayerSignature = Signature.fromRpc(\n      transaction.feePayerSignature,\n    )\n    ;(transaction_.feePayerSignature as any).v = Signature.yParityToV(\n      transaction_.feePayerSignature.yParity,\n    )\n  }\n\n  return transaction_ as never\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = ox_Transaction.fromRpc.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: 700000000000000000n,\n *     },\n *   ],\n *   chainId: 1,\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   signature: {\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *     type: 'secp256k1',\n *   },\n *   transactionIndex: 2,\n *   type: 'tempo',\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nexport function toRpc<pending extends boolean = false>(\n  transaction: Transaction<pending>,\n  _options?: toRpc.Options<pending>,\n): Rpc<pending> {\n  const rpc = ox_Transaction.toRpc(\n    transaction as ox_Transaction.Transaction<pending>,\n  ) as Rpc<pending>\n\n  rpc.type = toRpcType[transaction.type as keyof typeof toRpcType]\n\n  if (transaction.authorizationList)\n    rpc.aaAuthorizationList = AuthorizationTempo.toRpcList(\n      transaction.authorizationList as AuthorizationTempo.ListSigned,\n    )\n  if (transaction.calls)\n    rpc.calls = transaction.calls.map((call) => ({\n      to: call.to,\n      value: call.value ? Hex.fromNumber(call.value) : undefined,\n      data: call.data,\n    }))\n  if (transaction.feeToken) rpc.feeToken = transaction.feeToken\n  if (transaction.keyAuthorization)\n    rpc.keyAuthorization = KeyAuthorization.toRpc(transaction.keyAuthorization)\n  if (transaction.feePayerSignature) {\n    rpc.feePayerSignature = Signature.toRpc(\n      transaction.feePayerSignature,\n    ) as any\n    ;(rpc.feePayerSignature as any).v = Hex.fromNumber(\n      Signature.yParityToV(transaction.feePayerSignature?.yParity),\n    )\n  }\n  if (transaction.signature)\n    rpc.signature = SignatureEnvelope.toRpc(transaction.signature)\n  if (typeof transaction.validAfter === 'number')\n    rpc.validAfter = Hex.fromNumber(transaction.validAfter)\n  if (typeof transaction.validBefore === 'number')\n    rpc.validBefore = Hex.fromNumber(transaction.validBefore)\n\n  return rpc as Rpc<pending>\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = ox_Transaction.toRpc.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as AccessList from './AccessList.js'\nimport type * as Address from './Address.js'\nimport * as Authorization from './Authorization.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf, UnionCompute } from './internal/types.js'\nimport * as Signature from './Signature.js'\n\n/**\n * A Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Transaction<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = UnionCompute<\n  OneOf<\n    | Legacy<pending, bigintType, numberType>\n    | Eip1559<pending, bigintType, numberType>\n    | Eip2930<pending, bigintType, numberType>\n    | Eip4844<pending, bigintType, numberType>\n    | Eip7702<pending, bigintType, numberType>\n    | (Base & { type: Hex.Hex })\n  >\n>\n\n/**\n * An RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Rpc<pending extends boolean = false> = UnionCompute<\n  OneOf<\n    | LegacyRpc<pending>\n    | Eip1559Rpc<pending>\n    | Eip2930Rpc<pending>\n    | Eip4844Rpc<pending>\n    | Eip7702Rpc<pending>\n    | (BaseRpc & { type: Hex.Hex })\n  >\n>\n\n/** Base properties of a Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Base<\n  type extends string = string,\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** Hash of the block that contains this transaction, or `null` if pending. */\n  blockHash: pending extends true ? null : Hex.Hex\n  /** Number of block containing this transaction or `null` if pending */\n  blockNumber: pending extends true ? null : bigintType\n  /** Chain ID that this transaction is valid on. */\n  chainId: numberType\n  /** @alias `input` Added for TransactionEnvelope - Transaction compatibility. */\n  data?: Hex.Hex | undefined\n  /** Sender of this transaction */\n  from: Address.Address\n  /** Hash of this transaction */\n  hash: Hex.Hex\n  /** Contract code or a hashed method call with encoded args */\n  input: Hex.Hex\n  /** Gas provided for transaction execution */\n  gas: bigintType\n  /** Unique number identifying this transaction */\n  nonce: bigintType\n  /** Transaction recipient. `null` if the transaction is a contract creation. */\n  to: Address.Address | null\n  /** Index of this transaction in the block or `null` if pending */\n  transactionIndex: pending extends true ? null : numberType\n  /** Transaction type */\n  type: type\n  /** Value in wei sent with this transaction */\n  value: bigintType\n  /** ECDSA signature r. */\n  r: bigintType\n  /** ECDSA signature s. */\n  s: bigintType\n  /** ECDSA signature yParity. */\n  yParity: numberType\n  /** @deprecated ECDSA signature v (for backwards compatibility). */\n  v?: numberType | undefined\n}>\n\n/** Base properties of an RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type BaseRpc<\n  type extends string = string,\n  pending extends boolean = false,\n> = Base<type, pending, Hex.Hex, Hex.Hex>\n\n/** An [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip1559<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip1559',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** Effective gas price paid by the sender in wei. */\n    gasPrice?: bigintType | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip1559Rpc<pending extends boolean = false> = Compute<\n  Eip1559<pending, Hex.Hex, Hex.Hex, ToRpcType['eip1559']>\n>\n\n/** An [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip2930<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip2930',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** The gas price willing to be paid by the sender (in wei). */\n    gasPrice: bigintType\n  }\n>\n\n/** An RPC [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip2930Rpc<pending extends boolean = false> = Compute<\n  Eip2930<pending, Hex.Hex, Hex.Hex, ToRpcType['eip2930']>\n>\n\n/** An [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip4844<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip4844',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** List of versioned blob hashes associated with the transaction's blobs. */\n    blobVersionedHashes: readonly Hex.Hex[]\n    /** Total fee per blob gas in wei. */\n    maxFeePerBlobGas: bigintType\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An RPC [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip4844Rpc<pending extends boolean = false> = Compute<\n  Eip4844<pending, Hex.Hex, Hex.Hex, ToRpcType['eip4844']>\n>\n\n/** An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip7702<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip7702',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** EIP-7702 Authorization list for the transaction. */\n    authorizationList: Authorization.ListSigned<bigintType, numberType>\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An RPC [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip7702Rpc<pending extends boolean = false> = Compute<\n  Eip7702<pending, Hex.Hex, Hex.Hex, ToRpcType['eip7702']>\n>\n\n/** An legacy Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Legacy<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'legacy',\n> = Compute<\n  Omit<\n    Base<type, pending, bigintType, numberType>,\n    'chainId' | 'v' | 'yParity'\n  > & {\n    chainId?: numberType | undefined\n    /** The gas price willing to be paid by the sender (in wei). */\n    gasPrice: bigintType\n    /** ECDSA signature v. */\n    v: numberType\n    /** ECDSA signature yParity. */\n    yParity?: numberType | undefined\n  }\n>\n\n/** A legacy RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type LegacyRpc<pending extends boolean = false> = Compute<\n  Legacy<pending, Hex.Hex, Hex.Hex, ToRpcType['legacy']>\n>\n\n/** Type to RPC Type mapping. */\nexport const toRpcType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\n/** Type to RPC Type mapping. */\nexport type ToRpcType = typeof toRpcType & {\n  [type: string]: `0x${string}`\n}\n\n/** RPC Type to Type mapping. */\nexport const fromRpcType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const\n\n/** RPC Type to Type mapping. */\n\nexport type FromRpcType = typeof fromRpcType & {\n  [type: `0x${string}`]: string\n}\n\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nexport function fromRpc<\n  const transaction extends Rpc | null,\n  pending extends boolean = false,\n>(\n  transaction: transaction | Rpc<pending> | null,\n  _options: fromRpc.Options<pending> = {},\n): transaction extends Rpc<pending> ? Transaction<pending> : null {\n  if (!transaction) return null as never\n\n  const signature = Signature.extract(transaction)\n\n  const transaction_ = {\n    ...transaction,\n    ...signature,\n  } as unknown as Transaction<boolean>\n\n  transaction_.blockNumber = transaction.blockNumber\n    ? BigInt(transaction.blockNumber)\n    : null\n  transaction_.data = transaction.input\n  transaction_.gas = BigInt(transaction.gas ?? 0n)\n  transaction_.nonce = BigInt(transaction.nonce ?? 0n)\n  transaction_.transactionIndex = transaction.transactionIndex\n    ? Number(transaction.transactionIndex)\n    : null\n  transaction_.value = BigInt(transaction.value ?? 0n)\n\n  if (transaction.authorizationList)\n    transaction_.authorizationList = Authorization.fromRpcList(\n      transaction.authorizationList,\n    )\n  if (transaction.chainId) transaction_.chainId = Number(transaction.chainId)\n  if (transaction.gasPrice) transaction_.gasPrice = BigInt(transaction.gasPrice)\n  if (transaction.maxFeePerBlobGas)\n    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas)\n  if (transaction.maxFeePerGas)\n    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas)\n  if (transaction.maxPriorityFeePerGas)\n    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas)\n  if (transaction.type)\n    transaction_.type =\n      (fromRpcType as any)[transaction.type] ?? transaction.type\n  if (signature) transaction_.v = Signature.yParityToV(signature.yParity)\n\n  return transaction_ as never\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   chainId: 1,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n *   v: 27,\n *   value: 700000000000000000n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nexport function toRpc<pending extends boolean = false>(\n  transaction: Transaction<pending>,\n  _options?: toRpc.Options<pending>,\n): Rpc<pending> {\n  const rpc = {} as Rpc<boolean>\n\n  rpc.blockHash = transaction.blockHash\n  rpc.blockNumber =\n    typeof transaction.blockNumber === 'bigint'\n      ? Hex.fromNumber(transaction.blockNumber)\n      : null\n  rpc.from = transaction.from\n  rpc.gas = Hex.fromNumber(transaction.gas ?? 0n)\n  rpc.hash = transaction.hash\n  rpc.input = transaction.input\n  rpc.nonce = Hex.fromNumber(transaction.nonce ?? 0n)\n  rpc.to = transaction.to\n  rpc.transactionIndex = transaction.transactionIndex\n    ? Hex.fromNumber(transaction.transactionIndex)\n    : null\n  rpc.type = (toRpcType as any)[transaction.type] ?? transaction.type\n  rpc.value = Hex.fromNumber(transaction.value ?? 0n)\n\n  if (transaction.accessList) rpc.accessList = transaction.accessList\n  if (transaction.authorizationList)\n    rpc.authorizationList = Authorization.toRpcList(\n      transaction.authorizationList,\n    )\n  if (transaction.blobVersionedHashes)\n    rpc.blobVersionedHashes = transaction.blobVersionedHashes\n  if (transaction.chainId) rpc.chainId = Hex.fromNumber(transaction.chainId)\n  if (typeof transaction.gasPrice === 'bigint')\n    rpc.gasPrice = Hex.fromNumber(transaction.gasPrice)\n  if (typeof transaction.maxFeePerBlobGas === 'bigint')\n    rpc.maxFeePerBlobGas = Hex.fromNumber(transaction.maxFeePerBlobGas)\n  if (typeof transaction.maxFeePerGas === 'bigint')\n    rpc.maxFeePerGas = Hex.fromNumber(transaction.maxFeePerGas)\n  if (typeof transaction.maxPriorityFeePerGas === 'bigint')\n    rpc.maxPriorityFeePerGas = Hex.fromNumber(transaction.maxPriorityFeePerGas)\n  if (typeof transaction.r === 'bigint')\n    rpc.r = Hex.fromNumber(transaction.r, { size: 32 })\n  if (typeof transaction.s === 'bigint')\n    rpc.s = Hex.fromNumber(transaction.s, { size: 32 })\n  if (typeof transaction.v === 'number')\n    rpc.v = Hex.fromNumber(transaction.v, { size: 1 })\n  if (typeof transaction.yParity === 'number')\n    rpc.yParity = transaction.yParity === 0 ? '0x0' : '0x1'\n\n  return rpc as Rpc<pending>\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Address from '../core/Address.js'\nimport type * as Hex from '../core/Hex.js'\nimport type { Compute } from '../core/internal/types.js'\nimport * as ox_TransactionReceipt from '../core/TransactionReceipt.js'\n\n/**\n * Tempo transaction receipt.\n *\n * Extends standard receipts with `feePayer` (the address that paid fees) and\n * `feeToken` (the TIP-20 token used for fee payment).\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n */\nexport type TransactionReceipt<\n  status = ox_TransactionReceipt.Status,\n  type = ox_TransactionReceipt.Type,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  ox_TransactionReceipt.TransactionReceipt<\n    status,\n    type,\n    bigintType,\n    numberType\n  > & {\n    /** Address of the fee payer. */\n    feePayer?: Address.Address | undefined\n    /** Address of the fee token. */\n    feeToken?: Address.Address | undefined\n  }\n>\n\nexport type Rpc = TransactionReceipt<\n  ox_TransactionReceipt.RpcStatus,\n  ox_TransactionReceipt.RpcType,\n  Hex.Hex,\n  Hex.Hex\n>\n\nexport type Type = 'tempo' | ox_TransactionReceipt.Type\n\nexport type RpcType = '0x76' | ox_TransactionReceipt.RpcType\n\nexport type Status = ox_TransactionReceipt.Status\n\nexport type RpcStatus = ox_TransactionReceipt.RpcStatus\n\n/** RPC type to type mapping. */\nexport const fromRpcType = {\n  ...ox_TransactionReceipt.fromRpcType,\n  '0x76': 'tempo',\n} as const\n\n/** Type to RPC type mapping. */\nexport const toRpcType = {\n  ...ox_TransactionReceipt.toRpcType,\n  tempo: '0x76',\n} as const\n\n/**\n * Converts an RPC receipt to a TransactionReceipt.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox/tempo'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   feePayer: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   feeToken: '0x20c0000000000000000000000000000000000001',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   feePayer: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   feeToken: \"0x20c0000000000000000000000000000000000001\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The RPC receipt to convert.\n * @returns A TransactionReceipt.\n */\nexport function fromRpc<const receipt extends Rpc | null>(\n  receipt: receipt | Rpc | null,\n): receipt extends Rpc ? TransactionReceipt : null {\n  return ox_TransactionReceipt.fromRpc(\n    receipt as ox_TransactionReceipt.Rpc,\n  ) as never\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType = ox_TransactionReceipt.fromRpc.ErrorType\n}\n\n/**\n * Converts a TransactionReceipt to an RPC receipt.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox/tempo'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   feePayer: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   feeToken: '0x20c0000000000000000000000000000000000001',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   feePayer: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   feeToken: \"0x20c0000000000000000000000000000000000001\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nexport function toRpc(receipt: TransactionReceipt): Rpc {\n  const rpc = ox_TransactionReceipt.toRpc(\n    receipt as ox_TransactionReceipt.TransactionReceipt,\n  ) as Rpc\n  return {\n    ...rpc,\n    feePayer: receipt.feePayer,\n    feeToken: receipt.feeToken,\n  }\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = ox_TransactionReceipt.toRpc.ErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\n\n/** A Log as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Log<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** The address from which this log originated */\n  address: Address.Address\n  /** Hash of block containing this log or `null` if pending */\n  blockHash: pending extends true ? null : Hex.Hex\n  /** Number of block containing this log or `null` if pending */\n  blockNumber: pending extends true ? null : bigintType\n  /** Contains the non-integered arguments of the log */\n  data: Hex.Hex\n  /** Index of this log within its block or `null` if pending */\n  logIndex: pending extends true ? null : numberType\n  /** List of topics associated with this log */\n  topics: [Hex.Hex, ...(readonly Hex.Hex[])]\n  /** Hash of the transaction that created this log or `null` if pending */\n  transactionHash: pending extends true ? null : Hex.Hex\n  /** Index of the transaction that created this log or `null` if pending */\n  transactionIndex: pending extends true ? null : numberType\n  /** `true` if this filter has been destroyed and is invalid */\n  removed: boolean\n}>\n\n/** An RPC Log as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Rpc<pending extends boolean = false> = Log<\n  pending,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/**\n * Converts a {@link ox#Log.Rpc} to an {@link ox#Log.Log}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.fromRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   data: '0x',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: '0x12d846c',\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: '0x91',\n *   logIndex: '0x10f',\n *   removed: false,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use `Log.fromRpc` to instantiate a {@link ox#Log.Log} from an RPC log.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param log - The RPC log to convert.\n * @returns An instantiated {@link ox#Log.Log}.\n */\nexport function fromRpc<\n  const log extends Rpc<boolean>,\n  pending extends boolean = false,\n>(\n  log: log | Rpc<boolean>,\n  _options: fromRpc.Options<pending> = {},\n): Log<pending> {\n  return {\n    ...log,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n  } as Log<pending>\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Log.Log} to a {@link ox#Log.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.toRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: 19760236n,\n *   data: '0x',\n *   logIndex: 271,\n *   removed: false,\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: 145,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: '0x012d846c',\n * // @log:   data: '0x',\n * // @log:   logIndex: '0x010f',\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:     '0x0000000000000000000000000000000000000000000000000000000000000000',\n * // @log:     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n * // @log:     '0x000000000000000000000000000000000000000000000000000000000000025b',\n * // @log:   ],\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: '0x91',\n * // @log: }\n * ```\n *\n * @param log - The log to convert.\n * @returns An RPC log.\n */\nexport function toRpc<\n  const log extends Log<boolean>,\n  pending extends boolean = false,\n>(log: log, _options: toRpc.Options<pending> = {}): Rpc<pending> {\n  return {\n    address: log.address,\n    blockHash: log.blockHash,\n    blockNumber:\n      typeof log.blockNumber === 'bigint'\n        ? Hex.fromNumber(log.blockNumber)\n        : null,\n    data: log.data,\n    logIndex:\n      typeof log.logIndex === 'number' ? Hex.fromNumber(log.logIndex) : null,\n    topics: log.topics,\n    transactionHash: log.transactionHash,\n    transactionIndex:\n      typeof log.transactionIndex === 'number'\n        ? Hex.fromNumber(log.transactionIndex)\n        : null,\n    removed: log.removed,\n  } as Rpc as never\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Log from './Log.js'\n\n/** An Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type TransactionReceipt<\n  status = Status,\n  type = Type,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasPrice?: bigintType | undefined\n  /** The amount of blob gas used. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasUsed?: bigintType | undefined\n  /** Hash of block containing this transaction */\n  blockHash: Hex.Hex\n  /** Number of block containing this transaction */\n  blockNumber: bigintType\n  /** Address of new contract or `null` if no contract was created */\n  contractAddress?: Address.Address | null | undefined\n  /** Gas used by this and all preceding transactions in this block */\n  cumulativeGasUsed: bigintType\n  /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */\n  effectiveGasPrice: bigintType\n  /** Transaction sender */\n  from: Address.Address\n  /** Gas used by this transaction */\n  gasUsed: bigintType\n  /** List of log objects generated by this transaction */\n  logs: Log.Log<false, bigintType, numberType>[]\n  /** Logs bloom filter */\n  logsBloom: Hex.Hex\n  /** The post-transaction state root. Only specified for transactions included before the Byzantium upgrade. */\n  root?: Hex.Hex | undefined\n  /** `success` if this transaction was successful or `reverted` if it failed */\n  status: status\n  /** Transaction recipient or `null` if deploying a contract */\n  to: Address.Address | null\n  /** Hash of this transaction */\n  transactionHash: Hex.Hex\n  /** Index of this transaction in the block */\n  transactionIndex: numberType\n  /** Transaction type */\n  type: type\n}>\n\n/** An RPC Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Rpc = TransactionReceipt<RpcStatus, RpcType, Hex.Hex, Hex.Hex>\n\n/**\n * Union of Transaction Receipt statuses.\n *\n * - `success`\n * - `reverted`\n */\nexport type Status = 'success' | 'reverted'\n\n/**\n * Union of RPC Transaction Receipt statuses.\n *\n * - `0x0`\n * - `0x1`\n */\nexport type RpcStatus = '0x0' | '0x1'\n\n/**\n * Union of Transaction Receipt types.\n *\n * - `legacy`\n * - `eip1559`\n * - `eip2930`\n * - `eip4844`\n * - `eip7702`\n * - any other string\n */\nexport type Type =\n  | 'legacy'\n  | 'eip1559'\n  | 'eip2930'\n  | 'eip4844'\n  | 'eip7702'\n  | (string & {})\n\n/**\n * Union of RPC Transaction Receipt types.\n *\n * - `0x0`: legacy transactions\n * - `0x1`: EIP-1559 transactions\n * - `0x2`: EIP-2930 transactions\n * - `0x3`: EIP-4844 transactions\n * - `0x4`: EIP-7702 transactions\n * - any other string\n */\nexport type RpcType = '0x0' | '0x1' | '0x2' | '0x3' | '0x4' | (string & {})\n\n/** RPC status to status mapping. */\nexport const fromRpcStatus = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\n/** Status to RPC status mapping. */\nexport const toRpcStatus = {\n  reverted: '0x0',\n  success: '0x1',\n} as const\n\n/** RPC type to type mapping. */\nexport const fromRpcType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const\n\n/** Type to RPC type mapping. */\nexport const toRpcType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\n/**\n * Converts a {@link ox#TransactionReceipt.Rpc} to an {@link ox#TransactionReceipt.TransactionReceipt}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use the `TransactionReceipt.fromRpc` method to convert an RPC transaction receipt to a {@link ox#TransactionReceipt.TransactionReceipt} object.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param receipt - The RPC receipt to convert.\n * @returns An instantiated {@link ox#TransactionReceipt.TransactionReceipt}.\n */\nexport function fromRpc<const receipt extends Rpc | null>(\n  receipt: receipt | Rpc | null,\n): receipt extends Rpc ? TransactionReceipt : null {\n  if (!receipt) return null as never\n\n  return {\n    ...receipt,\n    blobGasPrice: receipt.blobGasPrice\n      ? BigInt(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : undefined,\n    blockNumber: BigInt(receipt.blockNumber ?? 0n),\n    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),\n    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),\n    gasUsed: BigInt(receipt.gasUsed ?? 0n),\n    logs: receipt.logs.map((log) => Log.fromRpc(log, { pending: false })),\n    status: fromRpcStatus[receipt.status],\n    transactionIndex: Number(receipt.transactionIndex ?? 0),\n    type: (fromRpcType as any)[receipt.type] || receipt.type,\n  } as never\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType = Log.fromRpc.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#TransactionReceipt.TransactionReceipt} to a {@link ox#TransactionReceipt.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nexport function toRpc(receipt: TransactionReceipt): Rpc {\n  return {\n    blobGasPrice: receipt.blobGasPrice\n      ? Hex.fromNumber(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed\n      ? Hex.fromNumber(receipt.blobGasUsed)\n      : undefined,\n    blockHash: receipt.blockHash,\n    blockNumber: Hex.fromNumber(receipt.blockNumber),\n    contractAddress: receipt.contractAddress,\n    cumulativeGasUsed: Hex.fromNumber(receipt.cumulativeGasUsed),\n    effectiveGasPrice: Hex.fromNumber(receipt.effectiveGasPrice),\n    from: receipt.from,\n    gasUsed: Hex.fromNumber(receipt.gasUsed),\n    logs: receipt.logs.map(Log.toRpc as never),\n    logsBloom: receipt.logsBloom,\n    root: receipt.root,\n    status: toRpcStatus[receipt.status],\n    to: receipt.to,\n    transactionHash: receipt.transactionHash,\n    transactionIndex: Hex.fromNumber(receipt.transactionIndex),\n    type: (toRpcType as any)[receipt.type] ?? receipt.type,\n  }\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute } from '../core/internal/types.js'\nimport * as ox_TransactionRequest from '../core/TransactionRequest.js'\nimport * as AuthorizationTempo from './AuthorizationTempo.js'\nimport * as KeyAuthorization from './KeyAuthorization.js'\nimport * as TokenId from './TokenId.js'\nimport * as Transaction from './Transaction.js'\nimport type { Call } from './TxEnvelopeTempo.js'\n\ntype KeyType = 'secp256k1' | 'p256' | 'webAuthn'\n\n/**\n * A Transaction Request that is generic to all transaction types.\n *\n * Extends the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4aca1d7a3e5aab24c8f6437131289ad386944eaa/src/schemas/transaction.yaml#L358-L423)\n * with Tempo-specific fields for batched calls, fee tokens, access keys, and scheduled execution.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n */\nexport type TransactionRequest<\n  bigintType = bigint,\n  numberType = number,\n  type extends string = string,\n> = Compute<\n  Omit<\n    ox_TransactionRequest.TransactionRequest<bigintType, numberType, type>,\n    'authorizationList'\n  > & {\n    authorizationList?:\n      | AuthorizationTempo.ListSigned<bigintType, numberType>\n      | undefined\n    calls?: readonly Call<bigintType>[] | undefined\n    keyAuthorization?: KeyAuthorization.KeyAuthorization<true> | undefined\n    keyData?: Hex.Hex | undefined\n    keyType?: KeyType | undefined\n    feeToken?: TokenId.TokenIdOrAddress | undefined\n    nonceKey?: 'random' | bigintType | undefined\n    validBefore?: numberType | undefined\n    validAfter?: numberType | undefined\n  }\n>\n\n/** RPC representation of a {@link ox#TransactionRequest.TransactionRequest}. */\nexport type Rpc = Omit<\n  TransactionRequest<Hex.Hex, Hex.Hex, string>,\n  'authorizationList' | 'keyAuthorization'\n> & {\n  authorizationList?: AuthorizationTempo.ListRpc | undefined\n  keyAuthorization?: KeyAuthorization.Rpc | undefined\n  nonceKey?: Hex.Hex | undefined\n}\n\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */\nexport function toRpc(request: TransactionRequest): Rpc {\n  const request_rpc = ox_TransactionRequest.toRpc({\n    ...request,\n    authorizationList: undefined,\n  }) as Rpc\n\n  if (request.authorizationList)\n    request_rpc.authorizationList = AuthorizationTempo.toRpcList(\n      request.authorizationList,\n    )\n  if (request.calls)\n    request_rpc.calls = request.calls.map((call) => ({\n      to: call.to,\n      value: call.value ? Hex.fromNumber(call.value) : '0x',\n      data: call.data ?? '0x',\n    }))\n  if (typeof request.feeToken !== 'undefined')\n    request_rpc.feeToken = TokenId.toAddress(request.feeToken)\n  if (request.keyAuthorization)\n    request_rpc.keyAuthorization = KeyAuthorization.toRpc(\n      request.keyAuthorization,\n    )\n  if (typeof request.validBefore !== 'undefined')\n    request_rpc.validBefore = Hex.fromNumber(request.validBefore)\n  if (typeof request.validAfter !== 'undefined')\n    request_rpc.validAfter = Hex.fromNumber(request.validAfter)\n\n  const nonceKey = (() => {\n    if (request.nonceKey === 'random') return Hex.random(6)\n    if (typeof request.nonceKey === 'bigint')\n      return Hex.fromNumber(request.nonceKey)\n    return undefined\n  })()\n  if (nonceKey) request_rpc.nonceKey = nonceKey\n\n  if (\n    typeof request.calls !== 'undefined' ||\n    typeof request.feeToken !== 'undefined' ||\n    typeof request.keyAuthorization !== 'undefined' ||\n    typeof request.nonceKey !== 'undefined' ||\n    typeof request.validBefore !== 'undefined' ||\n    typeof request.validAfter !== 'undefined' ||\n    request.type === 'tempo'\n  ) {\n    request_rpc.type = Transaction.toRpcType.tempo\n    delete request_rpc.data\n    delete request_rpc.input\n    delete request_rpc.to\n    delete request_rpc.value\n  }\n\n  return request_rpc\n}\n\nexport declare namespace toRpc {\n  export type ErrorType =\n    | AuthorizationTempo.toRpcList.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import type * as AccessList from './AccessList.js'\nimport type * as Address from './Address.js'\nimport * as Authorization from './Authorization.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Transaction from './Transaction.js'\n\n/** A Transaction Request that is generic to all transaction types, as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4aca1d7a3e5aab24c8f6437131289ad386944eaa/src/schemas/transaction.yaml#L358-L423). */\nexport type TransactionRequest<\n  bigintType = bigint,\n  numberType = number,\n  type extends string = string,\n> = Compute<{\n  /** EIP-2930 Access List. */\n  accessList?: AccessList.AccessList | undefined\n  /** EIP-7702 Authorization List. */\n  authorizationList?:\n    | Authorization.ListSigned<bigintType, numberType>\n    | undefined\n  /** Versioned hashes of blobs to be included in the transaction. */\n  blobVersionedHashes?: readonly Hex.Hex[]\n  /** Raw blob data. */\n  blobs?: readonly Hex.Hex[] | undefined\n  /** EIP-155 Chain ID. */\n  chainId?: numberType | undefined\n  /** Contract code or a hashed method call with encoded args */\n  data?: Hex.Hex | undefined\n  /** @alias `data`  added for TransactionEnvelope - Transaction compatibility. */\n  input?: Hex.Hex | undefined\n  /** Sender of the transaction. */\n  from?: Address.Address | undefined\n  /** Gas provided for transaction execution */\n  gas?: bigintType | undefined\n  /** Base fee per gas. */\n  gasPrice?: bigintType | undefined\n  /** Maximum total fee per gas sender is willing to pay for blob gas (in wei). */\n  maxFeePerBlobGas?: bigintType | undefined\n  /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n  maxFeePerGas?: bigintType | undefined\n  /** Max priority fee per gas (in wei). */\n  maxPriorityFeePerGas?: bigintType | undefined\n  /** Unique number identifying this transaction */\n  nonce?: bigintType | undefined\n  /** Transaction recipient */\n  to?: Address.Address | null | undefined\n  /** Transaction type */\n  type?: type | undefined\n  /** Value in wei sent with this transaction */\n  value?: bigintType | undefined\n}>\n\n/** RPC representation of a {@link ox#TransactionRequest.TransactionRequest}. */\nexport type Rpc = TransactionRequest<Hex.Hex, Hex.Hex, string>\n\n/**\n * Converts a {@link ox#TransactionRequest.Rpc} to a {@link ox#TransactionRequest.TransactionRequest}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest } from 'ox'\n *\n * const request = TransactionRequest.fromRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: '0x2386f26fc10000',\n * })\n * ```\n *\n * @param request - The RPC request to convert.\n * @returns A transaction request.\n */\nexport function fromRpc(request: Rpc): TransactionRequest {\n  const request_ = request as TransactionRequest\n\n  if (typeof request.authorizationList !== 'undefined')\n    request_.authorizationList = Authorization.fromRpcList(\n      request.authorizationList,\n    )\n  if (typeof request.chainId !== 'undefined')\n    request_.chainId = Hex.toNumber(request.chainId)\n  if (typeof request.gas !== 'undefined')\n    request_.gas = Hex.toBigInt(request.gas)\n  if (typeof request.gasPrice !== 'undefined')\n    request_.gasPrice = Hex.toBigInt(request.gasPrice)\n  if (typeof request.maxFeePerBlobGas !== 'undefined')\n    request_.maxFeePerBlobGas = Hex.toBigInt(request.maxFeePerBlobGas)\n  if (typeof request.maxFeePerGas !== 'undefined')\n    request_.maxFeePerGas = Hex.toBigInt(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    request_.maxPriorityFeePerGas = Hex.toBigInt(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    request_.nonce = Hex.toBigInt(request.nonce)\n  if (typeof request.type !== 'undefined')\n    request_.type =\n      Transaction.fromRpcType[\n        request.type as keyof typeof Transaction.fromRpcType\n      ] || request.type\n  if (typeof request.value !== 'undefined')\n    request_.value = Hex.toBigInt(request.value)\n\n  return request_\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType =\n    | Authorization.fromRpcList.ErrorType\n    | Hex.toNumber.ErrorType\n    | Hex.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest, Value } from 'ox'\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('0.01'),\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('0.01'),\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */\nexport function toRpc(request: TransactionRequest): Rpc {\n  const request_rpc: Rpc = {}\n\n  if (typeof request.accessList !== 'undefined')\n    request_rpc.accessList = request.accessList\n  if (typeof request.authorizationList !== 'undefined')\n    request_rpc.authorizationList = Authorization.toRpcList(\n      request.authorizationList,\n    )\n  if (typeof request.blobVersionedHashes !== 'undefined')\n    request_rpc.blobVersionedHashes = request.blobVersionedHashes\n  if (typeof request.blobs !== 'undefined') request_rpc.blobs = request.blobs\n  if (typeof request.chainId !== 'undefined')\n    request_rpc.chainId = Hex.fromNumber(request.chainId)\n  if (typeof request.data !== 'undefined') {\n    request_rpc.data = request.data\n    request_rpc.input = request.data\n  } else if (typeof request.input !== 'undefined') {\n    request_rpc.data = request.input\n    request_rpc.input = request.input\n  }\n  if (typeof request.from !== 'undefined') request_rpc.from = request.from\n  if (typeof request.gas !== 'undefined')\n    request_rpc.gas = Hex.fromNumber(request.gas)\n  if (typeof request.gasPrice !== 'undefined')\n    request_rpc.gasPrice = Hex.fromNumber(request.gasPrice)\n  if (typeof request.maxFeePerBlobGas !== 'undefined')\n    request_rpc.maxFeePerBlobGas = Hex.fromNumber(request.maxFeePerBlobGas)\n  if (typeof request.maxFeePerGas !== 'undefined')\n    request_rpc.maxFeePerGas = Hex.fromNumber(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    request_rpc.maxPriorityFeePerGas = Hex.fromNumber(\n      request.maxPriorityFeePerGas,\n    )\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    request_rpc.maxPriorityFeePerGas = Hex.fromNumber(\n      request.maxPriorityFeePerGas,\n    )\n  if (typeof request.nonce !== 'undefined')\n    request_rpc.nonce = Hex.fromNumber(request.nonce)\n  if (typeof request.to !== 'undefined') request_rpc.to = request.to\n  if (typeof request.type !== 'undefined')\n    request_rpc.type =\n      Transaction.toRpcType[\n        request.type as keyof typeof Transaction.toRpcType\n      ] || request.type\n  if (typeof request.value !== 'undefined')\n    request_rpc.value = Hex.fromNumber(request.value)\n\n  return request_rpc\n}\n\nexport declare namespace toRpc {\n  export type ErrorType =\n    | Authorization.toRpcList.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import * as AccessList from '../core/AccessList.js'\nimport * as Address from '../core/Address.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type {\n  Assign,\n  Compute,\n  OneOf,\n  PartialBy,\n  UnionPartialBy,\n} from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as Signature from '../core/Signature.js'\nimport * as TransactionEnvelope from '../core/TxEnvelope.js'\nimport * as AuthorizationTempo from './AuthorizationTempo.js'\nimport * as KeyAuthorization from './KeyAuthorization.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\nimport * as TokenId from './TokenId.js'\n\n/**\n * Represents a single call within a Tempo transaction.\n *\n * Tempo transactions support batching multiple calls for atomic execution.\n *\n * [Batch Calls](https://docs.tempo.xyz/protocol/transactions#batch-calls)\n */\nexport type Call<bigintType = bigint> = {\n  /** Call data. */\n  data?: Hex.Hex | undefined\n  /** The target address or contract creation. */\n  to?: Address.Address | undefined\n  /** Value to send (in wei). */\n  value?: bigintType | undefined\n}\n\n/**\n * Tempo transaction envelope (type `0x76`).\n *\n * A new EIP-2718 transaction type exclusively available on Tempo, designed for payment\n * use cases with the following features:\n *\n * - **Configurable Fee Tokens**: Pay transaction fees with any USD-denominated TIP-20 token.\n *   The Fee AMM automatically converts to the validator's preferred token.\n *\n * - **Fee Sponsorship**: A third-party fee payer can pay fees on behalf of the sender using\n *   a dual-signature scheme (sender signs tx, fee payer signs over tx + sender address).\n *\n * - **Batch Calls**: Execute multiple operations atomically in a single transaction via\n *   the `calls` array, reducing overhead and simplifying wallet management.\n *\n * - **Access Keys**: Delegate signing to secondary keys with expiry and per-TIP-20 spending\n *   limits via `keyAuthorization`. Enables passkey UX without repeated prompts.\n *\n * - **Parallelizable Nonces**: Use different `nonceKey` values to submit multiple transactions\n *   in parallel without waiting for sequential nonce confirmation.\n *\n * - **Scheduled Transactions**: Set `validAfter` and `validBefore` timestamps to define a\n *   time window for when the transaction can be included in a block.\n *\n * - **Multi-Signature Support**: Sign with secp256k1, P256 (passkeys), or WebAuthn credentials.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n */\nexport type TxEnvelopeTempo<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** EIP-7702 (Tempo) Authorization list for the transaction. */\n    authorizationList?:\n      | AuthorizationTempo.ListSigned<bigintType, numberType>\n      | undefined\n    /** Array of calls to execute. */\n    calls: readonly Call<bigintType>[]\n    /** EIP-155 Chain ID. */\n    chainId: numberType\n    /** Sender of the transaction. */\n    from?: Address.Address | undefined\n    /** Gas provided for transaction execution */\n    gas?: bigintType | undefined\n    /** Fee payer signature. */\n    feePayerSignature?:\n      | Signature.Signature<true, bigintType, numberType>\n      | null\n      | undefined\n    /** Fee token preference. Address or ID of the TIP-20 token. */\n    feeToken?: TokenId.TokenIdOrAddress | undefined\n    /**\n     * Key authorization for provisioning a new access key.\n     *\n     * When present, this transaction will add the specified key to the AccountKeychain precompile,\n     * before verifying the transaction signature.\n     * The authorization must be signed with the root key, the tx can be signed by the Keychain signature.\n     */\n    keyAuthorization?:\n      | KeyAuthorization.Signed<bigintType, numberType>\n      | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n    /** Nonce key for 2D nonce system (192 bits). */\n    nonceKey?: bigintType | undefined\n    /** Unique number identifying this transaction */\n    nonce?: bigintType | undefined\n    /** Transaction type */\n    type: type\n    /** Transaction can only be included in a block before this timestamp. */\n    validBefore?: numberType | undefined\n    /** Transaction can only be included in a block after this timestamp. */\n    validAfter?: numberType | undefined\n  } & (signed extends true\n    ? {\n        signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n      }\n    : {\n        signature?:\n          | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n          | undefined\n      })\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeTempo<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x76'\n>\n\nexport const feePayerMagic = '0x78' as const\nexport type FeePayerMagic = typeof feePayerMagic\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport type Signed = TxEnvelopeTempo<true>\n\nexport const serializedType = '0x76' as const\nexport type SerializedType = typeof serializedType\n\nexport const type = 'tempo' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 0n }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeTempo, 'type'>) {\n  const {\n    calls,\n    chainId,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    validBefore,\n    validAfter,\n  } = envelope\n\n  // Calls must not be empty\n  if (!calls || calls.length === 0) throw new CallsEmptyError()\n\n  // validBefore must be greater than validAfter if both are set\n  if (\n    typeof validBefore === 'number' &&\n    typeof validAfter === 'number' &&\n    validBefore <= validAfter\n  ) {\n    throw new InvalidValidityWindowError({\n      validBefore: validBefore,\n      validAfter: validAfter,\n    })\n  }\n\n  // Validate each call\n  if (calls)\n    for (const call of calls)\n      if (call.to) Address.assert(call.to, { strict: false })\n\n  // Validate chain ID\n  if (chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n\n  // Validate max fee per gas\n  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.FeeCapTooHighError({\n      feeCap: maxFeePerGas,\n    })\n\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TransactionEnvelope.TipAboveFeeCapError({\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | CallsEmptyError\n    | InvalidValidityWindowError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.deserialize('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   type: 'tempo',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   calls: [{ to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: 1000000000000000000n }],\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized: Serialized): Compute<TxEnvelopeTempo> {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    calls,\n    accessList,\n    nonceKey,\n    nonce,\n    validBefore,\n    validAfter,\n    feeToken,\n    feePayerSignatureOrSender,\n    authorizationList,\n    keyAuthorizationOrSignature,\n    maybeSignature,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  const keyAuthorization = Array.isArray(keyAuthorizationOrSignature)\n    ? keyAuthorizationOrSignature\n    : undefined\n  const signature = keyAuthorization\n    ? maybeSignature\n    : keyAuthorizationOrSignature\n\n  if (\n    !(\n      transactionArray.length === 13 ||\n      transactionArray.length === 14 ||\n      transactionArray.length === 15\n    )\n  )\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        authorizationList,\n        chainId,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        calls,\n        accessList,\n        keyAuthorization,\n        nonceKey,\n        nonce,\n        validBefore,\n        validAfter,\n        feeToken,\n        feePayerSignatureOrSender,\n        ...(transactionArray.length > 12\n          ? {\n              signature,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId),\n    type,\n  } as TxEnvelopeTempo\n\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (Hex.validate(nonceKey))\n    transaction.nonceKey = nonceKey === '0x' ? 0n : BigInt(nonceKey)\n  if (Hex.validate(validBefore) && validBefore !== '0x')\n    transaction.validBefore = Number(validBefore)\n  if (Hex.validate(validAfter) && validAfter !== '0x')\n    transaction.validAfter = Number(validAfter)\n  if (Hex.validate(feeToken) && feeToken !== '0x')\n    transaction.feeToken = feeToken\n\n  // Parse calls array\n  if (calls && calls !== '0x') {\n    const callsArray = calls as unknown as readonly Hex.Hex[][]\n    transaction.calls = callsArray.map((callTuple) => {\n      const [to, value, data] = callTuple\n      const call: Call = {}\n      if (to && to !== '0x') call.to = to\n      if (value && value !== '0x') call.value = BigInt(value)\n      if (data && data !== '0x') call.data = data\n      return call\n    })\n  }\n\n  if (accessList?.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as never)\n\n  if (authorizationList?.length !== 0 && authorizationList !== '0x')\n    transaction.authorizationList = AuthorizationTempo.fromTupleList(\n      authorizationList as never,\n    )\n\n  if (\n    feePayerSignatureOrSender !== '0x' &&\n    feePayerSignatureOrSender !== undefined\n  ) {\n    if (\n      feePayerSignatureOrSender === '0x00' ||\n      Address.validate(feePayerSignatureOrSender)\n    )\n      transaction.feePayerSignature = null\n    else\n      transaction.feePayerSignature = Signature.fromTuple(\n        feePayerSignatureOrSender as never,\n      )\n  }\n\n  if (keyAuthorization)\n    transaction.keyAuthorization = KeyAuthorization.fromTuple(\n      keyAuthorization as never,\n    )\n\n  const signatureEnvelope = signature\n    ? SignatureEnvelope.deserialize(signature)\n    : undefined\n  if (signatureEnvelope)\n    transaction = {\n      ...transaction,\n      signature: signatureEnvelope,\n    }\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into a Tempo Transaction Envelope.\n *\n * Use this to create transaction envelopes with Tempo-specific features like batched calls,\n * fee tokens, access keys, and scheduled execution. Attach a signature using the `signature`\n * option after signing with {@link ox#TxEnvelopeTempo.(getSignPayload:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({ // [!code focus]\n *   chainId: 1, // [!code focus]\n *   calls: [{ // [!code focus]\n *     data: '0xdeadbeef', // [!code focus]\n *     to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   }], // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 1000000000000000000n }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   type: 'tempo',\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate a Tempo Transaction Envelope from a {@link ox#TxEnvelopeTempo.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{\n * // @log:     data: '0xdeadbeef',\n * // @log:     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   type: 'tempo',\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A Tempo Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeTempo, 'type'> | Serialized,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeTempo, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnValue<envelope, signature> {\n  const { feePayerSignature, signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeTempo\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? { signature: SignatureEnvelope.from(signature) } : {}),\n    ...(feePayerSignature\n      ? { feePayerSignature: Signature.from(feePayerSignature) }\n      : {}),\n    type: 'tempo',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined = undefined,\n  > = {\n    feePayerSignature?: Signature.Signature | null | undefined\n    signature?: signature | SignatureEnvelope.from.Value | undefined\n  }\n\n  type ReturnValue<\n    envelope extends UnionPartialBy<TxEnvelopeTempo, 'type'> | Hex.Hex =\n      | TxEnvelopeTempo\n      | Hex.Hex,\n    signature extends SignatureEnvelope.from.Value | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeTempo\n      : Assign<\n          envelope,\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {}) & {\n            readonly type: 'tempo'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * RLP-encodes the transaction with type prefix `0x76`. For fee sponsorship, use `format: 'feePayer'`\n * to serialize with the fee payer magic `0x78` and the sender address.\n *\n * [RLP Encoding](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#rlp-encoding)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeTempo, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    accessList,\n    authorizationList,\n    calls,\n    chainId,\n    feeToken,\n    gas,\n    keyAuthorization,\n    nonce,\n    nonceKey,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    validBefore,\n    validAfter,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n  const signature = options.signature || envelope.signature\n\n  const authorizationTupleList =\n    AuthorizationTempo.toTupleList(authorizationList)\n\n  // Encode calls as RLP list of [to, value, data] tuples\n  const callsTupleList = calls.map((call) => [\n    call.to ?? '0x',\n    call.value ? Hex.fromNumber(call.value) : '0x',\n    call.data ?? '0x',\n  ])\n\n  const feePayerSignatureOrSender = (() => {\n    if (options.sender) return options.sender\n    const feePayerSignature =\n      typeof options.feePayerSignature !== 'undefined'\n        ? options.feePayerSignature\n        : envelope.feePayerSignature\n    if (feePayerSignature === null) return '0x00'\n    if (!feePayerSignature) return '0x'\n    return Signature.toTuple(feePayerSignature)\n  })()\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    callsTupleList,\n    accessTupleList,\n    nonceKey ? Hex.fromNumber(nonceKey) : '0x',\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    typeof validBefore === 'number' ? Hex.fromNumber(validBefore) : '0x',\n    typeof validAfter === 'number' ? Hex.fromNumber(validAfter) : '0x',\n    typeof feeToken === 'bigint' || typeof feeToken === 'string'\n      ? TokenId.toAddress(feeToken)\n      : '0x',\n    feePayerSignatureOrSender,\n    authorizationTupleList,\n    ...(keyAuthorization ? [KeyAuthorization.toTuple(keyAuthorization)] : []),\n    ...(signature\n      ? [SignatureEnvelope.serialize(SignatureEnvelope.from(signature))]\n      : []),\n  ] as const\n\n  return Hex.concat(\n    options.format === 'feePayer' ? feePayerMagic : serializedType,\n    Rlp.fromHex(serialized),\n  ) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /**\n     * Sender signature to append to the serialized envelope.\n     */\n    signature?: SignatureEnvelope.from.Value | undefined\n  } & OneOf<\n    | {\n        /**\n         * Sender address to cover the fee of.\n         */\n        sender: Address.Address\n        /**\n         * Whether to serialize the transaction in the fee payer format.\n         *\n         * - If `'feePayer'`, then the transaction will be serialized in the fee payer format.\n         * - If `undefined` (default), then the transaction will be serialized in the normal format.\n         */\n        format: 'feePayer'\n      }\n    | {\n        /**\n         * Fee payer signature or the sender to cover the fee of.\n         *\n         * - If `Signature.Signature`, then this is the fee payer signature.\n         * - If `null`, then this indicates the envelope is intended to be signed by a fee payer.\n         */\n        feePayerSignature?: Signature.Signature | null | undefined\n        format?: undefined\n      }\n  >\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Computes the keccak256 hash of the unsigned serialized transaction. Sign this payload\n * with secp256k1, P256, or WebAuthn, then attach the signature via {@link ox#TxEnvelopeTempo.(from:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeTempo,\n): getSignPayload.ReturnValue {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnValue = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { signature })\n *\n * const hash = TxEnvelopeTempo.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Tempo Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeTempo<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnValue {\n  const serialized = serialize({\n    ...envelope,\n    ...(options.presign\n      ? {\n          signature: undefined,\n        }\n      : {}),\n  })\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /**\n     * Whether to hash this transaction for signing.\n     *\n     * @default false\n     */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnValue = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the fee payer payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Fee sponsorship uses a dual-signature scheme: the sender signs the transaction, then a fee payer\n * signs over the transaction with the sender's address to commit to paying fees. The fee payer's\n * signature includes the `feeToken` and `sender_address`, using magic byte `0x78` for domain separation.\n *\n * [Fee Payer Signature](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#fee-payer-signature)\n * [Fee Sponsorship Guide](https://docs.tempo.xyz/protocol/transactions#fee-sponsorship)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getFeePayerSignPayload(envelope, {\n *   sender: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045'\n * }) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the fee payer sign payload for.\n * @param options - Options.\n * @returns The fee payer sign payload.\n */\nexport function getFeePayerSignPayload(\n  envelope: TxEnvelopeTempo,\n  options: getFeePayerSignPayload.Options,\n): getFeePayerSignPayload.ReturnValue {\n  const { sender } = options\n  const serialized = serialize(\n    { ...envelope, signature: undefined },\n    {\n      sender,\n      format: 'feePayer',\n    },\n  )\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace getFeePayerSignPayload {\n  type Options = {\n    /**\n     * Sender address to cover the fee of.\n     */\n    sender: Address.Address\n  }\n\n  type ReturnValue = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const valid = TxEnvelopeTempo.validate({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeTempo, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a transaction's calls list is empty.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [],\n *   chainId: 1,\n * })\n * // @error: TxEnvelopeTempo.CallsEmptyError: Calls list cannot be empty.\n * ```\n */\nexport class CallsEmptyError extends Errors.BaseError {\n  override readonly name = 'TxEnvelopeTempo.CallsEmptyError'\n  constructor() {\n    super('Calls list cannot be empty.')\n  }\n}\n\n/**\n * Thrown when validBefore is not greater than validAfter.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000' }],\n *   chainId: 1,\n *   validBefore: 100,\n *   validAfter: 200,\n * })\n * // @error: TxEnvelopeTempo.InvalidValidityWindowError: validBefore (100) must be greater than validAfter (200).\n * ```\n */\nexport class InvalidValidityWindowError extends Errors.BaseError {\n  override readonly name = 'TxEnvelopeTempo.InvalidValidityWindowError'\n  constructor({\n    validBefore,\n    validAfter,\n  }: {\n    validBefore: number\n    validAfter: number\n  }) {\n    super(\n      `validBefore (${validBefore}) must be greater than validAfter (${validAfter}).`,\n    )\n  }\n}\n", "import * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, Mutable } from './internal/types.js'\n\nexport type AccessList = Compute<readonly Item[]>\n\nexport type Item = Compute<{\n  address: Address.Address\n  storageKeys: readonly Hex.Hex[]\n}>\n\nexport type ItemTuple = Compute<\n  [address: Address.Address, storageKeys: readonly Hex.Hex[]]\n>\n\nexport type Tuple = readonly ItemTuple[]\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nexport function fromTupleList(accessList: Tuple): AccessList {\n  const list: Mutable<AccessList> = []\n  for (let i = 0; i < accessList.length; i++) {\n    const [address, storageKeys] = accessList[i] as [Hex.Hex, Hex.Hex[]]\n\n    if (address) Address.assert(address, { strict: false })\n\n    list.push({\n      address: address,\n      storageKeys: storageKeys.map((key) =>\n        Hash.validate(key) ? key : Hex.trimLeft(key),\n      ),\n    })\n  }\n  return list\n}\n\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nexport function toTupleList(\n  accessList?: AccessList | undefined,\n): Compute<Tuple> {\n  if (!accessList || accessList.length === 0) return []\n\n  const tuple: Mutable<Tuple> = []\n  for (const { address, storageKeys } of accessList) {\n    for (let j = 0; j < storageKeys.length; j++)\n      if (Hex.size(storageKeys[j]!) !== 32)\n        throw new InvalidStorageKeySizeError({\n          storageKey: storageKeys[j]!,\n        })\n\n    if (address) Address.assert(address, { strict: false })\n\n    tuple.push([address, storageKeys])\n  }\n  return tuple\n}\n\n/** Thrown when the size of a storage key is invalid. */\nexport class InvalidStorageKeySizeError extends Errors.BaseError {\n  override readonly name = 'AccessList.InvalidStorageKeySizeError'\n  constructor({ storageKey }: { storageKey: Hex.Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Hex.size(storageKey)} bytes.`,\n    )\n  }\n}\n", "import * as Errors from './Errors.js'\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nexport const exponents = {\n  wei: 0,\n  gwei: 9,\n  szabo: 12,\n  finney: 15,\n  ether: 18,\n} as const\n\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nexport function format(value: bigint, decimals = 0) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nexport function formatEther(\n  wei: bigint,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return format(wei, exponents.ether - exponents[unit])\n}\n\nexport declare namespace formatEther {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return format(wei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace formatGwei {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nexport function from(value: string, decimals = 0) {\n  if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n    throw new InvalidDecimalNumberError({ value })\n\n  let [integer = '', fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromEther(\n  ether: string,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return from(ether, exponents.ether - exponents[unit])\n}\n\nexport declare namespace fromEther {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromGwei(gwei: string, unit: 'wei' = 'wei') {\n  return from(gwei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace fromGwei {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nexport class InvalidDecimalNumberError extends Errors.BaseError {\n  override readonly name = 'Value.InvalidDecimalNumberError'\n  constructor({ value }: { value: string }) {\n    super(`Value \\`${value}\\` is not a valid decimal number.`)\n  }\n}\n", "import type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Value from './Value.js'\n\n/** Base type for a Transaction Envelope. Transaction Envelopes inherit this type. */\nexport type Base<\n  type extends string = string,\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** EIP-155 Chain ID. */\n    chainId: numberType\n    /** Contract code or a hashed method call with encoded args */\n    data?: Hex.Hex | undefined\n    /** @alias `data`  added for TransactionEnvelope - Transaction compatibility. */\n    input?: Hex.Hex | undefined\n    /** Sender of the transaction. */\n    from?: Address.Address | undefined\n    /** Gas provided for transaction execution */\n    gas?: bigintType | undefined\n    /** Unique number identifying this transaction */\n    nonce?: bigintType | undefined\n    /** Transaction recipient */\n    to?: Address.Address | null | undefined\n    /** Transaction type */\n    type: type\n    /** Value in wei sent with this transaction */\n    value?: bigintType | undefined\n    /** ECDSA signature r. */\n    r?: bigintType | undefined\n    /** ECDSA signature s. */\n    s?: bigintType | undefined\n    /** ECDSA signature yParity. */\n    yParity?: numberType | undefined\n    /** @deprecated ECDSA signature v (for backwards compatibility). */\n    v?: numberType | undefined\n  } & (signed extends true ? { r: bigintType; s: bigintType } : {})\n>\n\n/** RPC representation of a {@link ox#(TransactionEnvelope:namespace).Base}. */\nexport type BaseRpc<\n  type extends string = string,\n  signed extends boolean = boolean,\n> = Base<type, signed, Hex.Hex, Hex.Hex>\n\n/** Signed representation of a {@link ox#(TransactionEnvelope:namespace).Base}. */\nexport type BaseSigned<type extends string = string> = Base<type, true>\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class FeeCapTooHighError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.FeeCapTooHighError'\n  constructor({\n    feeCap,\n  }: {\n    feeCap?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${\n        feeCap ? ` = ${Value.formatGwei(feeCap)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n    )\n  }\n}\n\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class GasPriceTooHighError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.GasPriceTooHighError'\n  constructor({\n    gasPrice,\n  }: {\n    gasPrice?: bigint | undefined\n  } = {}) {\n    super(\n      `The gas price (\\`gasPrice\\`${\n        gasPrice ? ` = ${Value.formatGwei(gasPrice)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n    )\n  }\n}\n\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nexport class InvalidChainIdError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.InvalidChainIdError'\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId !== 'undefined'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n    )\n  }\n}\n\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nexport class InvalidSerializedError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.InvalidSerializedError'\n  constructor({\n    attributes,\n    serialized,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serialized: Hex.Hex\n    type: string\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serialized}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n  }\n}\n\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nexport class TipAboveFeeCapError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.TipAboveFeeCapError'\n  constructor({\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${Value.formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${Value.formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n    )\n  }\n}\n", "// TODO: Find opportunities to make this file less duplicated + more simplified with Viem v3.\n\nimport type { Address } from 'abitype'\nimport * as Hex from 'ox/Hex'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport {\n  type AuthorizationTempo,\n  type KeyAuthorization,\n  type TransactionReceipt as ox_TransactionReceipt,\n  SignatureEnvelope,\n  TxEnvelopeTempo as TxTempo,\n} from 'ox/tempo'\nimport type { Account } from '../accounts/types.js'\nimport type { FeeValuesEIP1559 } from '../types/fee.js'\nimport type { Signature as viem_Signature } from '../types/misc.js'\nimport type {\n  RpcTransaction as viem_RpcTransaction,\n  RpcTransactionRequest as viem_RpcTransactionRequest,\n} from '../types/rpc.js'\nimport type {\n  AccessList,\n  TransactionBase,\n  TransactionRequestBase,\n  TransactionSerializableBase,\n  TransactionSerializedGeneric,\n  Transaction as viem_Transaction,\n  TransactionReceipt as viem_TransactionReceipt,\n  TransactionRequest as viem_TransactionRequest,\n  TransactionSerializable as viem_TransactionSerializable,\n  TransactionSerialized as viem_TransactionSerialized,\n  TransactionType as viem_TransactionType,\n} from '../types/transaction.js'\nimport type { ExactPartial, OneOf, PartialBy } from '../types/utils.js'\nimport { getTransactionType as viem_getTransactionType } from '../utils/transaction/getTransactionType.js'\nimport {\n  type ParseTransactionReturnType,\n  parseTransaction as viem_parseTransaction,\n} from '../utils/transaction/parseTransaction.js'\nimport { serializeTransaction as viem_serializeTransaction } from '../utils/transaction/serializeTransaction.js'\n\nexport type Transaction<\n  bigintType = bigint,\n  numberType = number,\n  pending extends boolean = false,\n> = OneOf<\n  | viem_Transaction<bigintType, numberType, pending>\n  | TransactionTempo<bigintType, numberType, pending>\n>\nexport type TransactionRpc<pending extends boolean = false> = OneOf<\n  | viem_RpcTransaction<pending>\n  | (Omit<\n      TransactionTempo<Hex.Hex, Hex.Hex, pending, '0x76'>,\n      'authorizationList' | 'keyAuthorization' | 'signature'\n    > & {\n      authorizationList?: AuthorizationTempo.ListRpc | undefined\n      keyAuthorization?: KeyAuthorization.Rpc | null | undefined\n      signature: SignatureEnvelope.SignatureEnvelopeRpc\n    })\n>\n\nexport type TransactionTempo<\n  quantity = bigint,\n  index = number,\n  isPending extends boolean = boolean,\n  type = 'tempo',\n> = PartialBy<\n  Omit<TransactionBase<quantity, index, isPending>, 'input' | 'value' | 'to'>,\n  'r' | 's' | 'v' | 'yParity'\n> & {\n  accessList: AccessList\n  authorizationList?: AuthorizationTempo.ListSigned<quantity, index> | undefined\n  calls: readonly TxTempo.Call<quantity>[]\n  chainId: index\n  feeToken?: Address | undefined\n  feePayerSignature?: viem_Signature | undefined\n  keyAuthorization?: KeyAuthorization.Signed<quantity, index> | null | undefined\n  nonceKey?: quantity | undefined\n  signature: SignatureEnvelope.SignatureEnvelope\n  type: type\n  validBefore?: index | undefined\n  validAfter?: index | undefined\n} & FeeValuesEIP1559<quantity>\n\nexport type TransactionRequest<\n  bigintType = bigint,\n  numberType = number,\n> = OneOf<\n  | viem_TransactionRequest<bigintType, numberType>\n  | TransactionRequestTempo<bigintType, numberType>\n>\nexport type TransactionRequestRpc = OneOf<\n  viem_RpcTransactionRequest | TransactionRequestTempo<Hex.Hex, Hex.Hex, '0x76'>\n>\n\nexport type TransactionReceipt<\n  quantity = bigint,\n  index = number,\n  status = 'success' | 'reverted',\n  type = TransactionType,\n> = viem_TransactionReceipt<quantity, index, status, type> & {\n  feePayer?: Address | undefined\n  feeToken?: Address | undefined\n}\n\nexport type TransactionReceiptRpc = TransactionReceipt<\n  Hex.Hex,\n  Hex.Hex,\n  ox_TransactionReceipt.RpcStatus,\n  ox_TransactionReceipt.RpcType\n>\n\nexport type TransactionRequestTempo<\n  quantity = bigint,\n  index = number,\n  type = 'tempo',\n> = TransactionRequestBase<quantity, index, type> &\n  ExactPartial<FeeValuesEIP1559<quantity>> & {\n    accessList?: AccessList | undefined\n    keyAuthorization?: KeyAuthorization.Signed<quantity, index> | undefined\n    calls?: readonly TxTempo.Call<quantity>[] | undefined\n    feePayer?: Account | true | undefined\n    feeToken?: Address | bigint | undefined\n    nonceKey?: 'random' | quantity | undefined\n    validBefore?: index | undefined\n    validAfter?: index | undefined\n  }\n\nexport type TransactionSerializable = OneOf<\n  viem_TransactionSerializable | TransactionSerializableTempo\n>\n\nexport type TransactionSerializableTempo<\n  quantity = bigint,\n  index = number,\n> = TransactionSerializableBase<quantity, index> &\n  ExactPartial<FeeValuesEIP1559<quantity>> & {\n    accessList?: AccessList | undefined\n    calls: readonly TxTempo.Call<quantity>[]\n    chainId: number\n    feeToken?: Address | bigint | undefined\n    feePayerSignature?: viem_Signature | null | undefined\n    keyAuthorization?: KeyAuthorization.Signed<quantity, index> | undefined\n    nonceKey?: quantity | undefined\n    signature?: SignatureEnvelope.SignatureEnvelope<quantity, index> | undefined\n    validBefore?: index | undefined\n    validAfter?: index | undefined\n    type?: 'tempo' | undefined\n  }\n\nexport type TransactionSerialized<\n  type extends TransactionType = TransactionType,\n> = viem_TransactionSerialized<type> | TransactionSerializedTempo\n\nexport type TransactionSerializedTempo = `0x76${string}`\n\nexport type TransactionType = viem_TransactionType | 'tempo'\n\nexport function getType(\n  transaction: Record<string, unknown>,\n): Transaction['type'] {\n  const account = transaction.account as\n    | { keyType?: string | undefined }\n    | undefined\n  if (\n    (account?.keyType && account.keyType !== 'secp256k1') ||\n    typeof transaction.calls !== 'undefined' ||\n    typeof transaction.feePayer !== 'undefined' ||\n    typeof transaction.feeToken !== 'undefined' ||\n    typeof transaction.keyAuthorization !== 'undefined' ||\n    typeof transaction.nonceKey !== 'undefined' ||\n    typeof transaction.signature !== 'undefined' ||\n    typeof transaction.validBefore !== 'undefined' ||\n    typeof transaction.validAfter !== 'undefined'\n  )\n    return 'tempo' as never\n  if (transaction.type) return transaction.type as never\n  return viem_getTransactionType(transaction) as never\n}\n\nexport function isTempo(transaction: Record<string, unknown>) {\n  try {\n    const type = getType(transaction)\n    return type === 'tempo'\n  } catch {\n    return false\n  }\n}\n\nexport function deserialize<\n  const serialized extends TransactionSerializedGeneric,\n>(serializedTransaction: serialized): deserialize.ReturnValue<serialized> {\n  const type = Hex.slice(serializedTransaction, 0, 1)\n  if (type === '0x76') {\n    const from =\n      Hex.slice(serializedTransaction, -6) === '0xfeefeefeefee'\n        ? Hex.slice(serializedTransaction, -26, -6)\n        : undefined\n    return {\n      ...deserializeTempo(serializedTransaction as `0x76${string}`),\n      from,\n    } as never\n  }\n  return viem_parseTransaction(serializedTransaction) as never\n}\n\nexport declare namespace deserialize {\n  export type ReturnValue<\n    serialized extends\n      TransactionSerializedGeneric = TransactionSerializedGeneric,\n  > = serialized extends TransactionSerializedTempo\n    ? TransactionSerializableTempo\n    : ParseTransactionReturnType<serialized>\n}\n\nexport async function serialize(\n  transaction: TransactionSerializable & {\n    feePayer?: Account | true | undefined\n    from?: Address | undefined\n  },\n  signature?:\n    | OneOf<SignatureEnvelope.SignatureEnvelope | viem_Signature>\n    | undefined,\n) {\n  // If the transaction is not a Tempo transaction, route to Viem serializer.\n  if (!isTempo(transaction)) {\n    if (signature && 'type' in signature && signature.type !== 'secp256k1')\n      throw new Error(\n        'Unsupported signature type. Expected `secp256k1` but got `' +\n          signature.type +\n          '`.',\n      )\n    if (signature && 'type' in signature) {\n      const { r, s, yParity } = signature?.signature!\n      return viem_serializeTransaction(transaction as never, {\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity,\n      })\n    }\n    return viem_serializeTransaction(transaction as never, signature)\n  }\n\n  const type = getType(transaction)\n  if (type === 'tempo')\n    return serializeTempo(\n      transaction as TransactionSerializableTempo,\n      signature,\n    )\n\n  throw new Error('Unsupported transaction type')\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// Internal\n\n/** @internal */\nfunction deserializeTempo(\n  serializedTransaction: TransactionSerializedTempo,\n): TransactionSerializableTempo {\n  const { feePayerSignature, nonce, ...tx } = TxTempo.deserialize(\n    serializedTransaction,\n  )\n  return {\n    ...tx,\n    nonce: Number(nonce ?? 0n),\n    feePayerSignature: feePayerSignature\n      ? {\n          r: Hex.fromNumber(feePayerSignature.r, { size: 32 }),\n          s: Hex.fromNumber(feePayerSignature.s, { size: 32 }),\n          yParity: feePayerSignature.yParity,\n        }\n      : feePayerSignature,\n  } satisfies TransactionSerializableTempo\n}\n\n/** @internal */\nasync function serializeTempo(\n  transaction: TransactionSerializableTempo & {\n    feePayer?: Account | true | undefined\n    from?: Address | undefined\n  },\n  sig?: OneOf<SignatureEnvelope.SignatureEnvelope | viem_Signature> | undefined,\n) {\n  const signature = (() => {\n    if (transaction.signature) return transaction.signature\n    if (sig && 'type' in sig) return sig as SignatureEnvelope.SignatureEnvelope\n    if (sig)\n      return SignatureEnvelope.from({\n        r: BigInt(sig.r!),\n        s: BigInt(sig.s!),\n        yParity: Number(sig.yParity!),\n      })\n    return undefined\n  })()\n\n  const { chainId, feePayer, feePayerSignature, nonce, ...rest } = transaction\n\n  const transaction_ox = {\n    ...rest,\n    calls: rest.calls?.length\n      ? rest.calls\n      : [\n          {\n            to:\n              rest.to ||\n              (!rest.data || rest.data === '0x'\n                ? '0x0000000000000000000000000000000000000000'\n                : undefined),\n            value: rest.value,\n            data: rest.data,\n          },\n        ],\n    chainId: Number(chainId),\n    feePayerSignature: feePayerSignature\n      ? {\n          r: BigInt(feePayerSignature.r!),\n          s: BigInt(feePayerSignature.s!),\n          yParity: Number(feePayerSignature.yParity),\n        }\n      : feePayer\n        ? null\n        : undefined,\n    type: 'tempo',\n    ...(nonce ? { nonce: BigInt(nonce) } : {}),\n  } satisfies TxTempo.TxEnvelopeTempo\n\n  // If we have marked the transaction as intended to be paid\n  // by a fee payer (feePayer: true), we will not use the fee token\n  // as the fee payer will choose their fee token.\n  if (feePayer === true) delete transaction_ox.feeToken\n\n  if (signature && typeof transaction.feePayer === 'object') {\n    const tx = TxTempo.from(transaction_ox, {\n      signature,\n    })\n\n    const sender = (() => {\n      if (transaction.from) return transaction.from\n      if (signature.type === 'secp256k1')\n        return Secp256k1.recoverAddress({\n          payload: TxTempo.getSignPayload(tx),\n          signature: signature.signature,\n        })\n      throw new Error('Unable to extract sender from transaction or signature.')\n    })()\n\n    const hash = TxTempo.getFeePayerSignPayload(tx, {\n      sender,\n    })\n\n    const feePayerSignature = await transaction.feePayer.sign!({\n      hash,\n    })\n\n    return TxTempo.serialize(tx, {\n      feePayerSignature: Signature.from(feePayerSignature),\n    })\n  }\n\n  if (feePayer === true) {\n    const serialized = TxTempo.serialize(transaction_ox, {\n      feePayerSignature: null,\n      signature,\n    })\n    // if the transaction is ready to be sent off (signed), add the sender\n    // and a fee marker to the serialized transaction, so the fee payer proxy\n    // can infer the sender address.\n    if (transaction.from && signature)\n      return Hex.concat(serialized, transaction.from, '0xfeefeefeefee')\n    return serialized\n  }\n\n  return TxTempo.serialize(\n    // If we have specified a fee payer, the user will not be signing over the fee token.\n    // Defer the fee token signing to the fee payer.\n    { ...transaction_ox, ...(feePayer ? { feeToken: undefined } : {}) },\n    {\n      feePayerSignature: undefined,\n      signature,\n    },\n  )\n}\n\n// Export types required for inference.\n// biome-ignore lint/performance/noBarrelFile: _\nexport {\n  /** @deprecated */\n  KeyAuthorization as z_KeyAuthorization,\n  /** @deprecated */\n  SignatureEnvelope as z_SignatureEnvelope,\n  /** @deprecated */\n  TxEnvelopeTempo as z_TxEnvelopeTempo,\n} from 'ox/tempo'\n", "// TODO: Find opportunities to make this file less duplicated + more simplified with Viem v3.\n\nimport type { Address } from 'abitype'\nimport * as Hex from 'ox/Hex'\nimport {\n  Transaction as ox_Transaction,\n  TransactionRequest as ox_TransactionRequest,\n} from 'ox/tempo'\nimport type { Account as viem_Account } from '../accounts/types.js'\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport { formatTransaction as viem_formatTransaction } from '../utils/formatters/transaction.js'\nimport { formatTransactionReceipt as viem_formatTransactionReceipt } from '../utils/formatters/transactionReceipt.js'\nimport { formatTransactionRequest as viem_formatTransactionRequest } from '../utils/formatters/transactionRequest.js'\nimport type { Account } from './Account.js'\nimport {\n  isTempo,\n  type Transaction,\n  type TransactionReceipt,\n  type TransactionReceiptRpc,\n  type TransactionRequest,\n  type TransactionRequestRpc,\n  type TransactionRpc,\n} from './Transaction.js'\n\nexport function formatTransaction(\n  transaction: TransactionRpc,\n): Transaction<bigint, number, boolean> {\n  if (!isTempo(transaction)) return viem_formatTransaction(transaction as never)\n\n  const {\n    feePayerSignature,\n    gasPrice: _,\n    nonce,\n    ...tx\n  } = ox_Transaction.fromRpc(transaction as never) as ox_Transaction.Tempo\n\n  return {\n    ...tx,\n    accessList: tx.accessList!,\n    feePayerSignature: feePayerSignature\n      ? {\n          r: Hex.fromNumber(feePayerSignature.r, { size: 32 }),\n          s: Hex.fromNumber(feePayerSignature.s, { size: 32 }),\n          v: BigInt(feePayerSignature.v ?? 27),\n          yParity: feePayerSignature.yParity,\n        }\n      : undefined,\n    nonce: Number(nonce),\n    typeHex:\n      ox_Transaction.toRpcType[\n        tx.type as keyof typeof ox_Transaction.toRpcType\n      ],\n    type: tx.type as 'tempo',\n  }\n}\n\nexport function formatTransactionReceipt(\n  receipt: TransactionReceiptRpc,\n): TransactionReceipt {\n  return viem_formatTransactionReceipt(receipt as never)\n}\n\nexport function formatTransactionRequest(\n  r: TransactionRequest,\n  action?: string | undefined,\n): TransactionRequestRpc {\n  const request = r as TransactionRequest & {\n    account?: viem_Account | Address | undefined\n  }\n  const account = request.account\n    ? parseAccount<Account | viem_Account | Address>(request.account)\n    : undefined\n\n  // If the request is not a Tempo transaction, route to Viem formatter.\n  if (!isTempo(request))\n    return viem_formatTransactionRequest(\n      r as never,\n      action,\n    ) as TransactionRequestRpc\n\n  if (action)\n    request.calls = request.calls ?? [\n      {\n        to:\n          r.to ||\n          (!r.data || r.data === '0x'\n            ? '0x0000000000000000000000000000000000000000'\n            : undefined),\n        value: r.value,\n        data: r.data,\n      },\n    ]\n\n  // If we have marked the transaction as intended to be paid\n  // by a fee payer (feePayer: true), we will not use the fee token\n  // as the fee payer will choose their fee token.\n  if (request.feePayer === true) delete request.feeToken\n\n  const rpc = ox_TransactionRequest.toRpc({\n    ...request,\n    type: 'tempo',\n  } as never)\n\n  if (action === 'estimateGas') {\n    rpc.maxFeePerGas = undefined\n    rpc.maxPriorityFeePerGas = undefined\n  }\n\n  rpc.to = undefined\n  rpc.data = undefined\n  rpc.value = undefined\n\n  const [keyType, keyData] = (() => {\n    const type =\n      account && 'keyType' in account ? account.keyType : account?.source\n    if (!type) return [undefined, undefined]\n    if (type === 'webAuthn')\n      // TODO: derive correct bytes size of key data based on webauthn create metadata.\n      return ['webAuthn', `0x${'ff'.repeat(1400)}`]\n    if (['p256', 'secp256k1'].includes(type)) return [type, undefined]\n    return [undefined, undefined]\n  })()\n\n  const keyId =\n    account && 'accessKeyAddress' in account\n      ? account.accessKeyAddress\n      : undefined\n\n  return {\n    ...rpc,\n    ...(keyData ? { keyData } : {}),\n    ...(keyId ? { keyId } : {}),\n    ...(keyType ? { keyType } : {}),\n    ...(request.feePayer\n      ? {\n          feePayer:\n            typeof request.feePayer === 'object'\n              ? parseAccount(request.feePayer)\n              : request.feePayer,\n        }\n      : {}),\n  } as never\n}\n"],
  "mappings": "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",
  "names": ["from", "from", "concat", "hash", "from", "fromRpc", "fromRpcList", "fromTuple", "getSignPayload", "toRpc", "toRpcList", "toTuple", "assert", "from", "fromRpc", "toRpc", "validate", "verify", "p256", "secp256r1", "secp256r1", "from", "secp256r1", "extraEntropy", "hash", "secp256r1", "verify", "fromBytes", "fromHex", "size", "p256", "from", "sha256", "fromString", "concat", "fromHex", "sign", "verify", "hash", "type", "assert", "type", "p256", "size", "fromHex", "from", "fromRpc", "concat", "toHex", "fromString", "toRpc", "validate", "verify", "from", "fromRpc", "fromRpcList", "fromTuple", "getSignPayload", "concat", "fromHex", "toTuple", "toRpc", "toRpcList", "from", "fromRpc", "fromTuple", "getSignPayload", "hash", "toRpc", "toTuple", "from", "fromRpc", "fromTuple", "getSignPayload", "hash", "toTuple", "fromHex", "toRpc", "type", "from", "from", "concat", "serialize", "serialize", "fromString", "fromRpc", "fromRpcType", "toRpc", "toRpcType", "fromRpc", "toRpc", "toRpcType", "fromRpcType", "fromRpc", "fromRpcList", "toRpc", "toRpcList", "fromRpc", "fromRpcType", "toRpc", "toRpcType", "fromRpc", "toRpc", "fromRpcType", "toRpcType", "fromRpc", "toRpc", "fromRpcType", "toRpcType", "fromRpc", "toRpc", "toRpc", "toRpc", "toRpc", "toRpcList", "toRpcType", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "validate", "fromTupleList", "validate", "toTupleList", "InvalidSerializedError", "type", "assert", "deserialize", "toHex", "InvalidSerializedError", "fromTupleList", "validate", "fromTuple", "from", "serialize", "toTupleList", "toTuple", "concat", "fromHex", "getSignPayload", "hash", "Transaction_exports", "deserialize", "getType", "serialize", "getType", "type", "deserialize", "from", "serialize", "hash", "feePayerSignature", "concat", "formatTransaction", "formatTransactionReceipt", "formatTransactionRequest", "formatTransaction", "formatTransactionReceipt", "formatTransactionRequest", "type"]
}
