import {
  assert,
  assert2,
  encode,
  extraEntropy,
  extract,
  formatTransaction,
  formatTransactionReceipt,
  from as from2,
  from2 as from3,
  from3 as from4,
  fromHex2,
  fromHex3,
  fromPublicKey,
  fromRpc,
  fromRpcList,
  fromTuple,
  getTransactionType,
  isEqual,
  keccak256,
  parseTransaction,
  recoverAddress2 as recoverAddress,
  serializeTransaction,
  sha2562,
  toHex,
  toHex2,
  toHex3,
  toRpc,
  toRpcList,
  toTuple,
  validate as validate2,
  validate2 as validate3,
  verify,
  yParityToV
} from "./chunk-XO67QMZH.js";
import {
  BaseError2 as BaseError,
  concat2 as concat,
  concat3 as concat2,
  formatTransactionRequest,
  from2 as from,
  fromBytes2 as fromBytes,
  fromHex2 as fromHex,
  fromNumber,
  fromString,
  fromString2,
  padLeft,
  parseAccount,
  random,
  size3 as size,
  slice3 as slice,
  stringify2 as stringify,
  toBigInt2 as toBigInt,
  toNumber2 as toNumber,
  toString2 as toString,
  trimLeft2 as trimLeft,
  validate2 as validate
} from "./chunk-CLTBMHAB.js";
import {
  Field,
  createCurve,
  createHasher,
  mapToCurveSimpleSWU,
  sha256,
  sha384,
  sha512
} from "./chunk-NFNOCDIA.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/ox/_esm/tempo/TokenId.js
var TokenId_exports = {};
__export(TokenId_exports, {
  compute: () => compute,
  from: () => from5,
  fromAddress: () => fromAddress,
  toAddress: () => toAddress
});
var tip20Prefix = "0x20c0";
function from5(tokenIdOrAddress) {
  if (typeof tokenIdOrAddress === "bigint" || typeof tokenIdOrAddress === "number")
    return BigInt(tokenIdOrAddress);
  return fromAddress(tokenIdOrAddress);
}
function fromAddress(address) {
  if (!address.toLowerCase().startsWith(tip20Prefix))
    throw new Error("invalid tip20 address.");
  return toBigInt(slice(address, tip20Prefix.length));
}
function toAddress(tokenId) {
  if (typeof tokenId === "string") {
    assert(tokenId);
    return tokenId;
  }
  const tokenIdHex = fromNumber(tokenId, { size: 18 });
  return concat2(tip20Prefix, tokenIdHex);
}
function compute(value) {
  const hash4 = keccak256(encode(from3("address, bytes32"), [
    value.sender,
    value.salt
  ]));
  return toBigInt(slice(hash4, 0, 8));
}

// node_modules/ox/_esm/tempo/Tick.js
var Tick_exports = {};
__export(Tick_exports, {
  InvalidPriceFormatError: () => InvalidPriceFormatError,
  PriceOutOfBoundsError: () => PriceOutOfBoundsError,
  TickOutOfBoundsError: () => TickOutOfBoundsError,
  fromPrice: () => fromPrice,
  maxTick: () => maxTick,
  minTick: () => minTick,
  priceScale: () => priceScale,
  toPrice: () => toPrice
});
var minTick = -2e3;
var maxTick = 2e3;
var priceScale = 1e5;
function toPrice(tick) {
  if (tick < minTick || tick > maxTick) {
    throw new TickOutOfBoundsError({ tick });
  }
  const price = priceScale + tick;
  const whole = Math.floor(price / priceScale);
  let decimal = (price % priceScale).toString().padStart(5, "0");
  decimal = decimal.replace(/0+$/, "");
  if (decimal.length === 0)
    return whole.toString();
  return `${whole}.${decimal}`;
}
function fromPrice(price) {
  const priceStr = price.trim();
  if (!/^-?\d+(\.\d+)?$/.test(priceStr))
    throw new InvalidPriceFormatError({ price });
  const [w, d = "0"] = priceStr.split(".");
  const whole = BigInt(w);
  const decimal = BigInt(d.padEnd(5, "0").slice(0, 5));
  const priceInt = whole * BigInt(priceScale) + decimal;
  const tick = Number(priceInt - BigInt(priceScale));
  if (tick < minTick || tick > maxTick)
    throw new PriceOutOfBoundsError({ price, tick });
  return tick;
}
var TickOutOfBoundsError = class extends BaseError {
  constructor(options) {
    super(`Tick ${options.tick} is out of bounds.`, {
      metaMessages: [`Tick must be between ${minTick} and ${maxTick}.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Tick.TickOutOfBoundsError"
    });
  }
};
var InvalidPriceFormatError = class extends BaseError {
  constructor(options) {
    super(`Invalid price format: "${options.price}".`, {
      metaMessages: ['Price must be a decimal number string (e.g., "1.001").']
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Tick.InvalidPriceFormatError"
    });
  }
};
var PriceOutOfBoundsError = class extends BaseError {
  constructor(options) {
    super(`Price "${options.price}" results in tick ${options.tick} which is out of bounds.`, {
      metaMessages: [`Tick must be between ${minTick} and ${maxTick}.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Tick.PriceOutOfBoundsError"
    });
  }
};

// node_modules/ox/_esm/tempo/AuthorizationTempo.js
var AuthorizationTempo_exports = {};
__export(AuthorizationTempo_exports, {
  from: () => from7,
  fromRpc: () => fromRpc3,
  fromRpcList: () => fromRpcList2,
  fromTuple: () => fromTuple2,
  fromTupleList: () => fromTupleList,
  getSignPayload: () => getSignPayload2,
  hash: () => hash,
  toRpc: () => toRpc3,
  toRpcList: () => toRpcList2,
  toTuple: () => toTuple2,
  toTupleList: () => toTupleList
});

// node_modules/ox/_esm/tempo/SignatureEnvelope.js
var SignatureEnvelope_exports = {};
__export(SignatureEnvelope_exports, {
  CoercionError: () => CoercionError,
  InvalidSerializedError: () => InvalidSerializedError,
  MissingPropertiesError: () => MissingPropertiesError,
  VerificationError: () => VerificationError,
  assert: () => assert3,
  deserialize: () => deserialize,
  from: () => from6,
  fromRpc: () => fromRpc2,
  getType: () => getType,
  magicBytes: () => magicBytes,
  serialize: () => serialize,
  toRpc: () => toRpc2,
  types: () => types,
  validate: () => validate4,
  verify: () => verify4
});

// node_modules/@noble/curves/esm/nist.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var p256_a = Fp256.create(BigInt("-3"));
var p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: p256_a,
  b: p256_b,
  Fp: Fp256,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var p256_mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: p256_a,
  B: p256_b,
  Z: Fp256.create(BigInt("-10"))
}))();
var p256_hasher = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
var p384_a = Fp384.create(BigInt("-3"));
var p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
var p384 = createCurve({
  a: p384_a,
  b: p384_b,
  Fp: Fp384,
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
  h: BigInt(1),
  lowS: false
}, sha384);
var secp384r1 = p384;
var p384_mapSWU = (() => mapToCurveSimpleSWU(Fp384, {
  A: p384_a,
  B: p384_b,
  Z: Fp384.create(BigInt("-12"))
}))();
var p384_hasher = (() => createHasher(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {
  DST: "P384_XMD:SHA-384_SSWU_RO_",
  encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
  p: Fp384.ORDER,
  m: 1,
  k: 192,
  expand: "xmd",
  hash: sha384
}))();
var Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
var p521_a = Fp521.create(BigInt("-3"));
var p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
var p521 = createCurve({
  a: p521_a,
  b: p521_b,
  Fp: Fp521,
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
  h: BigInt(1),
  lowS: false,
  allowedPrivateKeyLengths: [130, 131, 132]
  // P521 keys are variable-length. Normalize to 132b
}, sha512);
var secp521r1 = p521;
var p521_mapSWU = (() => mapToCurveSimpleSWU(Fp521, {
  A: p521_a,
  B: p521_b,
  Z: Fp521.create(BigInt("-4"))
}))();
var p521_hasher = (() => createHasher(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {
  DST: "P521_XMD:SHA-512_SSWU_RO_",
  encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
  p: Fp521.ORDER,
  m: 1,
  k: 256,
  expand: "xmd",
  hash: sha512
}))();

// node_modules/@noble/curves/esm/p256.js
var p2562 = p256;
var secp256r12 = p256;
var hashToCurve = (() => p256_hasher.hashToCurve)();
var encodeToCurve = (() => p256_hasher.encodeToCurve)();

// node_modules/ox/_esm/core/P256.js
function getPublicKey(options) {
  const { privateKey } = options;
  const point = secp256r12.ProjectivePoint.fromPrivateKey(typeof privateKey === "string" ? privateKey.slice(2) : fromBytes(privateKey).slice(2));
  return from2(point);
}
function randomPrivateKey(options = {}) {
  const { as = "Hex" } = options;
  const bytes = secp256r12.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash: hash4, payload, privateKey } = options;
  const { r, s, recovery } = secp256r12.sign(payload instanceof Uint8Array ? payload : fromHex(payload), privateKey instanceof Uint8Array ? privateKey : fromHex(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from(extraEntropy2).slice(2),
    lowS: true,
    ...hash4 ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}
function verify2(options) {
  const { hash: hash4, payload, publicKey, signature } = options;
  return secp256r12.verify(signature, payload instanceof Uint8Array ? payload : fromHex(payload), toHex(publicKey).substring(2), ...hash4 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/Base64.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [i, a.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [a.charCodeAt(0), i])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function fromBytes2(value, options = {}) {
  const { pad = true, url = false } = options;
  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);
  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {
    const y = (value[j] << 16) + (value[j + 1] << 8) + (value[j + 2] | 0);
    encoded[i] = integerToCharacter[y >> 18];
    encoded[i + 1] = integerToCharacter[y >> 12 & 63];
    encoded[i + 2] = integerToCharacter[y >> 6 & 63];
    encoded[i + 3] = integerToCharacter[y & 63];
  }
  const k = value.length % 3;
  const end = Math.floor(value.length / 3) * 4 + (k && k + 1);
  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));
  if (pad && k === 1)
    base64 += "==";
  if (pad && k === 2)
    base64 += "=";
  if (url)
    base64 = base64.replaceAll("+", "-").replaceAll("/", "_");
  return base64;
}
function fromHex4(value, options = {}) {
  return fromBytes2(fromHex(value), options);
}
function toBytes(value) {
  const base64 = value.replace(/=+$/, "");
  const size2 = base64.length;
  const decoded = new Uint8Array(size2 + 3);
  encoder.encodeInto(base64 + "===", decoded);
  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {
    const x = (characterToInteger[decoded[i]] << 18) + (characterToInteger[decoded[i + 1]] << 12) + (characterToInteger[decoded[i + 2]] << 6) + characterToInteger[decoded[i + 3]];
    decoded[j] = x >> 16;
    decoded[j + 1] = x >> 8 & 255;
    decoded[j + 2] = x & 255;
  }
  const decodedSize = (size2 >> 2) * 3 + (size2 % 4 && size2 % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}

// node_modules/ox/_esm/core/internal/webauthn.js
function parseAsn1Signature(bytes) {
  const r_start = bytes[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r = BigInt(fromBytes(bytes.slice(r_start, r_end)));
  const s = BigInt(fromBytes(bytes.slice(s_start)));
  return {
    r,
    s: s > p2562.CURVE.n / 2n ? p2562.CURVE.n - s : s
  };
}
async function parseCredentialPublicKey(response) {
  try {
    const publicKeyBuffer = response.getPublicKey();
    if (!publicKeyBuffer)
      throw new CredentialCreationFailedError();
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from2(publicKey);
  } catch (error) {
    if (error.message !== "Permission denied to access object")
      throw error;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = (key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i = 0; i < data.length - coordinate.length; i++)
        if (coordinate.every((byte, j) => data[i + j] === byte))
          return i + coordinate.length;
      throw new CredentialCreationFailedError();
    };
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from2(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
async function createCredential(options) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error) {
    throw new CredentialCreationFailedError({
      cause: error
    });
  }
}
function getAuthenticatorData(options = {}) {
  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;
  const rpIdHash = sha2562(fromString2(rpId));
  const flag_bytes = fromNumber(flag, { size: 1 });
  const signCount_bytes = fromNumber(signCount, { size: 4 });
  return concat2(rpIdHash, flag_bytes, signCount_bytes);
}
function getClientDataJSON(options) {
  const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin } = options;
  return JSON.stringify({
    type: "webauthn.get",
    challenge: fromHex4(challenge, { url: true, pad: false }),
    origin,
    crossOrigin,
    ...extraClientData
  });
}
function getCredentialCreationOptions(options) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge = createChallenge, excludeCredentialIds, extensions, name: name_, rp = {
    id: window.location.hostname,
    name: window.document.title
  }, user } = options;
  const name = (user == null ? void 0 : user.name) ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge: typeof challenge === "string" ? fromHex(challenge) : challenge,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds == null ? void 0 : excludeCredentialIds.map((id) => ({
          id: toBytes(id),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      ...extensions && { extensions },
      rp,
      user: {
        id: (user == null ? void 0 : user.id) ?? keccak256(fromString(name), { as: "Bytes" }),
        name,
        displayName: (user == null ? void 0 : user.displayName) ?? name
      }
    }
  };
}
function getCredentialRequestOptions(options) {
  const { credentialId, challenge, extensions, rpId = window.location.hostname, userVerification = "required" } = options;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: Array.isArray(credentialId) ? credentialId.map((id) => ({
          id: toBytes(id),
          type: "public-key"
        })) : [
          {
            id: toBytes(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex(challenge),
      ...extensions && { extensions },
      rpId,
      userVerification
    }
  };
}
function getSignPayload(options) {
  const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = "required" } = options;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge,
    crossOrigin,
    extraClientData,
    origin
  });
  const clientDataJSONHash = sha2562(fromString2(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat2(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
async function sign2(options) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error) {
    throw new CredentialRequestFailedError({
      cause: error
    });
  }
}
function verify3(options) {
  const { challenge, hash: hash4 = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  if (typeIndex !== void 0) {
    const type2 = '"type":"webauthn.get"';
    if (type2 !== clientDataJSON.slice(Number(typeIndex), type2.length + 1))
      return false;
  }
  const challengeMatch = challengeIndex !== void 0 ? clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/) : clientDataJSON.match(/"challenge":"(.*?)"/);
  if (!challengeMatch)
    return false;
  const [_, challenge_extracted] = challengeMatch;
  if (fromBytes(toBytes(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2562(fromString(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat(authenticatorDataBytes, clientDataJSONHash);
  return verify2({
    hash: hash4,
    payload,
    publicKey,
    signature
  });
}
var CredentialCreationFailedError = class extends BaseError {
  constructor({ cause } = {}) {
    super("Failed to create credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialCreationFailedError"
    });
  }
};
var CredentialRequestFailedError = class extends BaseError {
  constructor({ cause } = {}) {
    super("Failed to request credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialRequestFailedError"
    });
  }
};

// node_modules/ox/_esm/tempo/SignatureEnvelope.js
var serializedP256Type = "0x01";
var serializedWebAuthnType = "0x02";
var serializedKeychainType = "0x03";
var magicBytes = "0x7777777777777777777777777777777777777777777777777777777777777777";
var types = ["secp256k1", "p256", "webAuthn"];
function assert3(envelope) {
  var _a, _b, _c, _d;
  const type2 = getType(envelope);
  if (type2 === "secp256k1") {
    const secp256k1 = envelope;
    assert2(secp256k1.signature);
    return;
  }
  if (type2 === "p256") {
    const p2563 = envelope;
    const missing = [];
    if (typeof ((_a = p2563.signature) == null ? void 0 : _a.r) !== "bigint")
      missing.push("signature.r");
    if (typeof ((_b = p2563.signature) == null ? void 0 : _b.s) !== "bigint")
      missing.push("signature.s");
    if (typeof p2563.prehash !== "boolean")
      missing.push("prehash");
    if (!p2563.publicKey)
      missing.push("publicKey");
    else {
      if (typeof p2563.publicKey.x !== "bigint")
        missing.push("publicKey.x");
      if (typeof p2563.publicKey.y !== "bigint")
        missing.push("publicKey.y");
    }
    if (missing.length > 0)
      throw new MissingPropertiesError({ envelope, missing, type: "p256" });
    return;
  }
  if (type2 === "webAuthn") {
    const webauthn = envelope;
    const missing = [];
    if (typeof ((_c = webauthn.signature) == null ? void 0 : _c.r) !== "bigint")
      missing.push("signature.r");
    if (typeof ((_d = webauthn.signature) == null ? void 0 : _d.s) !== "bigint")
      missing.push("signature.s");
    if (!webauthn.metadata)
      missing.push("metadata");
    else {
      if (!webauthn.metadata.authenticatorData)
        missing.push("metadata.authenticatorData");
      if (!webauthn.metadata.clientDataJSON)
        missing.push("metadata.clientDataJSON");
    }
    if (!webauthn.publicKey)
      missing.push("publicKey");
    else {
      if (typeof webauthn.publicKey.x !== "bigint")
        missing.push("publicKey.x");
      if (typeof webauthn.publicKey.y !== "bigint")
        missing.push("publicKey.y");
    }
    if (missing.length > 0)
      throw new MissingPropertiesError({ envelope, missing, type: "webAuthn" });
    return;
  }
  if (type2 === "keychain") {
    const keychain = envelope;
    assert3(keychain.inner);
    return;
  }
}
function deserialize(value) {
  const serialized = value.endsWith(magicBytes.slice(2)) ? slice(value, 0, -size(magicBytes)) : value;
  const size2 = size(serialized);
  if (size2 === 65) {
    const signature = fromHex3(serialized);
    assert2(signature);
    return { signature, type: "secp256k1" };
  }
  const typeId = slice(serialized, 0, 1);
  const data = slice(serialized, 1);
  const dataSize = size(data);
  if (typeId === serializedP256Type) {
    if (dataSize !== 129)
      throw new InvalidSerializedError({
        reason: `Invalid P256 signature envelope size: expected 129 bytes, got ${dataSize} bytes`,
        serialized
      });
    return {
      publicKey: {
        prefix: 4,
        x: toBigInt(slice(data, 64, 96)),
        y: toBigInt(slice(data, 96, 128))
      },
      prehash: toNumber(slice(data, 128, 129)) !== 0,
      signature: {
        r: toBigInt(slice(data, 0, 32)),
        s: toBigInt(slice(data, 32, 64))
      },
      type: "p256"
    };
  }
  if (typeId === serializedWebAuthnType) {
    if (dataSize < 128)
      throw new InvalidSerializedError({
        reason: `Invalid WebAuthn signature envelope size: expected at least 128 bytes, got ${dataSize} bytes`,
        serialized
      });
    const webauthnDataSize = dataSize - 128;
    const webauthnData = slice(data, 0, webauthnDataSize);
    let authenticatorData;
    let clientDataJSON;
    for (let split = 37; split < webauthnDataSize; split++) {
      const potentialJson = toString(slice(webauthnData, split));
      if (potentialJson.startsWith("{") && potentialJson.endsWith("}")) {
        try {
          JSON.parse(potentialJson);
          authenticatorData = slice(webauthnData, 0, split);
          clientDataJSON = potentialJson;
          break;
        } catch {
        }
      }
    }
    if (!authenticatorData || !clientDataJSON)
      throw new InvalidSerializedError({
        reason: "Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON",
        serialized
      });
    return {
      publicKey: {
        prefix: 4,
        x: toBigInt(slice(data, webauthnDataSize + 64, webauthnDataSize + 96)),
        y: toBigInt(slice(data, webauthnDataSize + 96, webauthnDataSize + 128))
      },
      metadata: {
        authenticatorData,
        clientDataJSON
      },
      signature: {
        r: toBigInt(slice(data, webauthnDataSize, webauthnDataSize + 32)),
        s: toBigInt(slice(data, webauthnDataSize + 32, webauthnDataSize + 64))
      },
      type: "webAuthn"
    };
  }
  if (typeId === serializedKeychainType) {
    const userAddress = slice(data, 0, 20);
    const inner = deserialize(slice(data, 20));
    return {
      userAddress,
      inner,
      type: "keychain"
    };
  }
  throw new InvalidSerializedError({
    reason: `Unknown signature type identifier: ${typeId}. Expected ${serializedP256Type} (P256) or ${serializedWebAuthnType} (WebAuthn)`,
    serialized
  });
}
function from6(value) {
  if (typeof value === "string")
    return deserialize(value);
  if (typeof value === "object" && value !== null && "r" in value && "s" in value && "yParity" in value)
    return { signature: value, type: "secp256k1" };
  const type2 = getType(value);
  return {
    ...value,
    ...type2 === "p256" ? { prehash: value.prehash } : {},
    type: type2
  };
}
function fromRpc2(envelope) {
  if (envelope.type === "secp256k1")
    return {
      signature: fromRpc(envelope),
      type: "secp256k1"
    };
  if (envelope.type === "p256") {
    return {
      prehash: envelope.preHash,
      publicKey: {
        prefix: 4,
        x: toBigInt(envelope.pubKeyX),
        y: toBigInt(envelope.pubKeyY)
      },
      signature: {
        r: toBigInt(envelope.r),
        s: toBigInt(envelope.s)
      },
      type: "p256"
    };
  }
  if (envelope.type === "webAuthn") {
    const webauthnData = envelope.webauthnData;
    const webauthnDataSize = size(webauthnData);
    let authenticatorData;
    let clientDataJSON;
    for (let split = 37; split < webauthnDataSize; split++) {
      const potentialJson = toString(slice(webauthnData, split));
      if (potentialJson.startsWith("{") && potentialJson.endsWith("}")) {
        try {
          JSON.parse(potentialJson);
          authenticatorData = slice(webauthnData, 0, split);
          clientDataJSON = potentialJson;
          break;
        } catch {
        }
      }
    }
    if (!authenticatorData || !clientDataJSON)
      throw new InvalidSerializedError({
        reason: "Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON",
        serialized: webauthnData
      });
    return {
      metadata: {
        authenticatorData,
        clientDataJSON
      },
      publicKey: {
        prefix: 4,
        x: toBigInt(envelope.pubKeyX),
        y: toBigInt(envelope.pubKeyY)
      },
      signature: {
        r: toBigInt(envelope.r),
        s: toBigInt(envelope.s)
      },
      type: "webAuthn"
    };
  }
  if (envelope.type === "keychain" || "userAddress" in envelope && "signature" in envelope)
    return {
      type: "keychain",
      userAddress: envelope.userAddress,
      inner: fromRpc2(envelope.signature)
    };
  throw new CoercionError({ envelope });
}
function getType(envelope) {
  if (typeof envelope !== "object" || envelope === null)
    throw new CoercionError({ envelope });
  if ("type" in envelope && envelope.type)
    return envelope.type;
  if ("signature" in envelope && !("publicKey" in envelope) && typeof envelope.signature === "object" && envelope.signature !== null && "r" in envelope.signature && "s" in envelope.signature && "yParity" in envelope.signature)
    return "secp256k1";
  if ("r" in envelope && "s" in envelope && "yParity" in envelope)
    return "secp256k1";
  if ("signature" in envelope && "prehash" in envelope && "publicKey" in envelope && typeof envelope.prehash === "boolean")
    return "p256";
  if ("signature" in envelope && "metadata" in envelope && "publicKey" in envelope)
    return "webAuthn";
  if ("userAddress" in envelope && "inner" in envelope)
    return "keychain";
  throw new CoercionError({
    envelope
  });
}
function serialize(envelope, options = {}) {
  const type2 = getType(envelope);
  if (type2 === "secp256k1") {
    const secp256k1 = envelope;
    return concat2(toHex3(secp256k1.signature), options.magic ? magicBytes : "0x");
  }
  if (type2 === "p256") {
    const p2563 = envelope;
    return concat2(serializedP256Type, fromNumber(p2563.signature.r, { size: 32 }), fromNumber(p2563.signature.s, { size: 32 }), fromNumber(p2563.publicKey.x, { size: 32 }), fromNumber(p2563.publicKey.y, { size: 32 }), fromNumber(p2563.prehash ? 1 : 0, { size: 1 }), options.magic ? magicBytes : "0x");
  }
  if (type2 === "webAuthn") {
    const webauthn = envelope;
    const webauthnData = concat2(webauthn.metadata.authenticatorData, fromString2(webauthn.metadata.clientDataJSON));
    return concat2(serializedWebAuthnType, webauthnData, fromNumber(webauthn.signature.r, { size: 32 }), fromNumber(webauthn.signature.s, { size: 32 }), fromNumber(webauthn.publicKey.x, { size: 32 }), fromNumber(webauthn.publicKey.y, { size: 32 }), options.magic ? magicBytes : "0x");
  }
  if (type2 === "keychain") {
    const keychain = envelope;
    return concat2(serializedKeychainType, keychain.userAddress, serialize(keychain.inner), options.magic ? magicBytes : "0x");
  }
  throw new CoercionError({ envelope });
}
function toRpc2(envelope) {
  const type2 = getType(envelope);
  if (type2 === "secp256k1") {
    const secp256k1 = envelope;
    return {
      ...toRpc(secp256k1.signature),
      type: "secp256k1"
    };
  }
  if (type2 === "p256") {
    const p2563 = envelope;
    return {
      preHash: p2563.prehash,
      pubKeyX: fromNumber(p2563.publicKey.x, { size: 32 }),
      pubKeyY: fromNumber(p2563.publicKey.y, { size: 32 }),
      r: fromNumber(p2563.signature.r, { size: 32 }),
      s: fromNumber(p2563.signature.s, { size: 32 }),
      type: "p256"
    };
  }
  if (type2 === "webAuthn") {
    const webauthn = envelope;
    const webauthnData = concat2(webauthn.metadata.authenticatorData, fromString2(webauthn.metadata.clientDataJSON));
    return {
      pubKeyX: fromNumber(webauthn.publicKey.x, { size: 32 }),
      pubKeyY: fromNumber(webauthn.publicKey.y, { size: 32 }),
      r: fromNumber(webauthn.signature.r, { size: 32 }),
      s: fromNumber(webauthn.signature.s, { size: 32 }),
      type: "webAuthn",
      webauthnData
    };
  }
  if (type2 === "keychain") {
    const keychain = envelope;
    return {
      type: "keychain",
      userAddress: keychain.userAddress,
      signature: toRpc2(keychain.inner)
    };
  }
  throw new CoercionError({ envelope });
}
function validate4(envelope) {
  try {
    assert3(envelope);
    return true;
  } catch {
    return false;
  }
}
function verify4(signature, parameters) {
  const { payload } = parameters;
  const address = (() => {
    if (parameters.address)
      return parameters.address;
    if (parameters.publicKey)
      return fromPublicKey(parameters.publicKey);
    return void 0;
  })();
  if (!address)
    return false;
  const envelope = from6(signature);
  if (envelope.type === "secp256k1") {
    if (!address)
      return false;
    return verify({
      address,
      payload,
      signature: envelope.signature
    });
  }
  if (envelope.type === "p256") {
    const envelopeAddress = fromPublicKey(envelope.publicKey);
    if (!isEqual(envelopeAddress, address))
      return false;
    return verify2({
      hash: envelope.prehash,
      publicKey: envelope.publicKey,
      payload,
      signature: envelope.signature
    });
  }
  if (envelope.type === "webAuthn") {
    const envelopeAddress = fromPublicKey(envelope.publicKey);
    if (!isEqual(envelopeAddress, address))
      return false;
    return verify3({
      challenge: from(payload),
      metadata: envelope.metadata,
      publicKey: envelope.publicKey,
      signature: envelope.signature
    });
  }
  throw new VerificationError(`Unable to verify signature envelope of type "${envelope.type}".`);
}
var CoercionError = class extends BaseError {
  constructor({ envelope }) {
    super(`Unable to coerce value (\`${stringify(envelope)}\`) to a valid signature envelope.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SignatureEnvelope.CoercionError"
    });
  }
};
var MissingPropertiesError = class extends BaseError {
  constructor({ envelope, missing, type: type2 }) {
    super(`Signature envelope of type "${type2}" is missing required properties: ${missing.map((m) => `\`${m}\``).join(", ")}.

Provided: ${stringify(envelope)}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SignatureEnvelope.MissingPropertiesError"
    });
  }
};
var InvalidSerializedError = class extends BaseError {
  constructor({ reason, serialized }) {
    super(`Unable to deserialize signature envelope: ${reason}`, {
      metaMessages: [`Serialized: ${serialized}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SignatureEnvelope.InvalidSerializedError"
    });
  }
};
var VerificationError = class extends BaseError {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SignatureEnvelope.VerificationError"
    });
  }
};

// node_modules/ox/_esm/tempo/AuthorizationTempo.js
function from7(authorization, options = {}) {
  if (typeof authorization.chainId === "string")
    return fromRpc3(authorization);
  if (options.signature) {
    return { ...authorization, signature: options.signature };
  }
  return authorization;
}
function fromRpc3(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = fromRpc2(authorization.signature);
  return {
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    signature
  };
}
function fromRpcList2(authorizationList) {
  return authorizationList.map((x) => fromRpc3(x));
}
function fromTuple2(tuple) {
  const [chainId, address, nonce, signatureSerialized] = tuple;
  const args = {
    address,
    chainId: chainId === "0x" ? 0 : Number(chainId),
    nonce: nonce === "0x" ? 0n : BigInt(nonce)
  };
  if (signatureSerialized)
    args.signature = deserialize(signatureSerialized);
  return from7(args);
}
function fromTupleList(tupleList) {
  const list = [];
  for (const tuple of tupleList)
    list.push(fromTuple2(tuple));
  return list;
}
function getSignPayload2(authorization) {
  return hash(authorization, { presign: true });
}
function hash(authorization, options = {}) {
  const { presign } = options;
  return keccak256(concat2("0x05", fromHex2(toTuple2(presign ? {
    address: authorization.address,
    chainId: authorization.chainId,
    nonce: authorization.nonce
  } : authorization))));
}
function toRpc3(authorization) {
  const { address, chainId, nonce, signature } = authorization;
  return {
    address,
    chainId: fromNumber(chainId),
    nonce: fromNumber(nonce),
    signature: toRpc2(signature)
  };
}
function toRpcList2(authorizationList) {
  return authorizationList.map((x) => toRpc3(x));
}
function toTuple2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = authorization.signature ? serialize(authorization.signature) : void 0;
  return [
    chainId ? fromNumber(chainId) : "0x",
    address,
    nonce ? fromNumber(nonce) : "0x",
    ...signature ? [signature] : []
  ];
}
function toTupleList(list) {
  if (!list || list.length === 0)
    return [];
  const tupleList = [];
  for (const authorization of list)
    tupleList.push(toTuple2(authorization));
  return tupleList;
}

// node_modules/ox/_esm/tempo/KeyAuthorization.js
var KeyAuthorization_exports = {};
__export(KeyAuthorization_exports, {
  from: () => from8,
  fromRpc: () => fromRpc4,
  fromTuple: () => fromTuple3,
  getSignPayload: () => getSignPayload3,
  hash: () => hash2,
  toRpc: () => toRpc4,
  toTuple: () => toTuple3
});
function from8(authorization, options = {}) {
  if (typeof authorization.expiry === "string")
    return fromRpc4(authorization);
  if (options.signature)
    return {
      ...authorization,
      signature: from6(options.signature)
    };
  return authorization;
}
function fromRpc4(authorization) {
  const { chainId = "0x0", keyId, expiry = 0, limits, keyType } = authorization;
  const signature = fromRpc2(authorization.signature);
  return {
    address: keyId,
    chainId: chainId === "0x" ? 0n : toBigInt(chainId),
    expiry: Number(expiry),
    limits: limits == null ? void 0 : limits.map((limit) => ({
      token: limit.token,
      limit: BigInt(limit.limit)
    })),
    signature,
    type: keyType
  };
}
function fromTuple3(tuple) {
  const [authorization, signatureSerialized] = tuple;
  const [chainId, keyType_hex, keyId, expiry, limits] = authorization;
  const keyType = (() => {
    switch (keyType_hex) {
      case "0x":
      case "0x00":
        return "secp256k1";
      case "0x01":
        return "p256";
      case "0x02":
        return "webAuthn";
      default:
        throw new Error(`Invalid key type: ${keyType_hex}`);
    }
  })();
  const args = {
    address: keyId,
    expiry: typeof expiry !== "undefined" ? toNumber(expiry) : void 0,
    type: keyType,
    ...chainId !== "0x" ? { chainId: toBigInt(chainId) } : {},
    ...typeof expiry !== "undefined" ? { expiry: toNumber(expiry) } : {},
    ...typeof limits !== "undefined" ? {
      limits: limits.map(([token, limit]) => ({
        token,
        limit: BigInt(limit)
      }))
    } : {}
  };
  if (signatureSerialized)
    args.signature = deserialize(signatureSerialized);
  return from8(args);
}
function getSignPayload3(authorization) {
  return hash2(authorization);
}
function hash2(authorization) {
  const [authorizationTuple] = toTuple3(authorization);
  const serialized = fromHex2(authorizationTuple);
  return keccak256(serialized);
}
function toRpc4(authorization) {
  const { address, chainId = 0n, expiry, limits, type: type2, signature } = authorization;
  return {
    chainId: chainId === 0n ? "0x" : fromNumber(chainId),
    expiry: typeof expiry === "number" ? fromNumber(expiry) : null,
    limits: limits == null ? void 0 : limits.map(({ token, limit }) => ({
      token,
      limit: fromNumber(limit)
    })),
    keyId: address,
    signature: toRpc2(signature),
    keyType: type2
  };
}
function toTuple3(authorization) {
  const { address, chainId = 0n, expiry, limits } = authorization;
  const signature = authorization.signature ? serialize(authorization.signature) : void 0;
  const type2 = (() => {
    switch (authorization.type) {
      case "secp256k1":
        return "0x";
      case "p256":
        return "0x01";
      case "webAuthn":
        return "0x02";
      default:
        throw new Error(`Invalid key type: ${authorization.type}`);
    }
  })();
  const authorizationTuple = [
    chainId === 0n ? "0x" : fromNumber(chainId),
    type2,
    address,
    typeof expiry === "number" ? fromNumber(expiry) : void 0,
    (limits == null ? void 0 : limits.map((limit) => [limit.token, fromNumber(limit.limit)])) ?? void 0
  ].filter(Boolean);
  return [authorizationTuple, ...signature ? [signature] : []];
}

// node_modules/ox/_esm/tempo/PoolId.js
var PoolId_exports = {};
__export(PoolId_exports, {
  from: () => from9
});
function from9(value) {
  return keccak256(concat2(padLeft(toAddress(value.userToken), 32), padLeft(toAddress(value.validatorToken), 32)));
}

// node_modules/ox/_esm/tempo/TokenRole.js
var TokenRole_exports = {};
__export(TokenRole_exports, {
  roles: () => roles,
  serialize: () => serialize2,
  toPreHashed: () => toPreHashed
});
var roles = [
  "defaultAdmin",
  "pause",
  "unpause",
  "issuer",
  "burnBlocked"
];
var toPreHashed = {
  defaultAdmin: "DEFAULT_ADMIN_ROLE",
  pause: "PAUSE_ROLE",
  unpause: "UNPAUSE_ROLE",
  issuer: "ISSUER_ROLE",
  burnBlocked: "BURN_BLOCKED_ROLE"
};
function serialize2(role) {
  if (role === "defaultAdmin")
    return "0x0000000000000000000000000000000000000000000000000000000000000000";
  return keccak256(fromString2(toPreHashed[role] ?? role));
}

// node_modules/ox/_esm/tempo/Transaction.js
var Transaction_exports = {};
__export(Transaction_exports, {
  fromRpc: () => fromRpc6,
  fromRpcType: () => fromRpcType2,
  toRpc: () => toRpc6,
  toRpcType: () => toRpcType2
});

// node_modules/ox/_esm/core/Transaction.js
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function fromRpc5(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
function toRpc5(transaction, _options) {
  const rpc = {};
  rpc.blockHash = transaction.blockHash;
  rpc.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber(transaction.blockNumber) : null;
  rpc.from = transaction.from;
  rpc.gas = fromNumber(transaction.gas ?? 0n);
  rpc.hash = transaction.hash;
  rpc.input = transaction.input;
  rpc.nonce = fromNumber(transaction.nonce ?? 0n);
  rpc.to = transaction.to;
  rpc.transactionIndex = transaction.transactionIndex ? fromNumber(transaction.transactionIndex) : null;
  rpc.type = toRpcType[transaction.type] ?? transaction.type;
  rpc.value = fromNumber(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc.chainId = fromNumber(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc.gasPrice = fromNumber(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc.maxFeePerBlobGas = fromNumber(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc.maxFeePerGas = fromNumber(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc.maxPriorityFeePerGas = fromNumber(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc.r = fromNumber(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc.s = fromNumber(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc.v = fromNumber(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc;
}

// node_modules/ox/_esm/tempo/Transaction.js
var toRpcType2 = {
  ...toRpcType,
  tempo: "0x76"
};
var fromRpcType2 = {
  ...fromRpcType,
  "0x76": "tempo"
};
function fromRpc6(transaction, _options = {}) {
  if (!transaction)
    return null;
  const transaction_ = fromRpc5(transaction);
  transaction_.type = fromRpcType2[transaction.type];
  if (transaction.aaAuthorizationList) {
    transaction_.authorizationList = fromRpcList2(transaction.aaAuthorizationList);
    delete transaction_.aaAuthorizationList;
  }
  if (transaction.calls)
    transaction_.calls = transaction.calls.map((call) => ({
      to: call.to,
      value: call.value && call.value !== "0x" ? BigInt(call.value) : void 0,
      // @ts-expect-error
      data: call.input || call.data || "0x"
    }));
  if (transaction.feeToken)
    transaction_.feeToken = transaction.feeToken;
  if (transaction.nonceKey)
    transaction_.nonceKey = BigInt(transaction.nonceKey);
  if (transaction.signature)
    transaction_.signature = fromRpc2(transaction.signature);
  if (transaction.validAfter)
    transaction_.validAfter = Number(transaction.validAfter);
  if (transaction.validBefore)
    transaction_.validBefore = Number(transaction.validBefore);
  if (transaction.keyAuthorization)
    transaction_.keyAuthorization = fromRpc4(transaction.keyAuthorization);
  if (transaction.feePayerSignature) {
    transaction_.feePayerSignature = fromRpc(transaction.feePayerSignature);
    transaction_.feePayerSignature.v = yParityToV(transaction_.feePayerSignature.yParity);
  }
  return transaction_;
}
function toRpc6(transaction, _options) {
  var _a;
  const rpc = toRpc5(transaction);
  rpc.type = toRpcType2[transaction.type];
  if (transaction.authorizationList)
    rpc.aaAuthorizationList = toRpcList2(transaction.authorizationList);
  if (transaction.calls)
    rpc.calls = transaction.calls.map((call) => ({
      to: call.to,
      value: call.value ? fromNumber(call.value) : void 0,
      data: call.data
    }));
  if (transaction.feeToken)
    rpc.feeToken = transaction.feeToken;
  if (transaction.keyAuthorization)
    rpc.keyAuthorization = toRpc4(transaction.keyAuthorization);
  if (transaction.feePayerSignature) {
    rpc.feePayerSignature = toRpc(transaction.feePayerSignature);
    rpc.feePayerSignature.v = fromNumber(yParityToV((_a = transaction.feePayerSignature) == null ? void 0 : _a.yParity));
  }
  if (transaction.signature)
    rpc.signature = toRpc2(transaction.signature);
  if (typeof transaction.validAfter === "number")
    rpc.validAfter = fromNumber(transaction.validAfter);
  if (typeof transaction.validBefore === "number")
    rpc.validBefore = fromNumber(transaction.validBefore);
  return rpc;
}

// node_modules/ox/_esm/tempo/TransactionReceipt.js
var TransactionReceipt_exports = {};
__export(TransactionReceipt_exports, {
  fromRpc: () => fromRpc9,
  fromRpcType: () => fromRpcType4,
  toRpc: () => toRpc9,
  toRpcType: () => toRpcType4
});

// node_modules/ox/_esm/core/Log.js
function fromRpc7(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
function toRpc7(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber(log.transactionIndex) : null,
    removed: log.removed
  };
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var fromRpcStatus = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType3 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType3 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc8(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc7(log, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType3[receipt.type] || receipt.type
  };
}
function toRpc8(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber(receipt.gasUsed),
    logs: receipt.logs.map(toRpc7),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber(receipt.transactionIndex),
    type: toRpcType3[receipt.type] ?? receipt.type
  };
}

// node_modules/ox/_esm/tempo/TransactionReceipt.js
var fromRpcType4 = {
  ...fromRpcType3,
  "0x76": "tempo"
};
var toRpcType4 = {
  ...toRpcType3,
  tempo: "0x76"
};
function fromRpc9(receipt) {
  return fromRpc8(receipt);
}
function toRpc9(receipt) {
  const rpc = toRpc8(receipt);
  return {
    ...rpc,
    feePayer: receipt.feePayer,
    feeToken: receipt.feeToken
  };
}

// node_modules/ox/_esm/tempo/TransactionRequest.js
var TransactionRequest_exports = {};
__export(TransactionRequest_exports, {
  toRpc: () => toRpc11
});

// node_modules/ox/_esm/core/TransactionRequest.js
function toRpc10(request) {
  const request_rpc = {};
  if (typeof request.accessList !== "undefined")
    request_rpc.accessList = request.accessList;
  if (typeof request.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request.authorizationList);
  if (typeof request.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined")
    request_rpc.blobs = request.blobs;
  if (typeof request.chainId !== "undefined")
    request_rpc.chainId = fromNumber(request.chainId);
  if (typeof request.data !== "undefined") {
    request_rpc.data = request.data;
    request_rpc.input = request.data;
  } else if (typeof request.input !== "undefined") {
    request_rpc.data = request.input;
    request_rpc.input = request.input;
  }
  if (typeof request.from !== "undefined")
    request_rpc.from = request.from;
  if (typeof request.gas !== "undefined")
    request_rpc.gas = fromNumber(request.gas);
  if (typeof request.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber(request.maxPriorityFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    request_rpc.nonce = fromNumber(request.nonce);
  if (typeof request.to !== "undefined")
    request_rpc.to = request.to;
  if (typeof request.type !== "undefined")
    request_rpc.type = toRpcType[request.type] || request.type;
  if (typeof request.value !== "undefined")
    request_rpc.value = fromNumber(request.value);
  return request_rpc;
}

// node_modules/ox/_esm/tempo/TransactionRequest.js
function toRpc11(request) {
  const request_rpc = toRpc10({
    ...request,
    authorizationList: void 0
  });
  if (request.authorizationList)
    request_rpc.authorizationList = toRpcList2(request.authorizationList);
  if (request.calls)
    request_rpc.calls = request.calls.map((call) => ({
      to: call.to,
      value: call.value ? fromNumber(call.value) : "0x",
      data: call.data ?? "0x"
    }));
  if (typeof request.feeToken !== "undefined")
    request_rpc.feeToken = toAddress(request.feeToken);
  if (request.keyAuthorization)
    request_rpc.keyAuthorization = toRpc4(request.keyAuthorization);
  if (typeof request.validBefore !== "undefined")
    request_rpc.validBefore = fromNumber(request.validBefore);
  if (typeof request.validAfter !== "undefined")
    request_rpc.validAfter = fromNumber(request.validAfter);
  const nonceKey = (() => {
    if (request.nonceKey === "random")
      return random(6);
    if (typeof request.nonceKey === "bigint")
      return fromNumber(request.nonceKey);
    return void 0;
  })();
  if (nonceKey)
    request_rpc.nonceKey = nonceKey;
  if (typeof request.calls !== "undefined" || typeof request.feeToken !== "undefined" || typeof request.keyAuthorization !== "undefined" || typeof request.nonceKey !== "undefined" || typeof request.validBefore !== "undefined" || typeof request.validAfter !== "undefined" || request.type === "tempo") {
    request_rpc.type = toRpcType2.tempo;
    delete request_rpc.data;
    delete request_rpc.input;
    delete request_rpc.to;
    delete request_rpc.value;
  }
  return request_rpc;
}

// node_modules/ox/_esm/tempo/TxEnvelopeTempo.js
var TxEnvelopeTempo_exports = {};
__export(TxEnvelopeTempo_exports, {
  CallsEmptyError: () => CallsEmptyError,
  InvalidValidityWindowError: () => InvalidValidityWindowError,
  assert: () => assert4,
  deserialize: () => deserialize2,
  feePayerMagic: () => feePayerMagic,
  from: () => from10,
  getFeePayerSignPayload: () => getFeePayerSignPayload,
  getSignPayload: () => getSignPayload4,
  hash: () => hash3,
  serialize: () => serialize3,
  serializedType: () => serializedType,
  type: () => type,
  validate: () => validate5
});

// node_modules/ox/_esm/core/AccessList.js
function fromTupleList2(accessList) {
  const list = [];
  for (let i = 0; i < accessList.length; i++) {
    const [address, storageKeys] = accessList[i];
    if (address)
      assert(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate2(key) ? key : trimLeft(key))
    });
  }
  return list;
}
function toTupleList2(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple = [];
  for (const { address, storageKeys } of accessList) {
    for (let j = 0; j < storageKeys.length; j++)
      if (size(storageKeys[j]) !== 32)
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j]
        });
    if (address)
      assert(address, { strict: false });
    tuple.push([address, storageKeys]);
  }
  return tuple;
}
var InvalidStorageKeySizeError = class extends BaseError {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${size(storageKey)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccessList.InvalidStorageKeySizeError"
    });
  }
};

// node_modules/ox/_esm/core/Value.js
var exponents = {
  wei: 0,
  gwei: 9,
  szabo: 12,
  finney: 15,
  ether: 18
};
function format(value, decimals = 0) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei(wei, unit = "wei") {
  return format(wei, exponents.gwei - exponents[unit]);
}

// node_modules/ox/_esm/core/TxEnvelope.js
var FeeCapTooHighError = class extends BaseError {
  constructor({ feeCap } = {}) {
    super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.FeeCapTooHighError"
    });
  }
};
var InvalidChainIdError = class extends BaseError {
  constructor({ chainId }) {
    super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidChainIdError"
    });
  }
};
var InvalidSerializedError2 = class extends BaseError {
  constructor({ attributes, serialized, type: type2 }) {
    const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type2}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serialized}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidSerializedError"
    });
  }
};
var TipAboveFeeCapError = class extends BaseError {
  constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.TipAboveFeeCapError"
    });
  }
};

// node_modules/ox/_esm/tempo/TxEnvelopeTempo.js
var feePayerMagic = "0x78";
var serializedType = "0x76";
var type = "tempo";
function assert4(envelope) {
  const { calls, chainId, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter } = envelope;
  if (!calls || calls.length === 0)
    throw new CallsEmptyError();
  if (typeof validBefore === "number" && typeof validAfter === "number" && validBefore <= validAfter) {
    throw new InvalidValidityWindowError({
      validBefore,
      validAfter
    });
  }
  if (calls) {
    for (const call of calls)
      if (call.to)
        assert(call.to, { strict: false });
  }
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({
      feeCap: maxFeePerGas
    });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
function deserialize2(serialized) {
  const transactionArray = toHex2(slice(serialized, 1));
  const [chainId, maxPriorityFeePerGas, maxFeePerGas, gas, calls, accessList, nonceKey, nonce, validBefore, validAfter, feeToken, feePayerSignatureOrSender, authorizationList, keyAuthorizationOrSignature, maybeSignature] = transactionArray;
  const keyAuthorization = Array.isArray(keyAuthorizationOrSignature) ? keyAuthorizationOrSignature : void 0;
  const signature = keyAuthorization ? maybeSignature : keyAuthorizationOrSignature;
  if (!(transactionArray.length === 13 || transactionArray.length === 14 || transactionArray.length === 15))
    throw new InvalidSerializedError2({
      attributes: {
        authorizationList,
        chainId,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        calls,
        accessList,
        keyAuthorization,
        nonceKey,
        nonce,
        validBefore,
        validAfter,
        feeToken,
        feePayerSignatureOrSender,
        ...transactionArray.length > 12 ? {
          signature
        } : {}
      },
      serialized,
      type
    });
  let transaction = {
    chainId: Number(chainId),
    type
  };
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (validate(nonceKey))
    transaction.nonceKey = nonceKey === "0x" ? 0n : BigInt(nonceKey);
  if (validate(validBefore) && validBefore !== "0x")
    transaction.validBefore = Number(validBefore);
  if (validate(validAfter) && validAfter !== "0x")
    transaction.validAfter = Number(validAfter);
  if (validate(feeToken) && feeToken !== "0x")
    transaction.feeToken = feeToken;
  if (calls && calls !== "0x") {
    const callsArray = calls;
    transaction.calls = callsArray.map((callTuple) => {
      const [to, value, data] = callTuple;
      const call = {};
      if (to && to !== "0x")
        call.to = to;
      if (value && value !== "0x")
        call.value = BigInt(value);
      if (data && data !== "0x")
        call.data = data;
      return call;
    });
  }
  if ((accessList == null ? void 0 : accessList.length) !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList2(accessList);
  if ((authorizationList == null ? void 0 : authorizationList.length) !== 0 && authorizationList !== "0x")
    transaction.authorizationList = fromTupleList(authorizationList);
  if (feePayerSignatureOrSender !== "0x" && feePayerSignatureOrSender !== void 0) {
    if (feePayerSignatureOrSender === "0x00" || validate3(feePayerSignatureOrSender))
      transaction.feePayerSignature = null;
    else
      transaction.feePayerSignature = fromTuple(feePayerSignatureOrSender);
  }
  if (keyAuthorization)
    transaction.keyAuthorization = fromTuple3(keyAuthorization);
  const signatureEnvelope = signature ? deserialize(signature) : void 0;
  if (signatureEnvelope)
    transaction = {
      ...transaction,
      signature: signatureEnvelope
    };
  assert4(transaction);
  return transaction;
}
function from10(envelope, options = {}) {
  const { feePayerSignature, signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert4(envelope_);
  return {
    ...envelope_,
    ...signature ? { signature: from6(signature) } : {},
    ...feePayerSignature ? { feePayerSignature: from4(feePayerSignature) } : {},
    type: "tempo"
  };
}
function serialize3(envelope, options = {}) {
  const { accessList, authorizationList, calls, chainId, feeToken, gas, keyAuthorization, nonce, nonceKey, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter } = envelope;
  assert4(envelope);
  const accessTupleList = toTupleList2(accessList);
  const signature = options.signature || envelope.signature;
  const authorizationTupleList = toTupleList(authorizationList);
  const callsTupleList = calls.map((call) => [
    call.to ?? "0x",
    call.value ? fromNumber(call.value) : "0x",
    call.data ?? "0x"
  ]);
  const feePayerSignatureOrSender = (() => {
    if (options.sender)
      return options.sender;
    const feePayerSignature = typeof options.feePayerSignature !== "undefined" ? options.feePayerSignature : envelope.feePayerSignature;
    if (feePayerSignature === null)
      return "0x00";
    if (!feePayerSignature)
      return "0x";
    return toTuple(feePayerSignature);
  })();
  const serialized = [
    fromNumber(chainId),
    maxPriorityFeePerGas ? fromNumber(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber(maxFeePerGas) : "0x",
    gas ? fromNumber(gas) : "0x",
    callsTupleList,
    accessTupleList,
    nonceKey ? fromNumber(nonceKey) : "0x",
    nonce ? fromNumber(nonce) : "0x",
    typeof validBefore === "number" ? fromNumber(validBefore) : "0x",
    typeof validAfter === "number" ? fromNumber(validAfter) : "0x",
    typeof feeToken === "bigint" || typeof feeToken === "string" ? toAddress(feeToken) : "0x",
    feePayerSignatureOrSender,
    authorizationTupleList,
    ...keyAuthorization ? [toTuple3(keyAuthorization)] : [],
    ...signature ? [serialize(from6(signature))] : []
  ];
  return concat2(options.format === "feePayer" ? feePayerMagic : serializedType, fromHex2(serialized));
}
function getSignPayload4(envelope) {
  return hash3(envelope, { presign: true });
}
function hash3(envelope, options = {}) {
  const serialized = serialize3({
    ...envelope,
    ...options.presign ? {
      signature: void 0
    } : {}
  });
  return keccak256(serialized);
}
function getFeePayerSignPayload(envelope, options) {
  const { sender } = options;
  const serialized = serialize3({ ...envelope, signature: void 0 }, {
    sender,
    format: "feePayer"
  });
  return keccak256(serialized);
}
function validate5(envelope) {
  try {
    assert4(envelope);
    return true;
  } catch {
    return false;
  }
}
var CallsEmptyError = class extends BaseError {
  constructor() {
    super("Calls list cannot be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TxEnvelopeTempo.CallsEmptyError"
    });
  }
};
var InvalidValidityWindowError = class extends BaseError {
  constructor({ validBefore, validAfter }) {
    super(`validBefore (${validBefore}) must be greater than validAfter (${validAfter}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TxEnvelopeTempo.InvalidValidityWindowError"
    });
  }
};

// node_modules/viem/_esm/tempo/Transaction.js
var Transaction_exports3 = {};
__export(Transaction_exports3, {
  deserialize: () => deserialize3,
  getType: () => getType2,
  isTempo: () => isTempo,
  serialize: () => serialize4,
  z_KeyAuthorization: () => KeyAuthorization_exports,
  z_SignatureEnvelope: () => SignatureEnvelope_exports,
  z_TxEnvelopeTempo: () => TxEnvelopeTempo_exports
});
function getType2(transaction) {
  const account = transaction.account;
  if ((account == null ? void 0 : account.keyType) && account.keyType !== "secp256k1" || typeof transaction.calls !== "undefined" || typeof transaction.feePayer !== "undefined" || typeof transaction.feeToken !== "undefined" || typeof transaction.keyAuthorization !== "undefined" || typeof transaction.nonceKey !== "undefined" || typeof transaction.signature !== "undefined" || typeof transaction.validBefore !== "undefined" || typeof transaction.validAfter !== "undefined")
    return "tempo";
  if (transaction.type)
    return transaction.type;
  return getTransactionType(transaction);
}
function isTempo(transaction) {
  try {
    const type2 = getType2(transaction);
    return type2 === "tempo";
  } catch {
    return false;
  }
}
function deserialize3(serializedTransaction) {
  const type2 = slice(serializedTransaction, 0, 1);
  if (type2 === "0x76") {
    const from11 = slice(serializedTransaction, -6) === "0xfeefeefeefee" ? slice(serializedTransaction, -26, -6) : void 0;
    return {
      ...deserializeTempo(serializedTransaction),
      from: from11
    };
  }
  return parseTransaction(serializedTransaction);
}
async function serialize4(transaction, signature) {
  if (!isTempo(transaction)) {
    if (signature && "type" in signature && signature.type !== "secp256k1")
      throw new Error("Unsupported signature type. Expected `secp256k1` but got `" + signature.type + "`.");
    if (signature && "type" in signature) {
      const { r, s, yParity } = signature == null ? void 0 : signature.signature;
      return serializeTransaction(transaction, {
        r: fromNumber(r, { size: 32 }),
        s: fromNumber(s, { size: 32 }),
        yParity
      });
    }
    return serializeTransaction(transaction, signature);
  }
  const type2 = getType2(transaction);
  if (type2 === "tempo")
    return serializeTempo(transaction, signature);
  throw new Error("Unsupported transaction type");
}
function deserializeTempo(serializedTransaction) {
  const { feePayerSignature, nonce, ...tx } = TxEnvelopeTempo_exports.deserialize(serializedTransaction);
  return {
    ...tx,
    nonce: Number(nonce ?? 0n),
    feePayerSignature: feePayerSignature ? {
      r: fromNumber(feePayerSignature.r, { size: 32 }),
      s: fromNumber(feePayerSignature.s, { size: 32 }),
      yParity: feePayerSignature.yParity
    } : feePayerSignature
  };
}
async function serializeTempo(transaction, sig) {
  var _a;
  const signature = (() => {
    if (transaction.signature)
      return transaction.signature;
    if (sig && "type" in sig)
      return sig;
    if (sig)
      return SignatureEnvelope_exports.from({
        r: BigInt(sig.r),
        s: BigInt(sig.s),
        yParity: Number(sig.yParity)
      });
    return void 0;
  })();
  const { chainId, feePayer, feePayerSignature, nonce, ...rest } = transaction;
  const transaction_ox = {
    ...rest,
    calls: ((_a = rest.calls) == null ? void 0 : _a.length) ? rest.calls : [
      {
        to: rest.to || (!rest.data || rest.data === "0x" ? "0x0000000000000000000000000000000000000000" : void 0),
        value: rest.value,
        data: rest.data
      }
    ],
    chainId: Number(chainId),
    feePayerSignature: feePayerSignature ? {
      r: BigInt(feePayerSignature.r),
      s: BigInt(feePayerSignature.s),
      yParity: Number(feePayerSignature.yParity)
    } : feePayer ? null : void 0,
    type: "tempo",
    ...nonce ? { nonce: BigInt(nonce) } : {}
  };
  if (feePayer === true)
    delete transaction_ox.feeToken;
  if (signature && typeof transaction.feePayer === "object") {
    const tx = TxEnvelopeTempo_exports.from(transaction_ox, {
      signature
    });
    const sender = (() => {
      if (transaction.from)
        return transaction.from;
      if (signature.type === "secp256k1")
        return recoverAddress({
          payload: TxEnvelopeTempo_exports.getSignPayload(tx),
          signature: signature.signature
        });
      throw new Error("Unable to extract sender from transaction or signature.");
    })();
    const hash4 = TxEnvelopeTempo_exports.getFeePayerSignPayload(tx, {
      sender
    });
    const feePayerSignature2 = await transaction.feePayer.sign({
      hash: hash4
    });
    return TxEnvelopeTempo_exports.serialize(tx, {
      feePayerSignature: from4(feePayerSignature2)
    });
  }
  if (feePayer === true) {
    const serialized = TxEnvelopeTempo_exports.serialize(transaction_ox, {
      feePayerSignature: null,
      signature
    });
    if (transaction.from && signature)
      return concat2(serialized, transaction.from, "0xfeefeefeefee");
    return serialized;
  }
  return TxEnvelopeTempo_exports.serialize(
    // If we have specified a fee payer, the user will not be signing over the fee token.
    // Defer the fee token signing to the fee payer.
    { ...transaction_ox, ...feePayer ? { feeToken: void 0 } : {} },
    {
      feePayerSignature: void 0,
      signature
    }
  );
}

// node_modules/viem/_esm/tempo/Formatters.js
var Formatters_exports = {};
__export(Formatters_exports, {
  formatTransaction: () => formatTransaction2,
  formatTransactionReceipt: () => formatTransactionReceipt2,
  formatTransactionRequest: () => formatTransactionRequest2
});
function formatTransaction2(transaction) {
  if (!isTempo(transaction))
    return formatTransaction(transaction);
  const { feePayerSignature, gasPrice: _, nonce, ...tx } = Transaction_exports.fromRpc(transaction);
  return {
    ...tx,
    accessList: tx.accessList,
    feePayerSignature: feePayerSignature ? {
      r: fromNumber(feePayerSignature.r, { size: 32 }),
      s: fromNumber(feePayerSignature.s, { size: 32 }),
      v: BigInt(feePayerSignature.v ?? 27),
      yParity: feePayerSignature.yParity
    } : void 0,
    nonce: Number(nonce),
    typeHex: Transaction_exports.toRpcType[tx.type],
    type: tx.type
  };
}
function formatTransactionReceipt2(receipt) {
  return formatTransactionReceipt(receipt);
}
function formatTransactionRequest2(r, action) {
  const request = r;
  const account = request.account ? parseAccount(request.account) : void 0;
  if (!isTempo(request))
    return formatTransactionRequest(r, action);
  if (action)
    request.calls = request.calls ?? [
      {
        to: r.to || (!r.data || r.data === "0x" ? "0x0000000000000000000000000000000000000000" : void 0),
        value: r.value,
        data: r.data
      }
    ];
  if (request.feePayer === true)
    delete request.feeToken;
  const rpc = TransactionRequest_exports.toRpc({
    ...request,
    type: "tempo"
  });
  if (action === "estimateGas") {
    rpc.maxFeePerGas = void 0;
    rpc.maxPriorityFeePerGas = void 0;
  }
  rpc.to = void 0;
  rpc.data = void 0;
  rpc.value = void 0;
  const [keyType, keyData] = (() => {
    const type2 = account && "keyType" in account ? account.keyType : account == null ? void 0 : account.source;
    if (!type2)
      return [void 0, void 0];
    if (type2 === "webAuthn")
      return ["webAuthn", `0x${"ff".repeat(1400)}`];
    if (["p256", "secp256k1"].includes(type2))
      return [type2, void 0];
    return [void 0, void 0];
  })();
  const keyId = account && "accessKeyAddress" in account ? account.accessKeyAddress : void 0;
  return {
    ...rpc,
    ...keyData ? { keyData } : {},
    ...keyId ? { keyId } : {},
    ...keyType ? { keyType } : {},
    ...request.feePayer ? {
      feePayer: typeof request.feePayer === "object" ? parseAccount(request.feePayer) : request.feePayer
    } : {}
  };
}

export {
  p2562 as p256,
  getPublicKey,
  randomPrivateKey,
  sign,
  createCredential,
  getSignPayload,
  sign2,
  SignatureEnvelope_exports,
  KeyAuthorization_exports,
  TokenId_exports,
  PoolId_exports,
  Tick_exports,
  TokenRole_exports,
  TxEnvelopeTempo_exports,
  deserialize3 as deserialize,
  serialize4 as serialize,
  Transaction_exports3 as Transaction_exports,
  formatTransaction2 as formatTransaction,
  formatTransactionReceipt2 as formatTransactionReceipt,
  formatTransactionRequest2 as formatTransactionRequest,
  Formatters_exports
};
/*! Bundled license information:

@noble/curves/esm/nist.js:
@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-ZHUZU25O.js.map
