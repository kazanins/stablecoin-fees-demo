{
  "version": 3,
  "sources": ["../../eventemitter3/index.js", "../../viem/tempo/Abis.ts", "../../viem/tempo/Account.ts", "../../ox/core/WebCryptoP256.ts", "../../viem/tempo/Addresses.ts", "../../viem/tempo/actions/index.ts", "../../viem/tempo/actions/amm.ts", "../../viem/tempo/internal/utils.ts", "../../viem/tempo/actions/dex.ts", "../../viem/tempo/actions/faucet.ts", "../../viem/tempo/actions/fee.ts", "../../viem/tempo/actions/nonce.ts", "../../viem/tempo/actions/policy.ts", "../../viem/tempo/actions/reward.ts", "../../viem/tempo/actions/token.ts", "../../viem/tempo/actions/validator.ts", "../../viem/_esm/tempo/Capabilities.js", "../../viem/tempo/Decorator.ts", "../../viem/tempo/P256.ts", "../../viem/tempo/Secp256k1.ts", "../../viem/tempo/TokenIds.ts", "../../viem/tempo/Transport.ts", "../../eventemitter3/index.mjs", "../../ox/core/RpcResponse.ts", "../../ox/core/Provider.ts", "../../ox/core/RpcRequest.ts", "../../viem/tempo/WebAuthnP256.ts", "../../viem/tempo/WebCryptoP256.ts"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "// Generated with `pnpm gen:abis`. Do not modify manually.\n\nexport const tip20 = [\n  {\n    name: 'name',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'symbol',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'decimals',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint8' }],\n  },\n  {\n    name: 'totalSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'quoteToken',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'nextQuoteToken',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'balanceOf',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'transfer',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'approve',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'spender' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'allowance',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'owner' },\n      { type: 'address', name: 'spender' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'transferFrom',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'mint',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'burn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint256', name: 'amount' }],\n    outputs: [],\n  },\n  {\n    name: 'currency',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'supplyCap',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'paused',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'transferPolicyId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'burnBlocked',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'mintWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'burnWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'transferWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'transferFromWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'changeTransferPolicyId',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint64', name: 'newPolicyId' }],\n    outputs: [],\n  },\n  {\n    name: 'setSupplyCap',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint256', name: 'newSupplyCap' }],\n    outputs: [],\n  },\n  {\n    name: 'pause',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'unpause',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'setNextQuoteToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'newQuoteToken' }],\n    outputs: [],\n  },\n  {\n    name: 'completeQuoteTokenUpdate',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'PAUSE_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'UNPAUSE_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'ISSUER_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'BURN_BLOCKED_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'distributeReward',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint256', name: 'amount' }],\n    outputs: [],\n  },\n  {\n    name: 'setRewardRecipient',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'recipient' }],\n    outputs: [],\n  },\n  {\n    name: 'claimRewards',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'optedInSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'globalRewardPerToken',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'userRewardInfo',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'address', name: 'rewardRecipient' },\n          { type: 'uint256', name: 'rewardPerToken' },\n          { type: 'uint256', name: 'rewardBalance' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'getPendingRewards',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'Transfer',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Approval',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'owner', indexed: true },\n      { type: 'address', name: 'spender', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Mint',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Burn',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'BurnBlocked',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'TransferWithMemo',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo', indexed: true },\n    ],\n  },\n  {\n    name: 'TransferPolicyUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint64', name: 'newPolicyId', indexed: true },\n    ],\n  },\n  {\n    name: 'SupplyCapUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint256', name: 'newSupplyCap', indexed: true },\n    ],\n  },\n  {\n    name: 'PauseStateUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'bool', name: 'isPaused' },\n    ],\n  },\n  {\n    name: 'NextQuoteTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'nextQuoteToken', indexed: true },\n    ],\n  },\n  {\n    name: 'QuoteTokenUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'newQuoteToken', indexed: true },\n    ],\n  },\n  {\n    name: 'RewardDistributed',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'funder', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'RewardRecipientSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'holder', indexed: true },\n      { type: 'address', name: 'recipient', indexed: true },\n    ],\n  },\n  {\n    name: 'InsufficientBalance',\n    type: 'error',\n    inputs: [\n      { type: 'uint256', name: 'available' },\n      { type: 'uint256', name: 'required' },\n      { type: 'address', name: 'token' },\n    ],\n  },\n  { name: 'InsufficientAllowance', type: 'error', inputs: [] },\n  { name: 'SupplyCapExceeded', type: 'error', inputs: [] },\n  { name: 'InvalidSupplyCap', type: 'error', inputs: [] },\n  { name: 'InvalidPayload', type: 'error', inputs: [] },\n  { name: 'StringTooLong', type: 'error', inputs: [] },\n  { name: 'PolicyForbids', type: 'error', inputs: [] },\n  { name: 'InvalidRecipient', type: 'error', inputs: [] },\n  { name: 'ContractPaused', type: 'error', inputs: [] },\n  { name: 'InvalidCurrency', type: 'error', inputs: [] },\n  { name: 'InvalidQuoteToken', type: 'error', inputs: [] },\n  { name: 'TransfersDisabled', type: 'error', inputs: [] },\n  { name: 'InvalidAmount', type: 'error', inputs: [] },\n  { name: 'NoOptedInSupply', type: 'error', inputs: [] },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'ProtectedAddress', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  { name: 'Uninitialized', type: 'error', inputs: [] },\n  { name: 'InvalidTransferPolicyId', type: 'error', inputs: [] },\n  {\n    name: 'hasRole',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'bytes32', name: 'role' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'getRoleAdmin',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'role' }],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'grantRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'address', name: 'account' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'revokeRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'address', name: 'account' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'renounceRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'bytes32', name: 'role' }],\n    outputs: [],\n  },\n  {\n    name: 'setRoleAdmin',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'bytes32', name: 'adminRole' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'RoleMembershipUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'role', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'sender', indexed: true },\n      { type: 'bool', name: 'hasRole' },\n    ],\n  },\n  {\n    name: 'RoleAdminUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'role', indexed: true },\n      { type: 'bytes32', name: 'newAdminRole', indexed: true },\n      { type: 'address', name: 'sender', indexed: true },\n    ],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n] as const\n\nexport const stablecoinDex = [\n  {\n    name: 'createPair',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'base' }],\n    outputs: [{ type: 'bytes32', name: 'key' }],\n  },\n  {\n    name: 'place',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n    ],\n    outputs: [{ type: 'uint128', name: 'orderId' }],\n  },\n  {\n    name: 'placeFlip',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n      { type: 'int16', name: 'flipTick' },\n    ],\n    outputs: [{ type: 'uint128', name: 'orderId' }],\n  },\n  {\n    name: 'cancel',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint128', name: 'orderId' }],\n    outputs: [],\n  },\n  {\n    name: 'cancelStaleOrder',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint128', name: 'orderId' }],\n    outputs: [],\n  },\n  {\n    name: 'swapExactAmountIn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountIn' },\n      { type: 'uint128', name: 'minAmountOut' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountOut' }],\n  },\n  {\n    name: 'swapExactAmountOut',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountOut' },\n      { type: 'uint128', name: 'maxAmountIn' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountIn' }],\n  },\n  {\n    name: 'quoteSwapExactAmountIn',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountIn' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountOut' }],\n  },\n  {\n    name: 'quoteSwapExactAmountOut',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountOut' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountIn' }],\n  },\n  {\n    name: 'balanceOf',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'user' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'withdraw',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getOrder',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint128', name: 'orderId' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'orderId' },\n          { type: 'address', name: 'maker' },\n          { type: 'bytes32', name: 'bookKey' },\n          { type: 'bool', name: 'isBid' },\n          { type: 'int16', name: 'tick' },\n          { type: 'uint128', name: 'amount' },\n          { type: 'uint128', name: 'remaining' },\n          { type: 'uint128', name: 'prev' },\n          { type: 'uint128', name: 'next' },\n          { type: 'bool', name: 'isFlip' },\n          { type: 'int16', name: 'flipTick' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'getTickLevel',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'base' },\n      { type: 'int16', name: 'tick' },\n      { type: 'bool', name: 'isBid' },\n    ],\n    outputs: [\n      { type: 'uint128', name: 'head' },\n      { type: 'uint128', name: 'tail' },\n      { type: 'uint128', name: 'totalLiquidity' },\n    ],\n  },\n  {\n    name: 'pairKey',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [\n      { type: 'address', name: 'tokenA' },\n      { type: 'address', name: 'tokenB' },\n    ],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'nextOrderId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'books',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'pairKey' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'address', name: 'base' },\n          { type: 'address', name: 'quote' },\n          { type: 'int16', name: 'bestBidTick' },\n          { type: 'int16', name: 'bestAskTick' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'MIN_TICK',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'MAX_TICK',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'TICK_SPACING',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'PRICE_SCALE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'MIN_ORDER_AMOUNT',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'MIN_PRICE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'MAX_PRICE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'tickToPrice',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [{ type: 'int16', name: 'tick' }],\n    outputs: [{ type: 'uint32', name: 'price' }],\n  },\n  {\n    name: 'priceToTick',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [{ type: 'uint32', name: 'price' }],\n    outputs: [{ type: 'int16', name: 'tick' }],\n  },\n  {\n    name: 'PairCreated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'key', indexed: true },\n      { type: 'address', name: 'base', indexed: true },\n      { type: 'address', name: 'quote', indexed: true },\n    ],\n  },\n  {\n    name: 'OrderPlaced',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n      { type: 'bool', name: 'isFlipOrder' },\n      { type: 'int16', name: 'flipTick' },\n    ],\n  },\n  {\n    name: 'OrderFilled',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'address', name: 'taker', indexed: true },\n      { type: 'uint128', name: 'amountFilled' },\n      { type: 'bool', name: 'partialFill' },\n    ],\n  },\n  {\n    name: 'OrderCancelled',\n    type: 'event',\n    inputs: [{ type: 'uint128', name: 'orderId', indexed: true }],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'PairDoesNotExist', type: 'error', inputs: [] },\n  { name: 'PairAlreadyExists', type: 'error', inputs: [] },\n  { name: 'OrderDoesNotExist', type: 'error', inputs: [] },\n  { name: 'IdenticalTokens', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  {\n    name: 'TickOutOfBounds',\n    type: 'error',\n    inputs: [{ type: 'int16', name: 'tick' }],\n  },\n  { name: 'InvalidTick', type: 'error', inputs: [] },\n  { name: 'InvalidFlipTick', type: 'error', inputs: [] },\n  { name: 'InsufficientBalance', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidity', type: 'error', inputs: [] },\n  { name: 'InsufficientOutput', type: 'error', inputs: [] },\n  { name: 'MaxInputExceeded', type: 'error', inputs: [] },\n  {\n    name: 'BelowMinimumOrderSize',\n    type: 'error',\n    inputs: [{ type: 'uint128', name: 'amount' }],\n  },\n  { name: 'InvalidBaseToken', type: 'error', inputs: [] },\n  { name: 'OrderNotStale', type: 'error', inputs: [] },\n] as const\n\nexport const feeManager = [\n  {\n    name: 'userTokens',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'user' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'validatorTokens',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'validator' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'setUserToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [],\n  },\n  {\n    name: 'setValidatorToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [],\n  },\n  {\n    name: 'distributeFees',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'validator' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'collectedFees',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'validator' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'UserTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'user', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n    ],\n  },\n  {\n    name: 'ValidatorTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'validator', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n    ],\n  },\n  {\n    name: 'FeesDistributed',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'validator', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  { name: 'OnlyValidator', type: 'error', inputs: [] },\n  { name: 'OnlySystemContract', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  { name: 'PoolDoesNotExist', type: 'error', inputs: [] },\n  { name: 'InsufficientFeeTokenBalance', type: 'error', inputs: [] },\n  { name: 'InternalError', type: 'error', inputs: [] },\n  { name: 'CannotChangeWithinBlock', type: 'error', inputs: [] },\n  { name: 'CannotChangeWithPendingFees', type: 'error', inputs: [] },\n  { name: 'TokenPolicyForbids', type: 'error', inputs: [] },\n] as const\n\nexport const feeAmm = [\n  {\n    name: 'M',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'N',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'SCALE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'MIN_LIQUIDITY',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'getPoolId',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n    ],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'getPool',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n    ],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'reserveUserToken' },\n          { type: 'uint128', name: 'reserveValidatorToken' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'pools',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'poolId' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'reserveUserToken' },\n          { type: 'uint128', name: 'reserveValidatorToken' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'mint',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [{ type: 'uint256', name: 'liquidity' }],\n  },\n  {\n    name: 'burn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n    ],\n  },\n  {\n    name: 'totalSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'poolId' }],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'liquidityBalances',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'bytes32', name: 'poolId' },\n      { type: 'address', name: 'user' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'rebalanceSwap',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'amountOut' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [{ type: 'uint256', name: 'amountIn' }],\n  },\n  {\n    name: 'Mint',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'sender' },\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n    ],\n  },\n  {\n    name: 'Burn',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'sender', indexed: true },\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n      { type: 'address', name: 'to' },\n    ],\n  },\n  {\n    name: 'RebalanceSwap',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'address', name: 'swapper', indexed: true },\n      { type: 'uint256', name: 'amountIn' },\n      { type: 'uint256', name: 'amountOut' },\n    ],\n  },\n  { name: 'IdenticalAddresses', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidity', type: 'error', inputs: [] },\n  { name: 'InsufficientReserves', type: 'error', inputs: [] },\n  { name: 'InvalidAmount', type: 'error', inputs: [] },\n  { name: 'DivisionByZero', type: 'error', inputs: [] },\n  { name: 'InvalidSwapCalculation', type: 'error', inputs: [] },\n] as const\n\nexport const accountKeychain = [\n  {\n    name: 'authorizeKey',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'keyId' },\n      { type: 'uint8', name: 'signatureType' },\n      { type: 'uint64', name: 'expiry' },\n      { type: 'bool', name: 'enforceLimits' },\n      {\n        type: 'tuple[]',\n        name: 'limits',\n        components: [\n          { type: 'address', name: 'token' },\n          { type: 'uint256', name: 'amount' },\n        ],\n      },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'revokeKey',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'keyId' }],\n    outputs: [],\n  },\n  {\n    name: 'updateSpendingLimit',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'keyId' },\n      { type: 'address', name: 'token' },\n      { type: 'uint256', name: 'newLimit' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getKey',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'address', name: 'keyId' },\n    ],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint8', name: 'signatureType' },\n          { type: 'address', name: 'keyId' },\n          { type: 'uint64', name: 'expiry' },\n          { type: 'bool', name: 'enforceLimits' },\n          { type: 'bool', name: 'isRevoked' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'getRemainingLimit',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'address', name: 'keyId' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'getTransactionKey',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'KeyAuthorized',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n      { type: 'uint8', name: 'signatureType' },\n      { type: 'uint64', name: 'expiry' },\n    ],\n  },\n  {\n    name: 'KeyRevoked',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n    ],\n  },\n  {\n    name: 'SpendingLimitUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint256', name: 'newLimit' },\n    ],\n  },\n  { name: 'UnauthorizedCaller', type: 'error', inputs: [] },\n  { name: 'KeyAlreadyExists', type: 'error', inputs: [] },\n  { name: 'KeyNotFound', type: 'error', inputs: [] },\n  { name: 'KeyExpired', type: 'error', inputs: [] },\n  { name: 'SpendingLimitExceeded', type: 'error', inputs: [] },\n  { name: 'InvalidSignatureType', type: 'error', inputs: [] },\n  { name: 'ZeroPublicKey', type: 'error', inputs: [] },\n  { name: 'ExpiryInPast', type: 'error', inputs: [] },\n  { name: 'KeyAlreadyRevoked', type: 'error', inputs: [] },\n] as const\n\nexport const nonce = [\n  {\n    name: 'getNonce',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'uint256', name: 'nonceKey' },\n    ],\n    outputs: [{ type: 'uint64', name: 'nonce' }],\n  },\n  {\n    name: 'NonceIncremented',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'uint256', name: 'nonceKey', indexed: true },\n      { type: 'uint64', name: 'newNonce' },\n    ],\n  },\n  { name: 'ProtocolNonceNotSupported', type: 'error', inputs: [] },\n  { name: 'InvalidNonceKey', type: 'error', inputs: [] },\n  { name: 'NonceOverflow', type: 'error', inputs: [] },\n] as const\n\nexport const tip20Factory = [\n  {\n    name: 'createToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'string', name: 'name' },\n      { type: 'string', name: 'symbol' },\n      { type: 'string', name: 'currency' },\n      { type: 'address', name: 'quoteToken' },\n      { type: 'address', name: 'admin' },\n      { type: 'bytes32', name: 'salt' },\n    ],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'isTIP20',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'getTokenAddress',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'sender' },\n      { type: 'bytes32', name: 'salt' },\n    ],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'TokenCreated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'string', name: 'name' },\n      { type: 'string', name: 'symbol' },\n      { type: 'string', name: 'currency' },\n      { type: 'address', name: 'quoteToken' },\n      { type: 'address', name: 'admin' },\n      { type: 'bytes32', name: 'salt' },\n    ],\n  },\n  { name: 'AddressReserved', type: 'error', inputs: [] },\n  { name: 'AddressNotReserved', type: 'error', inputs: [] },\n  { name: 'InvalidQuoteToken', type: 'error', inputs: [] },\n  {\n    name: 'TokenAlreadyExists',\n    type: 'error',\n    inputs: [{ type: 'address', name: 'token' }],\n  },\n] as const\n\nexport const tip403Registry = [\n  {\n    name: 'policyIdCounter',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'policyExists',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint64', name: 'policyId' }],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'policyData',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint64', name: 'policyId' }],\n    outputs: [\n      { type: 'uint8', name: 'policyType' },\n      { type: 'address', name: 'admin' },\n    ],\n  },\n  {\n    name: 'isAuthorized',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'user' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'createPolicy',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'admin' },\n      { type: 'uint8', name: 'policyType' },\n    ],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'createPolicyWithAccounts',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'admin' },\n      { type: 'uint8', name: 'policyType' },\n      { type: 'address[]', name: 'accounts' },\n    ],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'setPolicyAdmin',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'admin' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'modifyPolicyWhitelist',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'account' },\n      { type: 'bool', name: 'allowed' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'modifyPolicyBlacklist',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'account' },\n      { type: 'bool', name: 'restricted' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'PolicyAdminUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'admin', indexed: true },\n    ],\n  },\n  {\n    name: 'PolicyCreated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint8', name: 'policyType' },\n    ],\n  },\n  {\n    name: 'WhitelistUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bool', name: 'allowed' },\n    ],\n  },\n  {\n    name: 'BlacklistUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bool', name: 'restricted' },\n    ],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'IncompatiblePolicyType', type: 'error', inputs: [] },\n  { name: 'PolicyNotFound', type: 'error', inputs: [] },\n] as const\n\nexport const validator = [\n  {\n    name: 'getValidators',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [\n      {\n        type: 'tuple[]',\n        name: 'validators',\n        components: [\n          { type: 'bytes32', name: 'publicKey' },\n          { type: 'bool', name: 'active' },\n          { type: 'uint64', name: 'index' },\n          { type: 'address', name: 'validatorAddress' },\n          { type: 'string', name: 'inboundAddress' },\n          { type: 'string', name: 'outboundAddress' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'addValidator',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'newValidatorAddress' },\n      { type: 'bytes32', name: 'publicKey' },\n      { type: 'bool', name: 'active' },\n      { type: 'string', name: 'inboundAddress' },\n      { type: 'string', name: 'outboundAddress' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'updateValidator',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'newValidatorAddress' },\n      { type: 'bytes32', name: 'publicKey' },\n      { type: 'string', name: 'inboundAddress' },\n      { type: 'string', name: 'outboundAddress' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'changeValidatorStatus',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'validator' },\n      { type: 'bool', name: 'active' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'owner',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'changeOwner',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'newOwner' }],\n    outputs: [],\n  },\n  {\n    name: 'getNextFullDkgCeremony',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'setNextFullDkgCeremony',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint64', name: 'epoch' }],\n    outputs: [],\n  },\n  {\n    name: 'validatorsArray',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint256', name: 'index' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'validators',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'validator' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'bytes32', name: 'publicKey' },\n          { type: 'bool', name: 'active' },\n          { type: 'uint64', name: 'index' },\n          { type: 'address', name: 'validatorAddress' },\n          { type: 'string', name: 'inboundAddress' },\n          { type: 'string', name: 'outboundAddress' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'validatorCount',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'ValidatorAlreadyExists', type: 'error', inputs: [] },\n  { name: 'ValidatorNotFound', type: 'error', inputs: [] },\n  { name: 'InvalidPublicKey', type: 'error', inputs: [] },\n  {\n    name: 'NotHostPort',\n    type: 'error',\n    inputs: [\n      { type: 'string', name: 'field' },\n      { type: 'string', name: 'input' },\n      { type: 'string', name: 'backtrace' },\n    ],\n  },\n  {\n    name: 'NotIpPort',\n    type: 'error',\n    inputs: [\n      { type: 'string', name: 'field' },\n      { type: 'string', name: 'input' },\n      { type: 'string', name: 'backtrace' },\n    ],\n  },\n] as const\n", "import * as Address from 'ox/Address'\nimport * as Hex from 'ox/Hex'\nimport * as P256 from 'ox/P256'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\nimport * as WebCryptoP256 from 'ox/WebCryptoP256'\nimport type {\n  LocalAccount,\n  Account as viem_Account,\n} from '../accounts/types.js'\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport type { TransactionSerializable } from '../types/transaction.js'\nimport type { OneOf, RequiredBy } from '../types/utils.js'\nimport { hashAuthorization } from '../utils/authorization/hashAuthorization.js'\nimport { keccak256 } from '../utils/hash/keccak256.js'\nimport { hashMessage } from '../utils/signature/hashMessage.js'\nimport { hashTypedData } from '../utils/signature/hashTypedData.js'\nimport type { SerializeTransactionFn } from '../utils/transaction/serializeTransaction.js'\nimport * as Transaction from './Transaction.js'\n\nexport type Account_base<source extends string = string> = RequiredBy<\n  LocalAccount<source>,\n  'sign' | 'signAuthorization' | 'signTransaction'\n> & {\n  /** Key type. */\n  keyType: SignatureEnvelope.Type\n  /** Sign transaction fn. */\n  signTransaction: <\n    serializer extends\n      SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<Transaction.TransactionSerializableTempo>,\n    transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n  >(\n    transaction: transaction,\n    options?:\n      | {\n          serializer?: serializer | undefined\n        }\n      | undefined,\n  ) => Promise<Hex.Hex>\n}\n\nexport type RootAccount = Account_base<'root'> & {\n  /** Sign key authorization. */\n  signKeyAuthorization: (\n    key: Pick<AccessKeyAccount, 'accessKeyAddress' | 'keyType'>,\n    parameters?: Pick<KeyAuthorization.KeyAuthorization, 'expiry' | 'limits'>,\n  ) => Promise<KeyAuthorization.Signed>\n}\n\nexport type AccessKeyAccount = Account_base<'accessKey'> & {\n  /** Access key ID. */\n  accessKeyAddress: Address.Address\n}\n\nexport type Account = OneOf<RootAccount | AccessKeyAccount>\n\n/**\n * Instantiates an Account from a headless WebAuthn credential (P256 private key).\n *\n * @example\n * ```ts\n * import { Account } from 'viem/tempo'\n *\n * const account = Account.fromHeadlessWebAuthn('0x...')\n * ```\n *\n * @param privateKey P256 private key.\n * @returns Account.\n */\nexport function fromHeadlessWebAuthn<\n  const options extends fromHeadlessWebAuthn.Options,\n>(\n  privateKey: Hex.Hex,\n  options: options | fromHeadlessWebAuthn.Options,\n): fromHeadlessWebAuthn.ReturnValue<options> {\n  const { access, rpId, origin } = options\n\n  const publicKey = P256.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'webAuthn',\n    publicKey,\n    async sign({ hash }) {\n      const { metadata, payload } = WebAuthnP256.getSignPayload({\n        ...options,\n        challenge: hash,\n        rpId,\n        origin,\n      })\n      const signature = P256.sign({\n        payload,\n        privateKey,\n        hash: true,\n      })\n      return SignatureEnvelope.serialize({\n        metadata,\n        signature,\n        publicKey,\n        type: 'webAuthn',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromHeadlessWebAuthn {\n  export type Options = Omit<\n    WebAuthnP256.getSignPayload.Options,\n    'challenge' | 'rpId' | 'origin'\n  > &\n    Pick<from.Parameters, 'access'> & {\n      rpId: string\n      origin: string\n    }\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a P256 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'viem/tempo'\n *\n * const account = Account.fromP256('0x...')\n * ```\n *\n * @param privateKey P256 private key.\n * @returns Account.\n */\nexport function fromP256<const options extends fromP256.Options>(\n  privateKey: Hex.Hex,\n  options: options | fromP256.Options = {},\n): fromP256.ReturnValue<options> {\n  const { access } = options\n  const publicKey = P256.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'p256',\n    publicKey,\n    async sign({ hash }) {\n      const signature = P256.sign({ payload: hash, privateKey })\n      return SignatureEnvelope.serialize({\n        signature,\n        publicKey,\n        type: 'p256',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromP256 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a Secp256k1 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'viem/tempo'\n *\n * const account = Account.fromSecp256k1('0x...')\n * ```\n *\n * @param privateKey Secp256k1 private key.\n * @returns Account.\n */\nexport function fromSecp256k1<const options extends fromSecp256k1.Options>(\n  privateKey: Hex.Hex,\n  options: options | fromSecp256k1.Options = {},\n): fromSecp256k1.ReturnValue<options> {\n  const { access } = options\n  const publicKey = Secp256k1.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'secp256k1',\n    publicKey,\n    async sign(parameters) {\n      const { hash } = parameters\n      const signature = Secp256k1.sign({ payload: hash, privateKey })\n      return Signature.toHex(signature)\n    },\n  }) as never\n}\n\nexport declare namespace fromSecp256k1 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a WebAuthn credential.\n *\n * @example\n *\n * ### Create Passkey + Instantiate Account\n *\n * Create a credential with `WebAuthnP256.createCredential` and then instantiate\n * a Viem Account with `Account.fromWebAuthnP256`.\n *\n * It is highly recommended to store the credential's public key in an external store\n * for future use (ie. for future calls to `WebAuthnP256.getCredential`).\n *\n * ```ts\n * import { Account, WebAuthnP256 } from 'viem/tempo'\n * import { publicKeyStore } from './store'\n *\n * // 1. Create credential\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * // 2. Instantiate account\n * const account = Account.fromWebAuthnP256(credential)\n *\n * // 3. Store public key\n * await publicKeyStore.set(credential.id, credential.publicKey)\n *\n * ```\n *\n * @example\n *\n * ### Get Credential + Instantiate Account\n *\n * Gets a credential from `WebAuthnP256.getCredential` and then instantiates\n * an account with `Account.fromWebAuthnP256`.\n *\n * The `getPublicKey` function is required to fetch the public key paired with the credential\n * from an external store. The public key is required to derive the account's address.\n *\n * ```ts\n * import { Account, WebAuthnP256 } from 'viem/tempo'\n * import { publicKeyStore } from './store'\n *\n * // 1. Get credential\n * const credential = await WebAuthnP256.getCredential({\n *   async getPublicKey(credential) {\n *     // 2. Get public key from external store.\n *     return await publicKeyStore.get(credential.id)\n *   }\n * })\n *\n * // 3. Instantiate account\n * const account = Account.fromWebAuthnP256(credential)\n * ```\n *\n * @param credential WebAuthnP256 credential.\n * @returns Account.\n */\nexport function fromWebAuthnP256(\n  credential: fromWebAuthnP256.Credential,\n  options: fromWebAuthnP256.Options = {},\n): fromWebAuthnP256.ReturnValue {\n  const { id } = credential\n  const publicKey = PublicKey.fromHex(credential.publicKey)\n  return from({\n    keyType: 'webAuthn',\n    publicKey,\n    async sign({ hash }) {\n      const { metadata, signature } = await WebAuthnP256.sign({\n        ...options,\n        challenge: hash,\n        credentialId: id,\n      })\n      return SignatureEnvelope.serialize({\n        publicKey,\n        metadata,\n        signature,\n        type: 'webAuthn',\n      })\n    },\n  })\n}\n\nexport declare namespace fromWebAuthnP256 {\n  export type Credential = {\n    id: WebAuthnP256.P256Credential['id']\n    publicKey: Hex.Hex\n  }\n\n  export type Options = {\n    getFn?: WebAuthnP256.sign.Options['getFn'] | undefined\n    rpId?: WebAuthnP256.sign.Options['rpId'] | undefined\n  }\n\n  export type ReturnValue = from.ReturnValue\n}\n\n/**\n * Instantiates an Account from a P256 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'viem/tempo'\n * import { WebCryptoP256 } from 'ox'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n *\n * const account = Account.fromWebCryptoP256(keyPair)\n * ```\n *\n * @param keyPair WebCryptoP256 key pair.\n * @returns Account.\n */\nexport function fromWebCryptoP256<\n  const options extends fromWebCryptoP256.Options,\n>(\n  keyPair: Awaited<ReturnType<typeof WebCryptoP256.createKeyPair>>,\n  options: options | fromWebCryptoP256.Options = {},\n): fromWebCryptoP256.ReturnValue<options> {\n  const { access } = options\n  const { publicKey, privateKey } = keyPair\n\n  return from({\n    access,\n    keyType: 'p256',\n    publicKey,\n    async sign({ hash }) {\n      const signature = await WebCryptoP256.sign({ payload: hash, privateKey })\n      return SignatureEnvelope.serialize({\n        signature,\n        prehash: true,\n        publicKey,\n        type: 'p256',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromWebCryptoP256 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\nexport async function signKeyAuthorization(\n  account: LocalAccount,\n  parameters: signKeyAuthorization.Parameters,\n): Promise<signKeyAuthorization.ReturnValue> {\n  const { key, expiry, limits } = parameters\n  const { accessKeyAddress, keyType: type } = key\n\n  const signature = await account.sign!({\n    hash: KeyAuthorization.getSignPayload({\n      address: accessKeyAddress,\n      expiry,\n      limits,\n      type,\n    }),\n  })\n  return KeyAuthorization.from({\n    address: accessKeyAddress,\n    expiry,\n    limits,\n    signature: SignatureEnvelope.from(signature),\n    type,\n  })\n}\n\nexport declare namespace signKeyAuthorization {\n  type Parameters = Pick<\n    KeyAuthorization.KeyAuthorization,\n    'expiry' | 'limits'\n  > & {\n    key: Pick<AccessKeyAccount, 'accessKeyAddress' | 'keyType'>\n  }\n\n  type ReturnValue = KeyAuthorization.Signed\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromBase(parameters: fromBase.Parameters): Account_base {\n  const {\n    keyType = 'secp256k1',\n    parentAddress,\n    source = 'privateKey',\n  } = parameters\n\n  const address = parentAddress ?? Address.fromPublicKey(parameters.publicKey)\n  const publicKey = PublicKey.toHex(parameters.publicKey, {\n    includePrefix: false,\n  })\n\n  async function sign({ hash }: { hash: Hex.Hex }) {\n    const signature = await parameters.sign({ hash })\n    if (parentAddress)\n      return SignatureEnvelope.serialize(\n        SignatureEnvelope.from({\n          userAddress: parentAddress,\n          inner: SignatureEnvelope.from(signature),\n          type: 'keychain',\n        }),\n      )\n    // Don't need to append magic bytes to secp256k1 signatures as they are\n    // backwards compatible with existing verification logic.\n    if (keyType === 'secp256k1') return signature\n    return Hex.concat(signature, SignatureEnvelope.magicBytes)\n  }\n\n  return {\n    address: Address.checksum(address),\n    keyType,\n    sign,\n    async signAuthorization(parameters) {\n      const { chainId, nonce } = parameters\n      const address = parameters.contractAddress ?? parameters.address\n      const signature = await sign({\n        hash: hashAuthorization({ address, chainId, nonce }),\n      })\n      const envelope = SignatureEnvelope.from(signature)\n      if (envelope.type !== 'secp256k1')\n        throw new Error(\n          'Unsupported signature type. Expected `secp256k1` but got `' +\n            envelope.type +\n            '`.',\n        )\n      const { r, s, yParity } = envelope.signature\n      return {\n        address,\n        chainId,\n        nonce,\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity,\n      }\n    },\n    async signMessage(parameters) {\n      const { message } = parameters\n      return await sign({ hash: hashMessage(message) })\n    },\n    async signTransaction(transaction, options) {\n      const { serializer = Transaction.serialize } = options ?? {}\n      const signature = await sign({\n        hash: keccak256(await serializer(transaction)),\n      })\n      const envelope = SignatureEnvelope.from(signature)\n      return await serializer(transaction, envelope as never)\n    },\n    async signTypedData(typedData) {\n      return await sign({ hash: hashTypedData(typedData) })\n    },\n    publicKey,\n    source,\n    type: 'local',\n  }\n}\n\ndeclare namespace fromBase {\n  export type Parameters = {\n    /** Parent address. */\n    parentAddress?: Address.Address | undefined\n    /** Public key. */\n    publicKey: PublicKey.PublicKey\n    /** Key type. */\n    keyType?: SignatureEnvelope.Type | undefined\n    /** Sign function. */\n    sign: NonNullable<LocalAccount['sign']>\n    /** Source. */\n    source?: string | undefined\n  }\n\n  export type ReturnValue = Account_base\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromRoot(parameters: fromRoot.Parameters): RootAccount {\n  const account = fromBase(parameters)\n  return {\n    ...account,\n    source: 'root',\n    async signKeyAuthorization(key, parameters = {}) {\n      const { expiry, limits } = parameters\n      const { accessKeyAddress, keyType: type } = key\n\n      const signature = await account.sign({\n        hash: KeyAuthorization.getSignPayload({\n          address: accessKeyAddress,\n          expiry,\n          limits,\n          type,\n        }),\n      })\n      const keyAuthorization = KeyAuthorization.from({\n        address: accessKeyAddress,\n        expiry,\n        limits,\n        signature: SignatureEnvelope.from(signature),\n        type,\n      })\n      return keyAuthorization\n    },\n  }\n}\n\ndeclare namespace fromRoot {\n  export type Parameters = fromBase.Parameters\n\n  export type ReturnValue = RootAccount\n}\n\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromAccessKey(parameters: fromAccessKey.Parameters): AccessKeyAccount {\n  const { access } = parameters\n  const { address: parentAddress } = parseAccount(access)\n  const account = fromBase({ ...parameters, parentAddress })\n  return {\n    ...account,\n    accessKeyAddress: Address.fromPublicKey(parameters.publicKey),\n    source: 'accessKey',\n  }\n}\n\ndeclare namespace fromAccessKey {\n  export type Parameters = fromBase.Parameters & {\n    /**\n     * Parent account to access.\n     * If defined, this account will act as an \"access key\", and use\n     * the parent account's address as the keychain address.\n     */\n    access: viem_Account | Address.Address\n  }\n\n  export type ReturnValue = AccessKeyAccount\n}\n\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction from<const parameters extends from.Parameters>(\n  parameters: parameters | from.Parameters,\n): from.ReturnValue<parameters> {\n  const { access } = parameters\n  if (access) return fromAccessKey(parameters) as never\n  return fromRoot(parameters) as never\n}\n\ndeclare namespace from {\n  export type Parameters = OneOf<fromRoot.Parameters | fromAccessKey.Parameters>\n\n  export type ReturnValue<\n    parameters extends {\n      access?: fromAccessKey.Parameters['access'] | undefined\n    } = {\n      access?: fromAccessKey.Parameters['access'] | undefined\n    },\n  > = parameters extends {\n    access: fromAccessKey.Parameters['access']\n  }\n    ? AccessKeyAccount\n    : RootAccount\n}\n\n// Export types required for inference.\n// biome-ignore lint/performance/noBarrelFile: _\nexport {\n  /** @deprecated */\n  KeyAuthorization as z_KeyAuthorization,\n  /** @deprecated */\n  SignatureEnvelope as z_SignatureEnvelope,\n  /** @deprecated */\n  TxEnvelopeTempo as z_TxEnvelopeTempo,\n} from 'ox/tempo'\n", "import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(\n  options: createKeyPairECDH.Options = {},\n): Promise<createKeyPairECDH.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['deriveKey', 'deriveBits'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPairECDH {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): Promise<getSharedSecret.ReturnType<as>> {\n  const { as = 'Hex', privateKey, publicKey } = options\n\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error(\n      'privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.',\n    )\n  }\n\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(publicKey),\n    { name: 'ECDH', namedCurve: 'P-256' },\n    false,\n    [],\n  )\n\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKeyCrypto,\n    },\n    privateKey,\n    256, // 32 bytes * 8 bits/byte\n  )\n\n  const sharedSecret = new Uint8Array(sharedSecretBuffer)\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation (must be a CryptoKey for ECDH).\n     */\n    privateKey: CryptoKey\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "export const accountImplementation =\n  '0x7702c00000000000000000000000000000000000'\nexport const accountRegistrar = '0x7702ac0000000000000000000000000000000000'\nexport const feeManager = '0xfeec000000000000000000000000000000000000'\nexport const nonceManager = '0x4e4F4E4345000000000000000000000000000000'\nexport const pathUsd = '0x20c0000000000000000000000000000000000000'\nexport const stablecoinDex = '0xdec0000000000000000000000000000000000000'\nexport const tip20Factory = '0x20fc000000000000000000000000000000000000'\nexport const tip403Registry = '0x403c000000000000000000000000000000000000'\nexport const validator = '0xcccccccc00000000000000000000000000000000'\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport * as amm from './amm.js'\nexport * as dex from './dex.js'\nexport * as faucet from './faucet.js'\nexport * as fee from './fee.js'\nexport * as nonce from './nonce.js'\nexport * as policy from './policy.js'\nexport * as reward from './reward.js'\nexport * as token from './token.js'\nexport * as validator from './validator.js'\n", "import type { Address } from 'abitype'\nimport { PoolId, TokenId } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport type { MulticallParameters } from '../../actions/public/multicall.js'\nimport { multicall } from '../../actions/public/multicall.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { Compute, OneOf, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Gets the reserves for a liquidity pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const pool = await Actions.amm.getPool(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The pool reserves.\n */\nexport async function getPool<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getPool.Parameters,\n): Promise<getPool.ReturnValue> {\n  const { userToken, validatorToken, ...rest } = parameters\n  const [pool, totalSupply] = await multicall(client, {\n    ...rest,\n    contracts: getPool.calls({ userToken, validatorToken }),\n    allowFailure: false,\n    deployless: true,\n  })\n  return {\n    reserveUserToken: pool.reserveUserToken,\n    reserveValidatorToken: pool.reserveValidatorToken,\n    totalSupply,\n  }\n}\n\nexport namespace getPool {\n  export type Parameters = UnionOmit<\n    MulticallParameters,\n    'allowFailure' | 'contracts' | 'deployless'\n  > &\n    Args\n\n  export type Args = {\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = Compute<{\n    /** Reserve of user token. */\n    reserveUserToken: bigint\n    /** Reserve of validator token. */\n    reserveValidatorToken: bigint\n    /** Total supply of LP tokens. */\n    totalSupply: bigint\n  }>\n\n  /**\n   * Defines calls to the `getPool` and `totalSupply` functions.\n   *\n   * @param args - Arguments.\n   * @returns The calls.\n   */\n  export function calls(args: Args) {\n    const { userToken, validatorToken } = args\n    return [\n      defineCall({\n        address: Addresses.feeManager,\n        abi: Abis.feeAmm,\n        args: [TokenId.toAddress(userToken), TokenId.toAddress(validatorToken)],\n        functionName: 'getPool',\n      }),\n      defineCall({\n        address: Addresses.feeManager,\n        abi: Abis.feeAmm,\n        args: [PoolId.from({ userToken, validatorToken })],\n        functionName: 'totalSupply',\n      }),\n    ] as const\n  }\n}\n\n/**\n * Gets the LP token balance for an account in a specific pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const poolId = await Actions.amm.getPoolId(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n *\n * const balance = await Actions.amm.getLiquidityBalance(client, {\n *   poolId,\n *   address: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The LP token balance.\n */\nexport async function getLiquidityBalance<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getLiquidityBalance.Parameters,\n): Promise<getLiquidityBalance.ReturnValue> {\n  const { address, poolId, userToken, validatorToken, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getLiquidityBalance.call({\n      address,\n      poolId,\n      userToken,\n      validatorToken,\n    } as never),\n  })\n}\n\nexport namespace getLiquidityBalance {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address to check balance for. */\n    address: Address\n  } & OneOf<\n    | {\n        /** Pool ID. */\n        poolId: Hex\n      }\n    | {\n        /** User token. */\n        userToken: TokenId.TokenIdOrAddress\n        /** Validator token. */\n        validatorToken: TokenId.TokenIdOrAddress\n      }\n  >\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.feeAmm,\n    'liquidityBalances',\n    never\n  >\n\n  /**\n   * Defines a call to the `liquidityBalances` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { address } = args\n    const poolId = (() => {\n      if ('poolId' in args && args.poolId) return args.poolId!\n      if ('userToken' in args && 'validatorToken' in args)\n        return PoolId.from({\n          userToken: args.userToken,\n          validatorToken: args.validatorToken,\n        })\n      throw new Error(\n        '`poolId`, or `userToken` and `validatorToken` must be provided.',\n      )\n    })()\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      args: [poolId, address],\n      functionName: 'liquidityBalances',\n    })\n  }\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.rebalanceSwap(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function rebalanceSwap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: rebalanceSwap.Parameters<chain, account>,\n): Promise<rebalanceSwap.ReturnValue> {\n  return rebalanceSwap.inner(writeContract, client, parameters)\n}\n\nexport namespace rebalanceSwap {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of user token to receive. */\n    amountOut: bigint\n    /** Address to send the user token to. */\n    to: Address\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: rebalanceSwap.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { userToken, validatorToken, amountOut, to, ...rest } = parameters\n    const call = rebalanceSwap.call({\n      userToken,\n      validatorToken,\n      amountOut,\n      to,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `rebalanceSwap` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.rebalanceSwap.call({\n   *       userToken: '0x20c0...beef',\n   *       validatorToken: '0x20c0...babe',\n   *       amountOut: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *     actions.amm.rebalanceSwap.call({\n   *       userToken: '0x20c0...babe',\n   *       validatorToken: '0x20c0...babe',\n   *       amountOut: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { userToken, validatorToken, amountOut, to } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'rebalanceSwap',\n      args: [\n        TokenId.toAddress(userToken),\n        TokenId.toAddress(validatorToken),\n        amountOut,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `RebalanceSwap` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RebalanceSwap` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'RebalanceSwap',\n      strict: true,\n    })\n    if (!log) throw new Error('`RebalanceSwap` event not found.')\n    return log\n  }\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.amm.rebalanceSwapSync(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function rebalanceSwapSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: rebalanceSwapSync.Parameters<chain, account>,\n): Promise<rebalanceSwapSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await rebalanceSwap.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = rebalanceSwap.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace rebalanceSwapSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = rebalanceSwap.Parameters<chain, account>\n\n  export type Args = rebalanceSwap.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'RebalanceSwap',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.mint(client, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function mint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mint.Parameters<chain, account>,\n): Promise<mint.ReturnValue> {\n  return mint.inner(writeContract, client, parameters)\n}\n\nexport namespace mint {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address to mint LP tokens to. */\n    to: Address\n    /** User token address. */\n    userTokenAddress: TokenId.TokenIdOrAddress\n    /** Validator token address. */\n    validatorTokenAddress: TokenId.TokenIdOrAddress\n    /** Amount of validator token to add. */\n    validatorTokenAmount: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: mint.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n      ...rest\n    } = parameters\n    const call = mint.call({\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `mint` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.mint.call({\n   *       userTokenAddress: '0x20c0...beef',\n   *       validatorTokenAddress: '0x20c0...babe',\n   *       validatorTokenAmount: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *     actions.amm.mint.call({\n   *       userTokenAddress: '0x20c0...babe',\n   *       validatorTokenAddress: '0x20c0...babe',\n   *       validatorTokenAmount: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const {\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n    } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'mint',\n      args: [\n        TokenId.toAddress(userTokenAddress),\n        TokenId.toAddress(validatorTokenAddress),\n        validatorTokenAmount,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `Mint` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `Mint` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'Mint',\n      strict: true,\n    })\n    if (!log) throw new Error('`Mint` event not found.')\n    return log\n  }\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.mint(client, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mintSync.Parameters<chain, account>,\n): Promise<mintSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await mint.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = mint.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace mintSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = mint.Parameters<chain, account>\n\n  export type Args = mint.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'Mint',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.burn(client, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burn.Parameters<chain, account>,\n): Promise<burn.ReturnValue> {\n  return burn.inner(writeContract, client, parameters)\n}\n\nexport namespace burn {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of LP tokens to burn. */\n    liquidity: bigint\n    /** Address to send tokens to. */\n    to: Address\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burn.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { liquidity, to, userToken, validatorToken, ...rest } = parameters\n    const call = burn.call({ liquidity, to, userToken, validatorToken })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burn` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.burn.call({\n   *       liquidity: 100n,\n   *       to: '0xfeed...fede',\n   *       userToken: '0x20c0...beef',\n   *       validatorToken: '0x20c0...babe',\n   *     }),\n   *     actions.amm.burn.call({\n   *       liquidity: 100n,\n   *       to: '0xfeed...fede',\n   *       userToken: '0x20c0...babe',\n   *       validatorToken: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { liquidity, to, userToken, validatorToken } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'burn',\n      args: [\n        TokenId.toAddress(userToken),\n        TokenId.toAddress(validatorToken),\n        liquidity,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `Burn` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `Burn` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'Burn',\n      strict: true,\n    })\n    if (!log) throw new Error('`Burn` event not found.')\n    return log\n  }\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.amm.burnSync(client, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnSync.Parameters<chain, account>,\n): Promise<burnSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burn.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burn.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burn.Parameters<chain, account>\n\n  export type Args = burn.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'Burn',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Watches for rebalance swap events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchRebalanceSwap(client, {\n *   onRebalanceSwap: (args, log) => {\n *     console.log('Rebalance swap:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRebalanceSwap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRebalanceSwap.Parameters,\n) {\n  const { onRebalanceSwap, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'RebalanceSwap',\n    args:\n      userToken !== undefined && validatorToken !== undefined\n        ? {\n            userToken: TokenId.toAddress(userToken),\n            validatorToken: TokenId.toAddress(validatorToken),\n          }\n        : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onRebalanceSwap(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRebalanceSwap {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'RebalanceSwap',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'RebalanceSwap'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'RebalanceSwap', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a rebalance swap occurs. */\n    onRebalanceSwap: (args: Args, log: Log) => void\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n\n/**\n * Watches for liquidity mint events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchMint(client, {\n *   onMint: (args, log) => {\n *     console.log('Liquidity added:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchMint.Parameters) {\n  const { onMint, to, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'Mint',\n    args: {\n      to,\n      ...(userToken !== undefined && {\n        userToken: TokenId.toAddress(userToken),\n      }),\n      ...(validatorToken !== undefined && {\n        validatorToken: TokenId.toAddress(validatorToken),\n      }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onMint(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchMint {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'Mint',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'Mint'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'Mint', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when liquidity is added. */\n    onMint: (args: Args, log: Log) => void\n    /** Address of the sender to filter events. */\n    sender?: Address | undefined\n    /** Address of the recipient to filter events. */\n    to?: Address | undefined\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n\n/**\n * Watches for liquidity burn events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchBurn(client, {\n *   onBurn: (args, log) => {\n *     console.log('Liquidity removed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchBurn.Parameters) {\n  const { onBurn, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'Burn',\n    args:\n      userToken !== undefined && validatorToken !== undefined\n        ? {\n            userToken: TokenId.toAddress(userToken),\n            validatorToken: TokenId.toAddress(validatorToken),\n          }\n        : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onBurn(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBurn {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'Burn',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'Burn'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'Burn', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when liquidity is removed. */\n    onBurn: (args: Args, log: Log) => void\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n", "import type { Abi, AbiStateMutability, Address } from 'abitype'\nimport type {\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ExtractAbiItem,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { encodeFunctionData } from '../../utils/index.js'\n\nexport function defineCall<\n  const abi extends Abi,\n  const functionName extends ContractFunctionName<abi, AbiStateMutability>,\n  call extends ContractFunctionParameters<\n    abi,\n    AbiStateMutability,\n    functionName\n  >,\n>(\n  call:\n    | call\n    | ContractFunctionParameters<abi, AbiStateMutability, functionName>,\n): ContractFunctionParameters<\n  [ExtractAbiItem<abi, functionName>],\n  AbiStateMutability,\n  functionName\n> & {\n  data: Hex\n  to: Address\n} {\n  return {\n    ...(call as any),\n    data: encodeFunctionData(call as never),\n    to: call.address,\n  } as const\n}\n\n/**\n * Normalizes a value into a structured-clone compatible format.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\n * @internal\n */\nexport function normalizeValue<type>(value: type): type {\n  if (Array.isArray(value)) return value.map(normalizeValue) as never\n  if (typeof value === 'function') return undefined as never\n  if (typeof value !== 'object' || value === null) return value\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    try {\n      return structuredClone(value)\n    } catch {\n      return undefined as never\n    }\n\n  const normalized: Record<string, unknown> = {}\n  for (const [k, v] of Object.entries(value)) normalized[k] = normalizeValue(v)\n  return normalized as never\n}\n", "import type { Address } from 'abitype'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport {\n  type ReadContractReturnType,\n  readContract,\n} from '../../actions/public/readContract.js'\nimport {\n  type WatchContractEventParameters,\n  watchContractEvent,\n} from '../../actions/public/watchContractEvent.js'\nimport {\n  type WriteContractReturnType,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Order type for limit orders.\n */\ntype OrderType = 'buy' | 'sell'\n\n/**\n * Buys a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.buy(client, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function buy<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: buy.Parameters<chain, account>,\n): Promise<buy.ReturnValue> {\n  return buy.inner(writeContract, client, parameters)\n}\n\nexport namespace buy {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokenOut to buy. */\n    amountOut: bigint\n    /** Maximum amount of tokenIn to spend. */\n    maxAmountIn: bigint\n    /** Address of the token to spend. */\n    tokenIn: Address\n    /** Address of the token to buy. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: buy.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { tokenIn, tokenOut, amountOut, maxAmountIn, ...rest } = parameters\n    const call = buy.call({ tokenIn, tokenOut, amountOut, maxAmountIn })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `swapExactAmountOut` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.buy.call({\n   *       tokenIn: '0x20c0...beef',\n   *       tokenOut: '0x20c0...babe',\n   *       amountOut: parseUnits('100', 6),\n   *       maxAmountIn: parseUnits('105', 6),\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountOut, maxAmountIn } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'swapExactAmountOut',\n      args: [tokenIn, tokenOut, amountOut, maxAmountIn],\n    })\n  }\n}\n\n/**\n * Buys a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.buySync(client, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function buySync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: buySync.Parameters<chain, account>,\n): Promise<buySync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await buy.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace buySync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = buy.Parameters<chain, account>\n\n  export type Args = buy.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.cancel(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function cancel<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancel.Parameters<chain, account>,\n): Promise<cancel.ReturnValue> {\n  return cancel.inner(writeContract, client, parameters)\n}\n\nexport namespace cancel {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Order ID to cancel. */\n    orderId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: cancel.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { orderId, ...rest } = parameters\n    const call = cancel.call({ orderId })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `cancel` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.cancel.call({\n   *       orderId: 123n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { orderId } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'cancel',\n      args: [orderId],\n    })\n  }\n\n  /**\n   * Extracts the `OrderCancelled` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderCancelled` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinDex,\n      logs,\n      eventName: 'OrderCancelled',\n      strict: true,\n    })\n    if (!log) throw new Error('`OrderCancelled` event not found.')\n    return log\n  }\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.cancelSync(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function cancelSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancelSync.Parameters<chain, account>,\n): Promise<cancelSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await cancel.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = cancel.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace cancelSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = cancel.Parameters<chain, account>\n\n  export type Args = cancel.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinDex,\n      'OrderCancelled',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Cancels a stale order from the orderbook.\n *\n * A stale order is one where the owner's balance or allowance has dropped\n * below the order amount.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.cancelStale(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function cancelStale<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancelStale.Parameters<chain, account>,\n): Promise<cancelStale.ReturnValue> {\n  return cancelStale.inner(writeContract, client, parameters)\n}\n\nexport namespace cancelStale {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Order ID to cancel. */\n    orderId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: cancelStale.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { orderId, ...rest } = parameters\n    const call = cancelStale.call({ orderId })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `cancelStaleOrder` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.cancelStale.call({\n   *       orderId: 123n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { orderId } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'cancelStaleOrder',\n      args: [orderId],\n    })\n  }\n\n  /**\n   * Extracts the `OrderCancelled` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderCancelled` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinDex,\n      logs,\n      eventName: 'OrderCancelled',\n      strict: true,\n    })\n    if (!log) throw new Error('`OrderCancelled` event not found.')\n    return log\n  }\n}\n\n/**\n * Cancels a stale order from the orderbook and waits for confirmation.\n *\n * A stale order is one where the owner's balance or allowance has dropped\n * below the order amount.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.cancelStaleSync(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function cancelStaleSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancelStaleSync.Parameters<chain, account>,\n): Promise<cancelStaleSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await cancelStale.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = cancelStale.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace cancelStaleSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = cancelStale.Parameters<chain, account>\n\n  export type Args = cancelStale.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinDex,\n      'OrderCancelled',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.createPair(client, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function createPair<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createPair.Parameters<chain, account>,\n): Promise<createPair.ReturnValue> {\n  return createPair.inner(writeContract, client, parameters)\n}\n\nexport namespace createPair {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address of the base token for the pair. */\n    base: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: createPair.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { base, ...rest } = parameters\n    const call = createPair.call({ base })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `createPair` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.createPair.call({\n   *       base: '0x20c0...beef',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'createPair',\n      args: [base],\n    })\n  }\n\n  /**\n   * Extracts the `PairCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PairCreated` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinDex,\n      logs,\n      eventName: 'PairCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PairCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.createPairSync(client, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createPairSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createPairSync.Parameters<chain, account>,\n): Promise<createPairSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await createPair.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = createPair.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace createPairSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = createPair.Parameters<chain, account>\n\n  export type Args = createPair.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinDex,\n      'PairCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets a user's token balance on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const balance = await Actions.dex.getBalance(client, {\n *   account: '0x...',\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The user's token balance on the DEX.\n */\nexport async function getBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getBalance.Parameters<account>,\n): Promise<getBalance.ReturnValue> {\n  const { account: acc = client.account, token, ...rest } = parameters\n  const address = acc ? parseAccount(acc).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...rest,\n    ...getBalance.call({ account: address, token }),\n  })\n}\n\nexport namespace getBalance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Args\n\n  export type Args = {\n    /** Address of the account. */\n    account: Address\n    /** Address of the token. */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinDex,\n    'balanceOf',\n    never\n  >\n\n  /**\n   * Defines a call to the `balanceOf` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [account, token],\n      functionName: 'balanceOf',\n    })\n  }\n}\n\n/**\n * Gets the quote for buying a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const amountIn = await Actions.dex.getBuyQuote(client, {\n *   amountOut: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount of tokenIn needed to buy the specified amountOut.\n */\nexport async function getBuyQuote<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getBuyQuote.Parameters,\n): Promise<getBuyQuote.ReturnValue> {\n  const { tokenIn, tokenOut, amountOut, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getBuyQuote.call({ tokenIn, tokenOut, amountOut }),\n  })\n}\n\nexport namespace getBuyQuote {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Amount of tokenOut to buy. */\n    amountOut: bigint\n    /** Address of the token to spend. */\n    tokenIn: Address\n    /** Address of the token to buy. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinDex,\n    'quoteSwapExactAmountOut',\n    never\n  >\n\n  /**\n   * Defines a call to the `quoteSwapExactAmountOut` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountOut } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [tokenIn, tokenOut, amountOut],\n      functionName: 'quoteSwapExactAmountOut',\n    })\n  }\n}\n\n/**\n * Gets an order's details from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const order = await Actions.dex.getOrder(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The order details.\n */\nexport async function getOrder<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getOrder.Parameters,\n): Promise<getOrder.ReturnValue> {\n  const { orderId, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getOrder.call({ orderId }),\n  })\n}\n\nexport namespace getOrder {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Order ID to query. */\n    orderId: bigint\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinDex,\n    'getOrder',\n    never\n  >\n\n  /**\n   * Defines a call to the `getOrder` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { orderId } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [orderId],\n      functionName: 'getOrder',\n    })\n  }\n}\n\n/**\n * Gets orderbook information for a trading pair.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const book = await Actions.dex.getOrderbook(client, {\n *   base: '0x20c...11',\n *   quote: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The orderbook information.\n */\nexport async function getOrderbook<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getOrderbook.Parameters,\n): Promise<getOrderbook.ReturnValue> {\n  const { base, quote, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getOrderbook.call({ base, quote }),\n  })\n}\n\nexport namespace getOrderbook {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address of the base token. */\n    base: Address\n    /** Address of the quote token. */\n    quote: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinDex,\n    'books',\n    never\n  >\n\n  /**\n   * Defines a call to the `books` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base, quote } = args\n    const pairKey = getPairKey(base, quote)\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [pairKey],\n      functionName: 'books',\n    })\n  }\n}\n\n/**\n * Gets the price level information at a specific tick.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const level = await Actions.dex.getTickLevel(client, {\n *   base: '0x20c...11',\n *   tick: Tick.fromPrice('1.001'),\n *   isBid: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The price level information.\n */\nexport async function getTickLevel<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getTickLevel.Parameters,\n): Promise<getTickLevel.ReturnValue> {\n  const { base, tick, isBid, ...rest } = parameters\n  const [head, tail, totalLiquidity] = await readContract(client, {\n    ...rest,\n    ...getTickLevel.call({ base, tick, isBid }),\n  })\n  return { head, tail, totalLiquidity }\n}\n\nexport namespace getTickLevel {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address of the base token. */\n    base: Address\n    /** Whether to query the bid side (true) or ask side (false). */\n    isBid: boolean\n    /** Price tick to query. */\n    tick: number\n  }\n\n  export type ReturnValue = {\n    /** Order ID of the first order at this tick (0 if empty) */\n    head: bigint\n    /** Order ID of the last order at this tick (0 if empty) */\n    tail: bigint\n    /** Total liquidity available at this tick level */\n    totalLiquidity: bigint\n  }\n\n  /**\n   * Defines a call to the `getTickLevel` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base, tick, isBid } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [base, tick, isBid],\n      functionName: 'getTickLevel',\n    })\n  }\n}\n\n/**\n * Gets the quote for selling a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const amountOut = await Actions.dex.getSellQuote(client, {\n *   amountIn: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount of tokenOut received for selling the specified amountIn.\n */\nexport async function getSellQuote<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getSellQuote.Parameters,\n): Promise<getSellQuote.ReturnValue> {\n  const { tokenIn, tokenOut, amountIn, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getSellQuote.call({ tokenIn, tokenOut, amountIn }),\n  })\n}\n\nexport namespace getSellQuote {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Amount of tokenIn to sell. */\n    amountIn: bigint\n    /** Address of the token to sell. */\n    tokenIn: Address\n    /** Address of the token to receive. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinDex,\n    'quoteSwapExactAmountIn',\n    never\n  >\n\n  /**\n   * Defines a call to the `quoteSwapExactAmountIn` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountIn } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      args: [tokenIn, tokenOut, amountIn],\n      functionName: 'quoteSwapExactAmountIn',\n    })\n  }\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.place(client, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function place<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: place.Parameters<chain, account>,\n): Promise<place.ReturnValue> {\n  return place.inner(writeContract, client, parameters)\n}\n\nexport namespace place {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to place in the order. */\n    amount: bigint\n    /** Price tick for the order. */\n    tick: number\n    /** Address of the base token. */\n    token: Address\n    /** Order type - 'buy' to buy the token, 'sell' to sell it. */\n    type: OrderType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: place.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, token, type, tick, ...rest } = parameters\n    const call = place.call({ amount, token, type, tick })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `place` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions, Tick } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.place.call({\n   *       amount: parseUnits('100', 6),\n   *       tick: Tick.fromPrice('0.99'),\n   *       token: '0x20c0...beef',\n   *       type: 'buy',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount, type, tick } = args\n    const isBid = type === 'buy'\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'place',\n      args: [token, amount, isBid, tick],\n    })\n  }\n\n  /**\n   * Extracts the `OrderPlaced` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderPlaced` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinDex,\n      logs,\n      eventName: 'OrderPlaced',\n      strict: true,\n    })\n    if (!log) throw new Error('`OrderPlaced` event not found.')\n    return log\n  }\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.placeFlip(client, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function placeFlip<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeFlip.Parameters<chain, account>,\n): Promise<placeFlip.ReturnValue> {\n  return placeFlip.inner(writeContract, client, parameters)\n}\n\nexport namespace placeFlip {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to place in the order. */\n    amount: bigint\n    /** Target tick to flip to when order is filled. */\n    flipTick: number\n    /** Price tick for the order. */\n    tick: number\n    /** Address of the base token. */\n    token: Address\n    /** Order type - 'buy' to buy the token, 'sell' to sell it. */\n    type: OrderType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: placeFlip.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, flipTick, tick, token, type, ...rest } = parameters\n    const call = placeFlip.call({ amount, flipTick, tick, token, type })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `placeFlip` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions, Tick } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.placeFlip.call({\n   *       amount: parseUnits('100', 6),\n   *       flipTick: Tick.fromPrice('1.01'),\n   *       tick: Tick.fromPrice('0.99'),\n   *       token: '0x20c0...beef',\n   *       type: 'buy',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount, type, tick, flipTick } = args\n    const isBid = type === 'buy'\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'placeFlip',\n      args: [token, amount, isBid, tick, flipTick],\n    })\n  }\n\n  /**\n   * Extracts the `OrderPlaced` event (with `isFlipOrder: true`) from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderPlaced` event for a flip order.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const parsedLogs = parseEventLogs({\n      abi: Abis.stablecoinDex,\n      logs,\n      eventName: 'OrderPlaced',\n      strict: true,\n    })\n    const log = parsedLogs.find((l) => l.args.isFlipOrder)\n    if (!log) throw new Error('`OrderPlaced` event (flip order) not found.')\n    return log\n  }\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.placeFlipSync(client, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeFlipSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeFlipSync.Parameters<chain, account>,\n): Promise<placeFlipSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await placeFlip.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = placeFlip.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace placeFlipSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = placeFlip.Parameters<chain, account>\n\n  export type Args = placeFlip.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinDex,\n      'OrderPlaced',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.placeSync(client, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeSync.Parameters<chain, account>,\n): Promise<placeSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await place.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = place.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace placeSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = place.Parameters<chain, account>\n\n  export type Args = place.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinDex,\n      'OrderPlaced',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.sell(client, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function sell<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: sell.Parameters<chain, account>,\n): Promise<sell.ReturnValue> {\n  return sell.inner(writeContract, client, parameters)\n}\n\nexport namespace sell {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokenIn to sell. */\n    amountIn: bigint\n    /** Minimum amount of tokenOut to receive. */\n    minAmountOut: bigint\n    /** Address of the token to sell. */\n    tokenIn: Address\n    /** Address of the token to receive. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: sell.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { tokenIn, tokenOut, amountIn, minAmountOut, ...rest } = parameters\n    const call = sell.call({ tokenIn, tokenOut, amountIn, minAmountOut })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `swapExactAmountIn` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.sell.call({\n   *       amountIn: parseUnits('100', 6),\n   *       minAmountOut: parseUnits('95', 6),\n   *       tokenIn: '0x20c0...beef',\n   *       tokenOut: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountIn, minAmountOut } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'swapExactAmountIn',\n      args: [tokenIn, tokenOut, amountIn, minAmountOut],\n    })\n  }\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.sellSync(client, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function sellSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: sellSync.Parameters<chain, account>,\n): Promise<sellSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await sell.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace sellSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = sell.Parameters<chain, account>\n\n  export type Args = sell.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for flip order placed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchFlipOrderPlaced(client, {\n *   onFlipOrderPlaced: (args, log) => {\n *     console.log('Flip order placed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchFlipOrderPlaced<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchFlipOrderPlaced.Parameters,\n) {\n  const { onFlipOrderPlaced, maker, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinDex,\n    abi: Abis.stablecoinDex,\n    eventName: 'OrderPlaced',\n    args: {\n      ...(maker !== undefined && { maker }),\n      ...(token !== undefined && { token }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) {\n        if (log.args.isFlipOrder) onFlipOrderPlaced(log.args, log)\n      }\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchFlipOrderPlaced {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinDex,\n    'OrderPlaced',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinDex, 'OrderPlaced'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinDex,\n      'OrderPlaced',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when a flip order is placed. */\n    onFlipOrderPlaced: (args: Args, log: Log) => void\n    /** Address of the token to filter events. */\n    token?: Address | undefined\n  }\n}\n\n/**\n * Watches for order cancelled events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderCancelled(client, {\n *   onOrderCancelled: (args, log) => {\n *     console.log('Order cancelled:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderCancelled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderCancelled.Parameters,\n) {\n  const { onOrderCancelled, orderId, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinDex,\n    abi: Abis.stablecoinDex,\n    eventName: 'OrderCancelled',\n    args: orderId !== undefined ? { orderId } : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onOrderCancelled(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderCancelled {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinDex,\n    'OrderCancelled',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinDex, 'OrderCancelled'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinDex,\n      'OrderCancelled',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when an order is cancelled. */\n    onOrderCancelled: (args: Args, log: Log) => void\n    /** Order ID to filter events. */\n    orderId?: bigint | undefined\n  }\n}\n\n/**\n * Watches for order filled events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderFilled(client, {\n *   onOrderFilled: (args, log) => {\n *     console.log('Order filled:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderFilled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderFilled.Parameters,\n) {\n  const { onOrderFilled, maker, taker, orderId, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinDex,\n    abi: Abis.stablecoinDex,\n    eventName: 'OrderFilled',\n    args: {\n      ...(orderId !== undefined && { orderId }),\n      ...(maker !== undefined && { maker }),\n      ...(taker !== undefined && { taker }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onOrderFilled(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderFilled {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinDex,\n    'OrderFilled',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinDex, 'OrderFilled'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinDex,\n      'OrderFilled',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when an order is filled. */\n    onOrderFilled: (args: Args, log: Log) => void\n    /** Order ID to filter events. */\n    orderId?: bigint | undefined\n    /** Address of the taker to filter events. */\n    taker?: Address | undefined\n  }\n}\n\n/**\n * Watches for order placed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderPlaced(client, {\n *   onOrderPlaced: (args, log) => {\n *     console.log('Order placed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderPlaced<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderPlaced.Parameters,\n) {\n  const { onOrderPlaced, maker, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinDex,\n    abi: Abis.stablecoinDex,\n    eventName: 'OrderPlaced',\n    args: {\n      ...(maker !== undefined && { maker }),\n      ...(token !== undefined && { token }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onOrderPlaced(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderPlaced {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinDex,\n    'OrderPlaced',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinDex, 'OrderPlaced'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinDex,\n      'OrderPlaced',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when an order is placed. */\n    onOrderPlaced: (args: Args, log: Log) => void\n    /** Address of the token to filter events. */\n    token?: Address | undefined\n  }\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.withdraw(client, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function withdraw<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: withdraw.Parameters<chain, account>,\n): Promise<withdraw.ReturnValue> {\n  return withdraw.inner(writeContract, client, parameters)\n}\n\nexport namespace withdraw {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount to withdraw. */\n    amount: bigint\n    /** Address of the token to withdraw. */\n    token: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: withdraw.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, amount, ...rest } = parameters\n    const call = withdraw.call({ token, amount })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `withdraw` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.withdraw.call({\n   *       amount: parseUnits('100', 6),\n   *       token: '0x20c0...beef',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount } = args\n    return defineCall({\n      address: Addresses.stablecoinDex,\n      abi: Abis.stablecoinDex,\n      functionName: 'withdraw',\n      args: [token, amount],\n    })\n  }\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.withdrawSync(client, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function withdrawSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: withdrawSync.Parameters<chain, account>,\n): Promise<withdrawSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await withdraw.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace withdrawSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = withdraw.Parameters<chain, account>\n\n  export type Args = withdraw.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\nfunction getPairKey(base: Address, quote: Address) {\n  return Hash.keccak256(Hex.concat(base, quote))\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { waitForTransactionReceipt } from '../../actions/public/waitForTransactionReceipt.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hashes = await Actions.faucet.fund(client, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function fund<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: fund.Parameters,\n): Promise<fund.ReturnValue> {\n  const account = parseAccount(parameters.account)\n  return client.request<{\n    Method: 'tempo_fundAddress'\n    Parameters: [address: Address]\n    ReturnType: readonly Hash[]\n  }>({\n    method: 'tempo_fundAddress',\n    params: [account.address],\n  })\n}\n\nexport declare namespace fund {\n  export type Parameters = {\n    /** Account to fund. */\n    account: Account | Address\n  }\n\n  export type ReturnValue = readonly Hash[]\n}\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet. Waits for the transactions to be included\n * on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hashes = await Actions.faucet.fundSync(client, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function fundSync<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: fundSync.Parameters,\n): Promise<fundSync.ReturnValue> {\n  const { timeout = 10_000 } = parameters\n  const account = parseAccount(parameters.account)\n  const hashes = await client.request<{\n    Method: 'tempo_fundAddress'\n    Parameters: [address: Address]\n    ReturnType: readonly Hash[]\n  }>({\n    method: 'tempo_fundAddress',\n    params: [account.address],\n  })\n  const receipts = await Promise.all(\n    hashes.map((hash) =>\n      waitForTransactionReceipt(client, {\n        hash,\n        checkReplacement: false,\n        timeout,\n      }),\n    ),\n  )\n  return receipts\n}\n\nexport declare namespace fundSync {\n  export type Parameters = {\n    /** Account to fund. */\n    account: Account | Address\n    /** Timeout. */\n    timeout?: number | undefined\n  }\n\n  export type ReturnValue = readonly TransactionReceipt[]\n}\n", "import type { Address } from 'abitype'\nimport { TokenId } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { zeroAddress } from '../../constants/address.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Gets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { address, id } = await Actions.fee.getUserToken(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function getUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  ...parameters: account extends Account\n    ? [getUserToken.Parameters<account>] | []\n    : [getUserToken.Parameters<account>]\n): Promise<getUserToken.ReturnValue> {\n  const { account: account_ = client.account, ...rest } = parameters[0] ?? {}\n  if (!account_) throw new Error('account is required.')\n  const account = parseAccount(account_)\n  const address = await readContract(client, {\n    ...rest,\n    ...getUserToken.call({ account: account.address }),\n  })\n  if (address === zeroAddress) return null\n  return {\n    address,\n    id: TokenId.fromAddress(address),\n  }\n}\n\nexport namespace getUserToken {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account>\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n  }\n\n  export type ReturnValue = Compute<{\n    address: Address\n    id: bigint\n  } | null>\n\n  /**\n   * Defines a call to the `userTokens` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      args: [account],\n      functionName: 'userTokens',\n    })\n  }\n}\n\n/**\n * Sets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.fee.setUserToken(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setUserToken.Parameters<chain, account>,\n): Promise<setUserToken.ReturnValue> {\n  return setUserToken.inner(writeContract, client, parameters)\n}\n\nexport namespace setUserToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setUserToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = setUserToken.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setUserToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.fee.setUserToken.call({\n   *       token: '0x20c0...beef',\n   *     }),\n   *     actions.fee.setUserToken.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      functionName: 'setUserToken',\n      args: [TokenId.toAddress(token)],\n    })\n  }\n\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeManager,\n      logs,\n      eventName: 'UserTokenSet',\n      strict: true,\n    })\n    if (!log) throw new Error('`UserTokenSet` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.fee.setUserTokenSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setUserTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setUserTokenSync.Parameters<chain, account>,\n): Promise<setUserTokenSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setUserToken.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setUserToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setUserTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setUserToken.Parameters<chain, account>\n\n  export type Args = setUserToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeManager,\n      'UserTokenSet',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for user token set events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.fee.watchSetUserToken(client, {\n *   onUserTokenSet: (args, log) => {\n *     console.log('User token set:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchSetUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchSetUserToken.Parameters,\n) {\n  const { onUserTokenSet, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeManager,\n    eventName: 'UserTokenSet',\n    onLogs: (logs) => {\n      for (const log of logs) onUserTokenSet(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchSetUserToken {\n  export type Args = GetEventArgs<\n    typeof Abis.feeManager,\n    'UserTokenSet',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeManager, 'UserTokenSet'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeManager, 'UserTokenSet', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a user token is set. */\n    onUserTokenSet: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Gets the validator's preferred fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { address, id } = await Actions.fee.getValidatorToken(client, {\n *   validator: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The validator's preferred fee token, or null if not set.\n */\nexport async function getValidatorToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getValidatorToken.Parameters,\n): Promise<getValidatorToken.ReturnValue> {\n  const { validator, ...rest } = parameters\n  const address = await readContract(client, {\n    ...rest,\n    ...getValidatorToken.call({ validator }),\n  })\n  if (address === zeroAddress) return null\n  return {\n    address,\n    id: TokenId.fromAddress(address),\n  }\n}\n\nexport namespace getValidatorToken {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Validator address. */\n    validator: Address\n  }\n\n  export type ReturnValue = Compute<{\n    address: Address\n    id: bigint\n  } | null>\n\n  /**\n   * Defines a call to the `validatorTokens` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { validator } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      args: [validator],\n      functionName: 'validatorTokens',\n    })\n  }\n}\n\n/**\n * Sets the validator's preferred fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.fee.setValidatorToken(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setValidatorToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setValidatorToken.Parameters<chain, account>,\n): Promise<setValidatorToken.ReturnValue> {\n  return setValidatorToken.inner(writeContract, client, parameters)\n}\n\nexport namespace setValidatorToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setValidatorToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = setValidatorToken.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setValidatorToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.fee.setValidatorToken.call({\n   *       token: '0x20c0...beef',\n   *     }),\n   *     actions.fee.setValidatorToken.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      functionName: 'setValidatorToken',\n      args: [TokenId.toAddress(token)],\n    })\n  }\n\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeManager,\n      logs,\n      eventName: 'ValidatorTokenSet',\n      strict: true,\n    })\n    if (!log) throw new Error('`ValidatorTokenSet` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the validator's preferred fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.fee.setValidatorTokenSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setValidatorTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setValidatorTokenSync.Parameters<chain, account>,\n): Promise<setValidatorTokenSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setValidatorToken.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setValidatorToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setValidatorTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setValidatorToken.Parameters<chain, account>\n\n  export type Args = setValidatorToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeManager,\n      'ValidatorTokenSet',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for validator token set events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.fee.watchSetValidatorToken(client, {\n *   onValidatorTokenSet: (args, log) => {\n *     console.log('Validator token set:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchSetValidatorToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchSetValidatorToken.Parameters,\n) {\n  const { onValidatorTokenSet, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeManager,\n    eventName: 'ValidatorTokenSet',\n    onLogs: (logs) => {\n      for (const log of logs) onValidatorTokenSet(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchSetValidatorToken {\n  export type Args = GetEventArgs<\n    typeof Abis.feeManager,\n    'ValidatorTokenSet',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeManager, 'ValidatorTokenSet'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.feeManager,\n      'ValidatorTokenSet',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a validator token is set. */\n    onValidatorTokenSet: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log as viem_Log } from '../../types/log.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Gets the nonce for an account and nonce key.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const nonce = await Actions.nonce.getNonce(client, {\n *   account: '0x...',\n *   nonceKey: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The nonce value.\n */\nexport async function getNonce<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getNonce.Parameters,\n): Promise<getNonce.ReturnValue> {\n  const { account, nonceKey, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getNonce.call({ account, nonceKey }),\n  })\n}\n\nexport namespace getNonce {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Nonce key (must be > 0, key 0 is reserved for protocol nonces). */\n    nonceKey: bigint\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.nonce,\n    'getNonce',\n    never\n  >\n\n  /**\n   * Defines a call to the `getNonce` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [\n   *     Actions.nonce.getNonce.call({ account: '0x...', nonceKey: 1n }),\n   *     Actions.nonce.getNonce.call({ account: '0x...', nonceKey: 2n }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, nonceKey } = args\n    return defineCall({\n      address: Addresses.nonceManager,\n      abi: Abis.nonce,\n      args: [account, nonceKey],\n      functionName: 'getNonce',\n    })\n  }\n}\n\nexport function watchNonceIncremented<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchNonceIncremented.Parameters,\n) {\n  const { onNonceIncremented, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.nonceManager,\n    abi: Abis.nonce,\n    eventName: 'NonceIncremented',\n    onLogs: (logs) => {\n      for (const log of logs) onNonceIncremented(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchNonceIncremented {\n  export type Args = GetEventArgs<\n    typeof Abis.nonce,\n    'NonceIncremented',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.nonce, 'NonceIncremented'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.nonce, 'NonceIncremented', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a nonce is incremented. */\n    onNonceIncremented: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\nexport type PolicyType = 'whitelist' | 'blacklist'\n\nconst policyTypeMap = {\n  whitelist: 0,\n  blacklist: 1,\n} as const\n\n/**\n * Creates a new policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { hash, policyId } = await Actions.policy.create(client, {\n *   admin: '0x...',\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash and policy ID.\n */\nexport async function create<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: create.Parameters<chain, account>,\n): Promise<create.ReturnValue> {\n  return create.inner(writeContract, client, parameters)\n}\n\nexport namespace create {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'admin'> & {\n      /** Address of the policy admin. */\n      admin?: Address | undefined\n    }\n\n  export type Args = {\n    /** Optional array of accounts to initialize the policy with. */\n    addresses?: readonly Address[] | undefined\n    /** Address of the policy admin. */\n    admin: Address\n    /** Type of policy to create. */\n    type: PolicyType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      account = client.account,\n      addresses,\n      chain = client.chain,\n      type,\n      ...rest\n    } = parameters\n\n    if (!account) throw new Error('`account` is required')\n\n    const admin = parseAccount(account).address!\n\n    const call = create.call({ admin, type, addresses })\n    return action(client, {\n      ...rest,\n      account,\n      chain,\n      ...call,\n    } as never) as never\n  }\n\n  /**\n   * Defines a call to the `createPolicy` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.create.call({\n   *       admin: '0xfeed...fede',\n   *       type: 'whitelist',\n   *     }),\n   *     actions.policy.create.call({\n   *       admin: '0xfeed...fede',\n   *       type: 'blacklist',\n   *       addresses: ['0x20c0...beef', '0x20c0...babe'],\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { admin, type, addresses } = args\n    const config = (() => {\n      if (addresses)\n        return {\n          functionName: 'createPolicyWithAccounts',\n          args: [admin, policyTypeMap[type], addresses],\n        } as const\n      return {\n        functionName: 'createPolicy',\n        args: [admin, policyTypeMap[type]],\n      } as const\n    })()\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      ...config,\n    })\n  }\n\n  /**\n   * Extracts the `PolicyCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PolicyCreated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'PolicyCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PolicyCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.createSync(client, {\n *   admin: '0x...',\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createSync.Parameters<chain, account>,\n): Promise<createSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await create.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = create.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace createSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = create.Parameters<chain, account>\n\n  export type Args = create.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'PolicyCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the admin for a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.setAdmin(client, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setAdmin<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setAdmin.Parameters<chain, account>,\n): Promise<setAdmin.ReturnValue> {\n  return setAdmin.inner(writeContract, client, parameters)\n}\n\nexport namespace setAdmin {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New admin address. */\n    admin: Address\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setAdmin.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { policyId, admin, ...rest } = parameters\n    const call = setAdmin.call({ policyId, admin })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setPolicyAdmin` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.setAdmin.call({\n   *       policyId: 2n,\n   *       admin: '0xfeed...fede',\n   *     }),\n   *     actions.policy.setAdmin.call({\n   *       policyId: 3n,\n   *       admin: '0xfeed...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, admin } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'setPolicyAdmin',\n      args: [policyId, admin],\n    })\n  }\n\n  /**\n   * Extracts the `PolicyAdminUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PolicyAdminUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'PolicyAdminUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PolicyAdminUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the admin for a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.setAdminSync(client, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setAdminSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setAdminSync.Parameters<chain, account>,\n): Promise<setAdminSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setAdmin.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setAdmin.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setAdminSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setAdmin.Parameters<chain, account>\n\n  export type Args = setAdmin.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'PolicyAdminUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.modifyWhitelist(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function modifyWhitelist<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyWhitelist.Parameters<chain, account>,\n): Promise<modifyWhitelist.ReturnValue> {\n  return modifyWhitelist.inner(writeContract, client, parameters)\n}\n\nexport namespace modifyWhitelist {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Target account address. */\n    address: Address\n    /** Whether the account is allowed. */\n    allowed: boolean\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: modifyWhitelist.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { address: targetAccount, allowed, policyId, ...rest } = parameters\n    const call = modifyWhitelist.call({\n      address: targetAccount,\n      allowed,\n      policyId,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `modifyPolicyWhitelist` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.modifyWhitelist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...beef',\n   *       allowed: true,\n   *     }),\n   *     actions.policy.modifyWhitelist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...babe',\n   *       allowed: false,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, address, allowed } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'modifyPolicyWhitelist',\n      args: [policyId, address, allowed],\n    })\n  }\n\n  /**\n   * Extracts the `WhitelistUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `WhitelistUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'WhitelistUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`WhitelistUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.modifyWhitelistSync(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyWhitelistSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyWhitelistSync.Parameters<chain, account>,\n): Promise<modifyWhitelistSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await modifyWhitelist.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = modifyWhitelist.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace modifyWhitelistSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = modifyWhitelist.Parameters<chain, account>\n\n  export type Args = modifyWhitelist.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'WhitelistUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.modifyBlacklist(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function modifyBlacklist<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyBlacklist.Parameters<chain, account>,\n): Promise<modifyBlacklist.ReturnValue> {\n  return modifyBlacklist.inner(writeContract, client, parameters)\n}\n\nexport namespace modifyBlacklist {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Target account address. */\n    address: Address\n    /** Policy ID. */\n    policyId: bigint\n    /** Whether the account is restricted. */\n    restricted: boolean\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: modifyBlacklist.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { address: targetAccount, policyId, restricted, ...rest } = parameters\n    const call = modifyBlacklist.call({\n      address: targetAccount,\n      policyId,\n      restricted,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `modifyPolicyBlacklist` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.modifyBlacklist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...beef',\n   *       restricted: true,\n   *     }),\n   *     actions.policy.modifyBlacklist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...babe',\n   *       restricted: false,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, address, restricted } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'modifyPolicyBlacklist',\n      args: [policyId, address, restricted],\n    })\n  }\n\n  /**\n   * Extracts the `BlacklistUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `BlacklistUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'BlacklistUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`BlacklistUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.modifyBlacklistSync(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyBlacklistSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyBlacklistSync.Parameters<chain, account>,\n): Promise<modifyBlacklistSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await modifyBlacklist.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = modifyBlacklist.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace modifyBlacklistSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = modifyBlacklist.Parameters<chain, account>\n\n  export type Args = modifyBlacklist.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'BlacklistUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets policy data.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const data = await Actions.policy.getData(client, {\n *   policyId: 2n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The policy data.\n */\nexport async function getData<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getData.Parameters,\n): Promise<getData.ReturnValue> {\n  const { policyId, ...rest } = parameters\n  const result = await readContract(client, {\n    ...rest,\n    ...getData.call({ policyId }),\n  })\n  return {\n    admin: result[1],\n    type: result[0] === 0 ? 'whitelist' : 'blacklist',\n  }\n}\n\nexport namespace getData {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = Compute<{\n    /** Admin address. */\n    admin: Address\n    /** Policy type. */\n    type: PolicyType\n  }>\n\n  /**\n   * Defines a call to the `policyData` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      args: [policyId],\n      functionName: 'policyData',\n    })\n  }\n}\n\n/**\n * Checks if a user is authorized by a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const authorized = await Actions.policy.isAuthorized(client, {\n *   policyId: 2n,\n *   user: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Whether the user is authorized.\n */\nexport async function isAuthorized<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: isAuthorized.Parameters,\n): Promise<isAuthorized.ReturnValue> {\n  const { policyId, user, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...isAuthorized.call({ policyId, user }),\n  })\n}\n\nexport namespace isAuthorized {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Policy ID. */\n    policyId: bigint\n    /** User address to check. */\n    user: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip403Registry,\n    'isAuthorized',\n    never\n  >\n\n  /**\n   * Defines a call to the `isAuthorized` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, user } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      args: [policyId, user],\n      functionName: 'isAuthorized',\n    })\n  }\n}\n\n/**\n * Watches for policy creation events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchCreate(client, {\n *   onPolicyCreated: (args, log) => {\n *     console.log('Policy created:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchCreate.Parameters,\n) {\n  const { onPolicyCreated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'PolicyCreated',\n    onLogs: (logs) => {\n      for (const log of logs)\n        onPolicyCreated(\n          {\n            ...log.args,\n            type: log.args.policyType === 0 ? 'whitelist' : 'blacklist',\n          },\n          log,\n        )\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchCreate {\n  export type Args = Compute<{\n    policyId: bigint\n    updater: Address\n    type: PolicyType\n  }>\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'PolicyCreated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'PolicyCreated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a policy is created. */\n    onPolicyCreated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for policy admin update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchAdminUpdated(client, {\n *   onAdminUpdated: (args, log) => {\n *     console.log('Policy admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchAdminUpdated.Parameters,\n) {\n  const { onAdminUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'PolicyAdminUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onAdminUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchAdminUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'PolicyAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'PolicyAdminUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'PolicyAdminUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a policy admin is updated. */\n    onAdminUpdated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for whitelist update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchWhitelistUpdated(client, {\n *   onWhitelistUpdated: (args, log) => {\n *     console.log('Whitelist updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchWhitelistUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchWhitelistUpdated.Parameters,\n) {\n  const { onWhitelistUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'WhitelistUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onWhitelistUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchWhitelistUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'WhitelistUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'WhitelistUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'WhitelistUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a whitelist is updated. */\n    onWhitelistUpdated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for blacklist update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchBlacklistUpdated(client, {\n *   onBlacklistUpdated: (args, log) => {\n *     console.log('Blacklist updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBlacklistUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchBlacklistUpdated.Parameters,\n) {\n  const { onBlacklistUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'BlacklistUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onBlacklistUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBlacklistUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'BlacklistUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'BlacklistUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'BlacklistUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a blacklist is updated. */\n    onBlacklistUpdated: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type {\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Claims accumulated rewards for a recipient.\n *\n * This function allows a reward recipient to claim their accumulated rewards\n * and receive them as token transfers to their own balance.\n *\n * - Accrues all pending rewards up to the current block timestamp.\n * - Updates the caller's reward accounting.\n * - Transfers the caller's accumulated `rewardBalance` from the token contract to the caller.\n * - If the contract's balance is insufficient, claims up to the available amount.\n * - Returns the actual amount claimed.\n *\n * Notes:\n * - Reverts with `Paused` if the token is paused.\n * - Reverts with `PolicyForbids` if the caller is not authorized to receive tokens under TIP-403.\n * - If opted in, the claimed amount is added back to `optedInSupply` since it goes to the recipient's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.reward.claim(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function claim<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: claim.Parameters<chain, account>,\n): Promise<claim.ReturnValue> {\n  return claim.inner(writeContract, client, parameters)\n}\n\nexport namespace claim {\n  export type Args = {\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = claim.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `claimRewards` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.reward.claim.call({\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [],\n      functionName: 'claimRewards',\n    })\n  }\n}\n\n/**\n * Claims accumulated rewards for a recipient and waits for confirmation.\n *\n * This function allows a reward recipient to claim their accumulated rewards\n * and receive them as token transfers to their own balance.\n *\n * Behavior:\n * - Accrues all pending rewards up to the current block timestamp.\n * - Updates the caller's reward accounting.\n * - Transfers the caller's accumulated `rewardBalance` from the token contract to the caller.\n * - If the contract's balance is insufficient, claims up to the available amount.\n *\n * Notes:\n * - Reverts with `Paused` if the token is paused.\n * - Reverts with `PolicyForbids` if the caller is not authorized to receive tokens under TIP-403.\n * - If opted in, the claimed amount is added back to `optedInSupply` since it goes to the recipient's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.reward.claimSync(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount claimed and transaction receipt.\n */\nexport async function claimSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: claimSync.Parameters<chain, account>,\n): Promise<claimSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await claim.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return {\n    receipt,\n  } as never\n}\n\nexport namespace claimSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & claim.Args\n\n  export type ReturnValue = {\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n  }\n\n  export type ErrorType = claim.ErrorType\n}\n\n/**\n * Distributes rewards to opted-in token holders.\n *\n * This function transfers `amount` of tokens from the caller into the token contract's\n * reward pool and immediately distributes them to current opted-in holders by increasing\n * `globalRewardPerToken`.\n *\n * Notes:\n * - Reverts with `InvalidAmount` if `amount == 0`.\n * - The transfer from caller to pool is subject to TIP-403 policy checks.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.reward.distribute(client, {\n *   amount: 100000000000000000000n,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function distribute<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: distribute.Parameters<chain, account>,\n): Promise<distribute.ReturnValue> {\n  return distribute.inner(writeContract, client, parameters)\n}\n\n/**\n * Distributes rewards to opted-in token holders and waits for confirmation.\n *\n * This function transfers `amount` of tokens from the caller into the token contract's\n * reward pool and immediately distributes them to current opted-in holders by increasing\n * `globalRewardPerToken`.\n *\n * Notes:\n * - Reverts with `InvalidAmount` if `amount == 0`.\n * - The transfer from caller to pool is subject to TIP-403 policy checks.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { amount, funder, receipt } = await Actions.reward.distributeSync(client, {\n *   amount: 100000000000000000000n,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The funder, amount, and transaction receipt.\n */\nexport async function distributeSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: distributeSync.Parameters<chain, account>,\n): Promise<distributeSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await distribute.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = distribute.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace distribute {\n  export type Args = {\n    /** The amount of tokens to distribute (must be > 0) */\n    amount: bigint\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, token, ...rest } = parameters\n    const call = distribute.call({ amount, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `distributeReward` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.reward.distribute.call({\n   *     amount: 100000000000000000000n,\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [amount],\n      functionName: 'distributeReward',\n    })\n  }\n\n  /**\n   * Extracts the `RewardDistributed` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RewardDistributed` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RewardDistributed',\n      strict: true,\n    })\n    if (!log) throw new Error('`RewardDistributed` event not found.')\n    return log\n  }\n}\n\nexport declare namespace distributeSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & distribute.Args\n\n  export type ReturnValue = {\n    /** The amount distributed */\n    amount: bigint\n    /** The address that funded the distribution */\n    funder: Address\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n  }\n\n  export type ErrorType = distribute.ErrorType\n}\n\n/**\n * Gets the global reward per token value.\n *\n * Returns the current global reward per token value scaled by `ACC_PRECISION` (1e18).\n * This value increases each time rewards are distributed.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const rewardPerToken = await Actions.reward.getGlobalRewardPerToken(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The global reward per token (scaled by 1e18).\n */\nexport async function getGlobalRewardPerToken<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getGlobalRewardPerToken.Parameters,\n): Promise<getGlobalRewardPerToken.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getGlobalRewardPerToken.call(parameters),\n  })\n}\n\nexport namespace getGlobalRewardPerToken {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'globalRewardPerToken',\n    never\n  >\n\n  /**\n   * Defines a call to the `globalRewardPerToken` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [],\n      functionName: 'globalRewardPerToken',\n    })\n  }\n}\n\n/**\n * Calculates the pending claimable rewards for an account without modifying state.\n *\n * Returns the total pending claimable reward amount, including stored balance and newly accrued rewards.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const pending = await Actions.reward.getPendingRewards(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The total pending claimable reward amount.\n */\nexport async function getPendingRewards<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getPendingRewards.Parameters,\n): Promise<getPendingRewards.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getPendingRewards.call(parameters),\n  })\n}\n\nexport namespace getPendingRewards {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** The account address to query pending rewards for */\n    account: Address\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'getPendingRewards',\n    never\n  >\n\n  /**\n   * Defines a call to the `getPendingRewards` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [account],\n      functionName: 'getPendingRewards',\n    })\n  }\n}\n\n/**\n * Gets the reward information for a specific account.\n *\n * Returns the reward recipient address, reward per token value, and accumulated reward balance for the specified account.\n * This information includes:\n * - `rewardRecipient`: The address designated to receive rewards (zero address if opted out)\n * - `rewardPerToken`: The reward per token value for this account\n * - `rewardBalance`: The accumulated reward balance waiting to be claimed\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const info = await Actions.reward.getUserRewardInfo(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The user's reward information (recipient, rewardPerToken, rewardBalance).\n */\nexport async function getUserRewardInfo<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getUserRewardInfo.Parameters,\n): Promise<getUserRewardInfo.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getUserRewardInfo.call(parameters),\n  })\n}\n\nexport namespace getUserRewardInfo {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** The account address to query reward info for */\n    account: Address\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'userRewardInfo',\n    never\n  >\n\n  /**\n   * Defines a call to the `userRewardInfo` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [account],\n      functionName: 'userRewardInfo',\n    })\n  }\n}\n\n/**\n * Sets or changes the reward recipient for a token holder.\n *\n * This function allows a token holder to designate who should receive their share of rewards:\n * - If `recipient` is the zero address, opts out from rewards distribution.\n * - Otherwise, opts in and sets `recipient` as the address that will receive accrued rewards.\n * - Can be called with `recipient == msg.sender` to receive rewards directly.\n * - Automatically distributes any accrued rewards to the current recipient before changing.\n *\n * TIP-403 Policy:\n * - Reverts with `PolicyForbids` if `recipient` is not the zero address and either the holder or recipient is not authorized to receive tokens under the token's transfer policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.reward.setRecipient(client, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setRecipient<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRecipient.Parameters<chain, account>,\n): Promise<setRecipient.ReturnValue> {\n  return setRecipient.inner(writeContract, client, parameters)\n}\n\n/**\n * Sets or changes the reward recipient for a token holder and waits for confirmation.\n *\n * This function allows a token holder to designate who should receive their share of rewards:\n * - If `recipient` is the zero address, opts out from rewards distribution.\n * - Otherwise, opts in and sets `recipient` as the address that will receive accrued rewards.\n * - Can be called with `recipient == msg.sender` to receive rewards directly.\n * - Automatically distributes any accrued rewards to the current recipient before changing.\n *\n * TIP-403 Policy:\n * - Reverts with `PolicyForbids` if `recipient` is not the zero address and either the holder or recipient is not authorized to receive tokens under the token's transfer policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { holder, recipient, receipt } = await Actions.reward.setRecipientSync(client, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The holder, recipient, and transaction receipt.\n */\nexport async function setRecipientSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRecipientSync.Parameters<chain, account>,\n): Promise<setRecipientSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setRecipient.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setRecipient.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setRecipient {\n  export type Args = {\n    /** The reward recipient address (use zero address to opt out of rewards) */\n    recipient: Address\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { recipient, token, ...rest } = parameters\n    const call = setRecipient.call({ recipient, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setRewardRecipient` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.reward.setRecipient.call({\n   *     recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { recipient, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [recipient],\n      functionName: 'setRewardRecipient',\n    })\n  }\n\n  /**\n   * Extracts the `RewardRecipientSet` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RewardRecipientSet` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RewardRecipientSet',\n      strict: true,\n    })\n    if (!log) throw new Error('`RewardRecipientSet` event not found.')\n    return log\n  }\n}\n\nexport declare namespace setRecipientSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & setRecipient.Args\n\n  export type ReturnValue = {\n    /** The token holder address who set their reward recipient */\n    holder: Address\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n    /** The reward recipient address (zero address indicates opt-out) */\n    recipient: Address\n  }\n\n  export type ErrorType = setRecipient.ErrorType\n}\n\n/**\n * Watches for reward distributed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.reward.watchRewardDistributed(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardDistributed: (args, log) => {\n *     console.log('Reward distributed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardDistributed<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRewardDistributed.Parameters,\n) {\n  const { onRewardDistributed, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: token,\n    abi: Abis.tip20,\n    eventName: 'RewardDistributed',\n    onLogs: (logs) => {\n      for (const log of logs) onRewardDistributed(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRewardDistributed {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RewardDistributed',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RewardDistributed'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RewardDistributed', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when rewards are distributed. */\n    onRewardDistributed: (args: Args, log: Log) => void\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n\n/**\n * Watches for reward recipient set events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.reward.watchRewardRecipientSet(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardRecipientSet: (args, log) => {\n *     console.log('Reward recipient set:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardRecipientSet<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRewardRecipientSet.Parameters,\n) {\n  const { onRewardRecipientSet, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: token,\n    abi: Abis.tip20,\n    eventName: 'RewardRecipientSet',\n    onLogs: (logs) => {\n      for (const log of logs) onRewardRecipientSet(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRewardRecipientSet {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RewardRecipientSet',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RewardRecipientSet'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RewardRecipientSet', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a reward recipient is set. */\n    onRewardRecipientSet: (args: Args, log: Log) => void\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n", "import type { Address } from 'abitype'\nimport * as Hex from 'ox/Hex'\nimport { TokenId, TokenRole } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { multicall } from '../../actions/public/multicall.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type {\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js'\nimport {\n  type SendTransactionSyncParameters,\n  sendTransactionSync,\n} from '../../actions/wallet/sendTransactionSync.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, OneOf, UnionOmit } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.approve(client, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function approve<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: approve.Parameters<chain, account>,\n): Promise<approve.ReturnValue> {\n  const { token, ...rest } = parameters\n  return approve.inner(writeContract, client, parameters, { ...rest, token })\n}\n\nexport namespace approve {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to approve. */\n    amount: bigint\n    /** Address of the spender. */\n    spender: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: approve.Parameters<chain, account>,\n    args: Args,\n  ): Promise<ReturnType<action>> {\n    const call = approve.call(args)\n    return (await action(client, {\n      ...parameters,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `approve` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.approve.call({\n   *       spender: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { spender, amount, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'approve',\n      args: [spender, amount],\n    })\n  }\n\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Approval',\n    })\n    if (!log) throw new Error('`Approval` event not found.')\n    return log\n  }\n}\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.approveSync(client, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function approveSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: approveSync.Parameters<chain, account>,\n): Promise<approveSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await approve.inner(\n    writeContractSync,\n    client,\n    { ...parameters, throwOnReceiptRevert } as never,\n    rest,\n  )\n  const { args } = approve.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace approveSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = approve.Parameters<chain, account>\n\n  export type Args = approve.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Approval',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnBlocked(client, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burnBlocked<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnBlocked.Parameters<chain, account>,\n): Promise<burnBlocked.ReturnValue> {\n  return burnBlocked.inner(writeContract, client, parameters)\n}\n\nexport namespace burnBlocked {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to burn. */\n    amount: bigint\n    /** Address to burn tokens from. */\n    from: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burnBlocked.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, from, token, ...rest } = parameters\n    const call = burnBlocked.call({ amount, from, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burnBlocked` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.burnBlocked.call({\n   *       from: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { from, amount, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'burnBlocked',\n      args: [from, amount],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'BurnBlocked',\n    })\n    if (!log) throw new Error('`BurnBlocked` event not found.')\n    return log\n  }\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnBlockedSync(client, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnBlockedSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnBlockedSync.Parameters<chain, account>,\n): Promise<burnBlockedSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burnBlocked.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burnBlocked.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnBlockedSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burnBlocked.Parameters<chain, account>\n\n  export type Args = burnBlocked.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'BurnBlocked',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burn(client, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burn.Parameters<chain, account>,\n): Promise<burn.ReturnValue> {\n  return burn.inner(writeContract, client, parameters)\n}\n\nexport namespace burn {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to burn. */\n    amount: bigint\n    /** Memo to include in the transfer. */\n    memo?: Hex.Hex | undefined\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burn.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, memo, token, ...rest } = parameters\n    const call = burn.call({ amount, memo, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burn` or `burnWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.burn.call({\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, memo, token } = args\n    const callArgs = memo\n      ? ({\n          functionName: 'burnWithMemo',\n          args: [amount, Hex.padLeft(memo, 32)],\n        } as const)\n      : ({\n          functionName: 'burn',\n          args: [amount],\n        } as const)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Burn',\n    })\n    if (!log) throw new Error('`Burn` event not found.')\n    return log\n  }\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnSync(client, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnSync.Parameters<chain, account>,\n): Promise<burnSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burn.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burn.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burn.Parameters<chain, account>\n\n  export type Args = burn.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Burn',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.changeTransferPolicy(client, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function changeTransferPolicy<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeTransferPolicy.Parameters<chain, account>,\n): Promise<changeTransferPolicy.ReturnValue> {\n  return changeTransferPolicy.inner(writeContract, client, parameters)\n}\n\nexport namespace changeTransferPolicy {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New transfer policy ID. */\n    policyId: bigint\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: changeTransferPolicy.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { policyId, token, ...rest } = parameters\n    const call = changeTransferPolicy.call({ policyId, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `changeTransferPolicyId` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.changeTransferPolicy.call({\n   *       token: '0x20c0...babe',\n   *       policyId: 1n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, policyId } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'changeTransferPolicyId',\n      args: [policyId],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'TransferPolicyUpdate',\n    })\n    if (!log) throw new Error('`TransferPolicyUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.changeTransferPolicySync(client, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function changeTransferPolicySync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeTransferPolicySync.Parameters<chain, account>,\n): Promise<changeTransferPolicySync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await changeTransferPolicy.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = changeTransferPolicy.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace changeTransferPolicySync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = changeTransferPolicy.Parameters<chain, account>\n\n  export type Args = changeTransferPolicy.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'TransferPolicyUpdate',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.create(client, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function create<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: create.Parameters<chain, account>,\n): Promise<create.ReturnValue> {\n  return create.inner(writeContract, client, parameters)\n}\n\nexport namespace create {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'admin'> &\n    (account extends Account\n      ? { admin?: Account | Address | undefined }\n      : { admin: Account | Address })\n\n  export type Args = {\n    /** Admin address. */\n    admin: Address\n    /** Currency (e.g. \"USD\"). */\n    currency: string\n    /** Token name. */\n    name: string\n    /** Quote token. */\n    quoteToken?: TokenId.TokenIdOrAddress | undefined\n    /** Unique salt. @default Hex.random(32) */\n    salt?: Hex.Hex | undefined\n    /** Token symbol. */\n    symbol: string\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: any,\n  ): Promise<ReturnType<action>> {\n    const {\n      account = client.account,\n      admin: admin_ = client.account,\n      chain = client.chain,\n      ...rest\n    } = parameters\n    const admin = admin_ ? parseAccount(admin_) : undefined\n    if (!admin) throw new Error('admin is required.')\n\n    const call = create.call({ ...rest, admin: admin.address })\n\n    return (await action(\n      client as never,\n      {\n        ...parameters,\n        account,\n        chain,\n        ...call,\n      } as never,\n    )) as never\n  }\n\n  /**\n   * Defines a call to the `createToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.create.call({\n   *       name: 'My Token',\n   *       symbol: 'MTK',\n   *       currency: 'USD',\n   *       admin: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const {\n      name,\n      symbol,\n      currency,\n      quoteToken = Addresses.pathUsd,\n      admin,\n      salt = Hex.random(32),\n    } = args\n    return defineCall({\n      address: Addresses.tip20Factory,\n      abi: Abis.tip20Factory,\n      args: [\n        name,\n        symbol,\n        currency,\n        TokenId.toAddress(quoteToken),\n        admin,\n        salt,\n      ],\n      functionName: 'createToken',\n    })\n  }\n\n  /**\n   * Extracts the `TokenCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `TokenCreated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20Factory,\n      logs,\n      eventName: 'TokenCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`TokenCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.createSync(client, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createSync.Parameters<chain, account>,\n): Promise<createSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await create.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n\n  const { args } = create.extractEvent(receipt.logs)\n  const tokenId = TokenId.fromAddress(args.token)\n\n  return {\n    ...args,\n    receipt,\n    tokenId,\n  } as never\n}\n\nexport namespace createSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = create.Parameters<chain, account>\n\n  export type Args = create.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20Factory,\n      'TokenCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Token ID. */\n      tokenId: TokenId.TokenId\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets TIP20 token allowance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const allowance = await Actions.token.getAllowance(client, {\n *   spender: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token allowance.\n */\nexport async function getAllowance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getAllowance.Parameters<account>,\n): Promise<getAllowance.ReturnValue> {\n  const { account = client.account } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...parameters,\n    ...getAllowance.call({ ...parameters, account: address }),\n  })\n}\n\nexport namespace getAllowance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Omit<Args, 'account'> & {}\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Address of the spender. */\n    spender: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'allowance',\n    never\n  >\n\n  /**\n   * Defines a call to the `allowance` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, spender, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'allowance',\n      args: [account, spender],\n    })\n  }\n}\n\n/**\n * Gets TIP20 token balance for an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const balance = await Actions.token.getBalance(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token balance.\n */\nexport async function getBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getBalance.Parameters<account>,\n): Promise<getBalance.ReturnValue> {\n  const { account = client.account, ...rest } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...rest,\n    ...getBalance.call({ account: address, ...rest }),\n  })\n}\n\nexport namespace getBalance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Omit<Args, 'account'>\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'balanceOf',\n    never\n  >\n\n  /**\n   * Defines a call to the `balanceOf` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'balanceOf',\n      args: [account],\n    })\n  }\n}\n\n/**\n * Gets TIP20 token metadata including name, symbol, currency, decimals, and total supply.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const metadata = await Actions.token.getMetadata(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token metadata.\n */\nexport async function getMetadata<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getMetadata.Parameters,\n): Promise<getMetadata.ReturnValue> {\n  const { token, ...rest } = parameters\n  const address = TokenId.toAddress(token)\n  const abi = Abis.tip20\n\n  if (TokenId.from(token) === TokenId.fromAddress(Addresses.pathUsd))\n    return multicall(client, {\n      ...rest,\n      contracts: [\n        {\n          address,\n          abi,\n          functionName: 'currency',\n        },\n        {\n          address,\n          abi,\n          functionName: 'decimals',\n        },\n        {\n          address,\n          abi,\n          functionName: 'name',\n        },\n        {\n          address,\n          abi,\n          functionName: 'symbol',\n        },\n        {\n          address,\n          abi,\n          functionName: 'totalSupply',\n        },\n      ] as const,\n      allowFailure: false,\n      deployless: true,\n    }).then(([currency, decimals, name, symbol, totalSupply]) => ({\n      name,\n      symbol,\n      currency,\n      decimals,\n      totalSupply,\n    }))\n\n  return multicall(client, {\n    ...rest,\n    contracts: [\n      {\n        address,\n        abi,\n        functionName: 'currency',\n      },\n      {\n        address,\n        abi,\n        functionName: 'decimals',\n      },\n      {\n        address,\n        abi,\n        functionName: 'quoteToken',\n      },\n      {\n        address,\n        abi,\n        functionName: 'name',\n      },\n      {\n        address,\n        abi,\n        functionName: 'paused',\n      },\n      {\n        address,\n        abi,\n        functionName: 'supplyCap',\n      },\n      {\n        address,\n        abi,\n        functionName: 'symbol',\n      },\n      {\n        address,\n        abi,\n        functionName: 'totalSupply',\n      },\n      {\n        address,\n        abi,\n        functionName: 'transferPolicyId',\n      },\n    ] as const,\n    allowFailure: false,\n    deployless: true,\n  }).then(\n    ([\n      currency,\n      decimals,\n      quoteToken,\n      name,\n      paused,\n      supplyCap,\n      symbol,\n      totalSupply,\n      transferPolicyId,\n    ]) => ({\n      name,\n      symbol,\n      currency,\n      decimals,\n      quoteToken,\n      totalSupply,\n      paused,\n      supplyCap,\n      transferPolicyId,\n    }),\n  )\n}\n\nexport declare namespace getMetadata {\n  export type Parameters = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = Compute<{\n    /**\n     * Currency (e.g. \"USD\").\n     */\n    currency: string\n    /**\n     * Decimals of the token.\n     */\n    decimals: number\n    /**\n     * Quote token.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    quoteToken?: Address | undefined\n    /**\n     * Name of the token.\n     */\n    name: string\n    /**\n     * Whether the token is paused.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    paused?: boolean | undefined\n    /**\n     * Supply cap.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    supplyCap?: bigint | undefined\n    /**\n     * Symbol of the token.\n     */\n    symbol: string\n    /**\n     * Total supply of the token.\n     */\n    totalSupply: bigint\n    /**\n     * Transfer policy ID.\n     * 0=\"always-reject\", 1=\"always-allow\", >2=custom policy\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    transferPolicyId?: bigint | undefined\n  }>\n}\n\n/**\n * Gets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const adminRole = await Actions.token.getRoleAdmin(client, {\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The admin role hash.\n */\nexport async function getRoleAdmin<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getRoleAdmin.Parameters,\n): Promise<getRoleAdmin.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getRoleAdmin.call(parameters),\n  })\n}\n\nexport namespace getRoleAdmin {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Role to get admin for. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'getRoleAdmin',\n    never\n  >\n\n  /**\n   * Defines a call to the `getRoleAdmin` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { role, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'getRoleAdmin',\n      args: [TokenRole.serialize(role)],\n    })\n  }\n}\n\n/**\n * Checks if an account has a specific role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hasRole = await Actions.token.hasRole(client, {\n *   account: '0x...',\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Whether the account has the role.\n */\nexport async function hasRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: hasRole.Parameters<account>,\n): Promise<hasRole.ReturnValue> {\n  const { account = client.account } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...parameters,\n    ...hasRole.call({ ...parameters, account: address }),\n  })\n}\n\nexport namespace hasRole {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & Omit<Args, 'account'> & GetAccountParameter<account>\n\n  export type Args = {\n    /** Account address to check. */\n    account: Address\n    /** Role to check. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'hasRole',\n    never\n  >\n\n  /**\n   * Defines a call to the `hasRole` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, role, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'hasRole',\n      args: [account, TokenRole.serialize(role)],\n    })\n  }\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.grantRoles(client, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function grantRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: grantRoles.Parameters<chain, account>,\n): Promise<grantRoles.ReturnValue> {\n  return grantRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace grantRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Role to grant. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Role to grant. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n    /** Address to grant the role to. */\n    to: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: grantRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = grantRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `grantRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.grantRoles.call({\n   *       token: '0x20c0...babe',\n   *       to: '0x20c0...beef',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, to, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'grantRole',\n      args: [roleHash, to],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.grantRolesSync(client, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function grantRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: grantRolesSync.Parameters<chain, account>,\n): Promise<grantRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await grantRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = grantRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace grantRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = grantRoles.Parameters<chain, account>\n\n  export type Args = grantRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.mint(client, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function mint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mint.Parameters<chain, account>,\n): Promise<mint.ReturnValue> {\n  return mint.inner(writeContract, client, parameters)\n}\n\nexport namespace mint {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to mint. */\n    amount: bigint\n    /** Memo to include in the mint. */\n    memo?: Hex.Hex | undefined\n    /** Address to mint tokens to. */\n    to: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: any,\n  ): Promise<ReturnType<action>> {\n    const call = mint.call(parameters)\n    return (await action(client, {\n      ...parameters,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `mint` or `mintWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.mint.call({\n   *       to: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { to, amount, memo, token } = args\n    const callArgs = memo\n      ? ({\n          functionName: 'mintWithMemo',\n          args: [to, amount, Hex.padLeft(memo, 32)],\n        } as const)\n      : ({\n          functionName: 'mint',\n          args: [to, amount],\n        } as const)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Mint',\n    })\n    if (!log) throw new Error('`Mint` event not found.')\n    return log\n  }\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.mintSync(client, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mintSync.Parameters<chain, account>,\n): Promise<mintSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await mint.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = mint.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace mintSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = mint.Parameters<chain, account>\n\n  export type Args = mint.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Mint',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.pause(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function pause<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: pause.Parameters<chain, account>,\n): Promise<pause.ReturnValue> {\n  return pause.inner(writeContract, client, parameters)\n}\n\nexport namespace pause {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: pause.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = pause.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `pause` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.pause.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'pause',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'PauseStateUpdate',\n    })\n    if (!log) throw new Error('`PauseStateUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.pauseSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function pauseSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: pauseSync.Parameters<chain, account>,\n): Promise<pauseSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await pause.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = pause.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  }\n}\n\nexport namespace pauseSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = pause.Parameters<chain, account>\n\n  export type Args = pause.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'PauseStateUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.renounceRoles(client, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function renounceRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: renounceRoles.Parameters<chain, account>,\n): Promise<renounceRoles.ReturnValue> {\n  return renounceRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace renounceRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Roles to renounce. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Role to renounce. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: renounceRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = renounceRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `renounceRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.renounceRoles.call({\n   *       token: '0x20c0...babe',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'renounceRole',\n      args: [roleHash],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.renounceRolesSync(client, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function renounceRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: renounceRolesSync.Parameters<chain, account>,\n): Promise<renounceRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await renounceRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = renounceRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace renounceRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = renounceRoles.Parameters<chain, account>\n\n  export type Args = renounceRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.revokeRoles(client, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function revokeRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: revokeRoles.Parameters<chain, account>,\n): Promise<revokeRoles.ReturnValue> {\n  return revokeRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace revokeRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = SendTransactionSyncParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Role to revoke. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Address to revoke the role from. */\n    from: Address\n    /** Role to revoke. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: revokeRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = revokeRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `revokeRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.revokeRoles.call({\n   *       token: '0x20c0...babe',\n   *       from: '0x20c0...beef',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, from, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'revokeRole',\n      args: [roleHash, from],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.revokeRolesSync(client, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function revokeRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: revokeRolesSync.Parameters<chain, account>,\n): Promise<revokeRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await revokeRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = revokeRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace revokeRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = revokeRoles.Parameters<chain, account>\n\n  export type Args = revokeRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setSupplyCap(client, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setSupplyCap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setSupplyCap.Parameters<chain, account>,\n): Promise<setSupplyCap.ReturnValue> {\n  return setSupplyCap.inner(writeContract, client, parameters)\n}\n\nexport namespace setSupplyCap {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New supply cap. */\n    supplyCap: bigint\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setSupplyCap.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { supplyCap, token, ...rest } = parameters\n    const call = setSupplyCap.call({ supplyCap, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setSupplyCap` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.setSupplyCap.call({\n   *       token: '0x20c0...babe',\n   *       supplyCap: 1000000n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, supplyCap } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setSupplyCap',\n      args: [supplyCap],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'SupplyCapUpdate',\n    })\n    if (!log) throw new Error('`SupplyCapUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setSupplyCapSync(client, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setSupplyCapSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setSupplyCapSync.Parameters<chain, account>,\n): Promise<setSupplyCapSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setSupplyCap.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setSupplyCap.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setSupplyCapSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setSupplyCap.Parameters<chain, account>\n\n  export type Args = setSupplyCap.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'SupplyCapUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setRoleAdmin(client, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'admin',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setRoleAdmin<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRoleAdmin.Parameters<chain, account>,\n): Promise<setRoleAdmin.ReturnValue> {\n  return setRoleAdmin.inner(writeContract, client, parameters)\n}\n\nexport namespace setRoleAdmin {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New admin role. */\n    adminRole: TokenRole.TokenRole\n    /** Role to set admin for. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setRoleAdmin.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { adminRole, role, token, ...rest } = parameters\n    const call = setRoleAdmin.call({ adminRole, role, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setRoleAdmin` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.setRoleAdmin.call({\n   *       token: '0x20c0...babe',\n   *       role: 'issuer',\n   *       adminRole: 'admin',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, role, adminRole } = args\n    const roleHash = TokenRole.serialize(role)\n    const adminRoleHash = TokenRole.serialize(adminRole)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setRoleAdmin',\n      args: [roleHash, adminRoleHash],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleAdminUpdated',\n    })\n    if (!log) throw new Error('`RoleAdminUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setRoleAdminSync(client, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'admin',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setRoleAdminSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRoleAdminSync.Parameters<chain, account>,\n): Promise<setRoleAdminSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setRoleAdmin.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setRoleAdmin.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setRoleAdminSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setRoleAdmin.Parameters<chain, account>\n\n  export type Args = setRoleAdmin.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.transfer(client, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function transfer<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: transfer.Parameters<chain, account>,\n): Promise<transfer.ReturnValue> {\n  return transfer.inner(writeContract, client, parameters)\n}\n\nexport namespace transfer {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to transfer. */\n    amount: bigint\n    /** Address to transfer tokens from. */\n    from?: Address | undefined\n    /** Memo to include in the transfer. */\n    memo?: Hex.Hex | undefined\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n    /** Address to transfer tokens to. */\n    to: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: transfer.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, from, memo, token, to, ...rest } = parameters\n    const call = transfer.call({ amount, from, memo, token, to })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `transfer`, `transferFrom`, `transferWithMemo`, or `transferFromWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.transfer.call({\n   *       to: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, from, memo, token, to } = args\n    const callArgs = (() => {\n      if (memo && from)\n        return {\n          functionName: 'transferFromWithMemo',\n          args: [from, to, amount, Hex.padLeft(memo, 32)],\n        } as const\n      if (memo)\n        return {\n          functionName: 'transferWithMemo',\n          args: [to, amount, Hex.padLeft(memo, 32)],\n        } as const\n      if (from)\n        return {\n          functionName: 'transferFrom',\n          args: [from, to, amount],\n        } as const\n      return {\n        functionName: 'transfer',\n        args: [to, amount],\n      } as const\n    })()\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Transfer',\n    })\n    if (!log) throw new Error('`Transfer` event not found.')\n    return log\n  }\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.transferSync(client, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function transferSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: transferSync.Parameters<chain, account>,\n): Promise<transferSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await transfer.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = transfer.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace transferSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = transfer.Parameters<chain, account>\n\n  export type Args = transfer.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'Transfer',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.unpause(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function unpause<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: unpause.Parameters<chain, account>,\n): Promise<unpause.ReturnValue> {\n  return unpause.inner(writeContract, client, parameters)\n}\n\nexport namespace unpause {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: unpause.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = unpause.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `unpause` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.unpause.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'unpause',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'PauseStateUpdate',\n    })\n    if (!log) throw new Error('`PauseStateUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.unpauseSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function unpauseSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: unpauseSync.Parameters<chain, account>,\n): Promise<unpauseSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await unpause.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = unpause.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace unpauseSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = unpause.Parameters<chain, account>\n\n  export type Args = unpause.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'PauseStateUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.prepareUpdateQuoteToken(client, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function prepareUpdateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareUpdateQuoteToken.Parameters<chain, account>,\n): Promise<prepareUpdateQuoteToken.ReturnValue> {\n  return prepareUpdateQuoteToken.inner(writeContract, client, parameters)\n}\n\nexport namespace prepareUpdateQuoteToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New quote token address. */\n    quoteToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: prepareUpdateQuoteToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { quoteToken, token, ...rest } = parameters\n    const call = prepareUpdateQuoteToken.call({ quoteToken, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `prepareUpdateQuoteToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.prepareUpdateQuoteToken.call({\n   *       token: '0x20c0...babe',\n   *       quoteToken: '0x20c0...cafe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, quoteToken } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setNextQuoteToken',\n      args: [TokenId.toAddress(quoteToken)],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'NextQuoteTokenSet',\n    })\n    if (!log) throw new Error('`NextQuoteTokenSet` event not found.')\n    return log\n  }\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.prepareUpdateQuoteTokenSync(client, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function prepareUpdateQuoteTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareUpdateQuoteTokenSync.Parameters<chain, account>,\n): Promise<prepareUpdateQuoteTokenSync.ReturnValue> {\n  const receipt = await prepareUpdateQuoteToken.inner(\n    writeContractSync,\n    client,\n    parameters,\n  )\n  const { args } = prepareUpdateQuoteToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace prepareUpdateQuoteTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = prepareUpdateQuoteToken.Parameters<chain, account>\n\n  export type Args = prepareUpdateQuoteToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'NextQuoteTokenSet',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.updateQuoteToken(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function updateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: updateQuoteToken.Parameters<chain, account>,\n): Promise<updateQuoteToken.ReturnValue> {\n  return updateQuoteToken.inner(writeContract, client, parameters)\n}\n\nexport namespace updateQuoteToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: updateQuoteToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = updateQuoteToken.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `updateQuoteToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.updateQuoteToken.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'completeQuoteTokenUpdate',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'QuoteTokenUpdate',\n    })\n    if (!log) throw new Error('`QuoteTokenUpdateCompleted` event not found.')\n    return log\n  }\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.updateQuoteTokenSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function updateQuoteTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: updateQuoteTokenSync.Parameters<chain, account>,\n): Promise<updateQuoteTokenSync.ReturnValue> {\n  const receipt = await updateQuoteToken.inner(\n    writeContractSync,\n    client,\n    parameters,\n  )\n  const { args } = updateQuoteToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace updateQuoteTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = updateQuoteToken.Parameters<chain, account>\n\n  export type Args = updateQuoteToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'QuoteTokenUpdate',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for TIP20 token approval events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchApprove(client, {\n *   onApproval: (args, log) => {\n *     console.log('Approval:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchApprove<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchApprove.Parameters,\n) {\n  const { onApproval, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Approval',\n    onLogs: (logs) => {\n      for (const log of logs) onApproval(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchApprove {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Approval',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Approval'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Approval', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are approved. */\n    onApproval: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token burn events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchBurn(client, {\n *   onBurn: (args, log) => {\n *     console.log('Burn:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchBurn.Parameters) {\n  const { onBurn, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Burn',\n    onLogs: (logs) => {\n      for (const log of logs) onBurn(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBurn {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Burn',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Burn'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Burn', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are burned. */\n    onBurn: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for new TIP20 tokens created.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchCreate(client, {\n *   onTokenCreated: (args, log) => {\n *     console.log('Token created:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchCreate.Parameters,\n) {\n  const { onTokenCreated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip20Factory,\n    abi: Abis.tip20Factory,\n    eventName: 'TokenCreated',\n    onLogs: (logs) => {\n      for (const log of logs) onTokenCreated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchCreate {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20Factory,\n    'TokenCreated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20Factory, 'TokenCreated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip20Factory,\n      'TokenCreated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a new TIP20 token is created. */\n    onTokenCreated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for TIP20 token mint events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchMint(client, {\n *   onMint: (args, log) => {\n *     console.log('Mint:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchMint.Parameters) {\n  const { onMint, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Mint',\n    onLogs: (logs) => {\n      for (const log of logs) onMint(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchMint {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Mint',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Mint'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Mint', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are minted. */\n    onMint: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n\n/**\n * Watches for TIP20 token role admin updates.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchAdminRole(client, {\n *   onRoleAdminUpdated: (args, log) => {\n *     console.log('Role admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchAdminRole.Parameters,\n) {\n  const { onRoleAdminUpdated, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'RoleAdminUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onRoleAdminUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchAdminRole {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RoleAdminUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RoleAdminUpdated', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a role admin is updated. */\n    onRoleAdminUpdated: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token role membership updates.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchRole(client, {\n *   onRoleUpdated: (args, log) => {\n *     console.log('Role updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchRole.Parameters) {\n  const { onRoleUpdated, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'RoleMembershipUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) {\n        const type = log.args.hasRole ? 'granted' : 'revoked'\n        onRoleUpdated({ ...log.args, type }, log)\n      }\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRole {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleMembershipUpdated',\n    { IndexedOnly: false; Required: true }\n  > & {\n    /** Type of role update. */\n    type: 'granted' | 'revoked'\n  }\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RoleMembershipUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a role membership is updated. */\n    onRoleUpdated: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token transfer events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchTransfer(client, {\n *   onTransfer: (args, log) => {\n *     console.log('Transfer:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchTransfer<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchTransfer.Parameters,\n) {\n  const { onTransfer, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Transfer',\n    onLogs: (logs) => {\n      for (const log of logs) onTransfer(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchTransfer {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Transfer',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Transfer'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Transfer', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are transferred. */\n    onTransfer: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token quote token update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchUpdateQuoteToken(client, {\n *   onUpdateQuoteToken: (args, log) => {\n *     if (args.completed)\n *       console.log('quote token update completed:', args.newQuoteToken)\n *     else\n *       console.log('quote token update proposed:', args.newQuoteToken)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchUpdateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchUpdateQuoteToken.Parameters,\n) {\n  const { onUpdateQuoteToken, token, ...rest } = parameters\n  const address = TokenId.toAddress(token)\n\n  return watchContractEvent(client, {\n    ...rest,\n    address,\n    abi: Abis.tip20,\n    onLogs: (\n      logs: viem_Log<\n        bigint,\n        number,\n        false,\n        ExtractAbiItem<\n          typeof Abis.tip20,\n          'NextQuoteTokenSet' | 'QuoteTokenUpdate'\n        >,\n        true\n      >[],\n    ) => {\n      for (const log of logs) {\n        if (\n          log.eventName !== 'NextQuoteTokenSet' &&\n          log.eventName !== 'QuoteTokenUpdate'\n        )\n          continue\n\n        onUpdateQuoteToken(\n          {\n            ...log.args,\n            completed: log.eventName === 'QuoteTokenUpdate',\n          },\n          log,\n        )\n      }\n    },\n    strict: true,\n  } as never)\n}\n\nexport declare namespace watchUpdateQuoteToken {\n  export type Args = OneOf<\n    | GetEventArgs<\n        typeof Abis.tip20,\n        'NextQuoteTokenSet',\n        { IndexedOnly: false; Required: true }\n      >\n    | GetEventArgs<\n        typeof Abis.tip20,\n        'QuoteTokenUpdate',\n        { IndexedOnly: false; Required: true }\n      >\n  > & {\n    /** Whether the update has been completed. */\n    completed: boolean\n  }\n\n  export type Log = viem_Log\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, any, true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a quote token update is proposed or completed. */\n    onUpdateQuoteToken: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Hex } from 'ox/Hex'\nimport type { Account } from '../../accounts/types.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Adds a new validator (owner only).\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hash = await Actions.validator.add(client, {\n *   newValidatorAddress: '0x...',\n *   publicKey: '0x...',\n *   active: true,\n *   inboundAddress: '192.168.1.1:8080',\n *   outboundAddress: '192.168.1.1:8080',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function add<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: add.Parameters<chain, account>,\n): Promise<add.ReturnValue> {\n  return add.inner(writeContract, client, parameters)\n}\n\nexport namespace add {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** The address of the new validator. */\n    newValidatorAddress: Address\n    /** The validator's communication public key. */\n    publicKey: Hex\n    /** Whether the validator should be active. */\n    active: boolean\n    /** The validator's inbound address `<hostname|ip>:<port>` for incoming connections. */\n    inboundAddress: string\n    /** The validator's outbound IP address `<ip>:<port>` for firewall whitelisting (IP only, no hostnames). */\n    outboundAddress: string\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      newValidatorAddress,\n      publicKey,\n      active,\n      inboundAddress,\n      outboundAddress,\n      ...rest\n    } = parameters\n    const callData = add.call({\n      newValidatorAddress,\n      publicKey,\n      active,\n      inboundAddress,\n      outboundAddress,\n    })\n    return (await action(client, {\n      ...rest,\n      ...callData,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `addValidator` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.validator.add.call({\n   *       newValidatorAddress: '0x...',\n   *       publicKey: '0x...',\n   *       active: true,\n   *       inboundAddress: '192.168.1.1:8080',\n   *       outboundAddress: '192.168.1.1:8080',\n   *     }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const {\n      newValidatorAddress,\n      publicKey,\n      active,\n      inboundAddress,\n      outboundAddress,\n    } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [\n        newValidatorAddress,\n        publicKey,\n        active,\n        inboundAddress,\n        outboundAddress,\n      ],\n      functionName: 'addValidator',\n    })\n  }\n}\n\n/**\n * Adds a new validator (owner only) and waits for the transaction receipt.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.validator.addSync(client, {\n *   newValidatorAddress: '0x...',\n *   publicKey: '0x...',\n *   active: true,\n *   inboundAddress: '192.168.1.1:8080',\n *   outboundAddress: '192.168.1.1:8080',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function addSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: addSync.Parameters<chain, account>,\n): Promise<addSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await add.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace addSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = add.Parameters<chain, account>\n\n  export type Args = add.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n  }\n}\n\n/**\n * Changes the owner of the validator config precompile.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hash = await Actions.validator.changeOwner(client, {\n *   newOwner: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function changeOwner<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeOwner.Parameters<chain, account>,\n): Promise<changeOwner.ReturnValue> {\n  return changeOwner.inner(writeContract, client, parameters)\n}\n\nexport namespace changeOwner {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** The new owner address. */\n    newOwner: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { newOwner, ...rest } = parameters\n    const callData = changeOwner.call({ newOwner })\n    return (await action(client, {\n      ...rest,\n      ...callData,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `changeOwner` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.validator.changeOwner.call({\n   *       newOwner: '0x...',\n   *     }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { newOwner } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [newOwner],\n      functionName: 'changeOwner',\n    })\n  }\n}\n\n/**\n * Changes the owner and waits for the transaction receipt.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.validator.changeOwnerSync(client, {\n *   newOwner: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function changeOwnerSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeOwnerSync.Parameters<chain, account>,\n): Promise<changeOwnerSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await changeOwner.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace changeOwnerSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = changeOwner.Parameters<chain, account>\n\n  export type Args = changeOwner.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n  }\n}\n\n/**\n * Changes validator active status (owner only).\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hash = await Actions.validator.changeStatus(client, {\n *   validator: '0x...',\n *   active: false,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function changeStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeStatus.Parameters<chain, account>,\n): Promise<changeStatus.ReturnValue> {\n  return changeStatus.inner(writeContract, client, parameters)\n}\n\nexport namespace changeStatus {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** The validator address. */\n    validator: Address\n    /** Whether the validator should be active. */\n    active: boolean\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { validator, active, ...rest } = parameters\n    const callData = changeStatus.call({ validator, active })\n    return (await action(client, {\n      ...rest,\n      ...callData,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `changeValidatorStatus` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.validator.changeStatus.call({\n   *       validator: '0x...',\n   *       active: false,\n   *     }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { validator, active } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [validator, active],\n      functionName: 'changeValidatorStatus',\n    })\n  }\n}\n\n/**\n * Changes validator active status and waits for the transaction receipt.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.validator.changeStatusSync(client, {\n *   validator: '0x...',\n *   active: false,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function changeStatusSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeStatusSync.Parameters<chain, account>,\n): Promise<changeStatusSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await changeStatus.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace changeStatusSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = changeStatus.Parameters<chain, account>\n\n  export type Args = changeStatus.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n  }\n}\n\n/**\n * Gets the next epoch for a full DKG ceremony.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const epoch = await Actions.validator.getNextFullDkgCeremony(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The epoch number for the next full DKG ceremony.\n */\nexport async function getNextFullDkgCeremony<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getNextFullDkgCeremony.Parameters = {},\n): Promise<getNextFullDkgCeremony.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getNextFullDkgCeremony.call(),\n  })\n}\n\nexport namespace getNextFullDkgCeremony {\n  export type Parameters = ReadParameters\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'getNextFullDkgCeremony',\n    never\n  >\n\n  /**\n   * Defines a call to the `getNextFullDkgCeremony` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [Actions.validator.getNextFullDkgCeremony.call()],\n   * })\n   * ```\n   *\n   * @returns The call.\n   */\n  export function call() {\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [],\n      functionName: 'getNextFullDkgCeremony',\n    })\n  }\n}\n\n/**\n * Gets the contract owner.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const owner = await Actions.validator.getOwner(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The owner address.\n */\nexport async function getOwner<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getOwner.Parameters = {},\n): Promise<getOwner.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getOwner.call(),\n  })\n}\n\nexport namespace getOwner {\n  export type Parameters = ReadParameters\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'owner',\n    never\n  >\n\n  /**\n   * Defines a call to the `owner` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [Actions.validator.getOwner.call()],\n   * })\n   * ```\n   *\n   * @returns The call.\n   */\n  export function call() {\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [],\n      functionName: 'owner',\n    })\n  }\n}\n\n/**\n * Gets validator information by address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const validator = await Actions.validator.get(client, {\n *   validator: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The validator information.\n */\nexport async function get<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: get.Parameters,\n): Promise<get.ReturnValue> {\n  const { validator, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...get.call({ validator }),\n  })\n}\n\nexport namespace get {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Validator address. */\n    validator: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'validators',\n    never\n  >\n\n  /**\n   * Defines a call to the `validators` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [\n   *     Actions.validator.get.call({ validator: '0x...' }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { validator } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [validator],\n      functionName: 'validators',\n    })\n  }\n}\n\n/**\n * Gets validator address by index.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const validatorAddress = await Actions.validator.getByIndex(client, {\n *   index: 0n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The validator address at the given index.\n */\nexport async function getByIndex<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getByIndex.Parameters,\n): Promise<getByIndex.ReturnValue> {\n  const { index, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getByIndex.call({ index }),\n  })\n}\n\nexport namespace getByIndex {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Validator index. */\n    index: bigint\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'validatorsArray',\n    never\n  >\n\n  /**\n   * Defines a call to the `validatorsArray` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [\n   *     Actions.validator.getByIndex.call({ index: 0n }),\n   *     Actions.validator.getByIndex.call({ index: 1n }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { index } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [index],\n      functionName: 'validatorsArray',\n    })\n  }\n}\n\n/**\n * Gets the total number of validators.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const count = await Actions.validator.getCount(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The total number of validators.\n */\nexport async function getCount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getCount.Parameters = {},\n): Promise<getCount.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getCount.call(),\n  })\n}\n\nexport namespace getCount {\n  export type Parameters = ReadParameters\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'validatorCount',\n    never\n  >\n\n  /**\n   * Defines a call to the `validatorCount` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [Actions.validator.getCount.call()],\n   * })\n   * ```\n   *\n   * @returns The call.\n   */\n  export function call() {\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [],\n      functionName: 'validatorCount',\n    })\n  }\n}\n\n/**\n * Gets the complete set of validators.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const validators = await Actions.validator.list(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Array of all validators with their information.\n */\nexport async function list<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: list.Parameters = {},\n): Promise<list.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...list.call(),\n  })\n}\n\nexport namespace list {\n  export type Parameters = ReadParameters\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.validator,\n    'getValidators',\n    never\n  >\n\n  /**\n   * Defines a call to the `getValidators` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [Actions.validator.list.call()],\n   * })\n   * ```\n   *\n   * @returns The call.\n   */\n  export function call() {\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [],\n      functionName: 'getValidators',\n    })\n  }\n}\n\n/**\n * Sets the next epoch for a full DKG ceremony.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hash = await Actions.validator.setNextFullDkgCeremony(client, {\n *   epoch: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setNextFullDkgCeremony<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setNextFullDkgCeremony.Parameters<chain, account>,\n): Promise<setNextFullDkgCeremony.ReturnValue> {\n  return setNextFullDkgCeremony.inner(writeContract, client, parameters)\n}\n\nexport namespace setNextFullDkgCeremony {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** The epoch number for the next full DKG ceremony. */\n    epoch: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { epoch, ...rest } = parameters\n    const callData = setNextFullDkgCeremony.call({ epoch })\n    return (await action(client, {\n      ...rest,\n      ...callData,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setNextFullDkgCeremony` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.validator.setNextFullDkgCeremony.call({\n   *       epoch: 100n,\n   *     }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { epoch } = args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [epoch],\n      functionName: 'setNextFullDkgCeremony',\n    })\n  }\n}\n\n/**\n * Sets the next epoch for a full DKG ceremony and waits for the transaction receipt.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.validator.setNextFullDkgCeremonySync(client, {\n *   epoch: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function setNextFullDkgCeremonySync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setNextFullDkgCeremonySync.Parameters<chain, account>,\n): Promise<setNextFullDkgCeremonySync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setNextFullDkgCeremony.inner(\n    writeContractSync,\n    client,\n    {\n      ...rest,\n      throwOnReceiptRevert,\n    } as never,\n  )\n  return { receipt }\n}\n\nexport namespace setNextFullDkgCeremonySync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setNextFullDkgCeremony.Parameters<chain, account>\n\n  export type Args = setNextFullDkgCeremony.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n  }\n}\n\n/**\n * Updates validator information (only callable by the validator themselves).\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hash = await Actions.validator.update(client, {\n *   newValidatorAddress: '0x...',\n *   publicKey: '0x...',\n *   inboundAddress: '192.168.1.1:8080',\n *   outboundAddress: '192.168.1.1:8080',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function update<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: update.Parameters<chain, account>,\n): Promise<update.ReturnValue> {\n  return update.inner(writeContract, client, parameters)\n}\n\nexport namespace update {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** The new address for this validator. */\n    newValidatorAddress: Address\n    /** The validator's new communication public key. */\n    publicKey: Hex\n    /** The validator's inbound address `<hostname|ip>:<port>` for incoming connections. */\n    inboundAddress: string\n    /** The validator's outbound IP address `<ip>:<port>` for firewall whitelisting (IP only, no hostnames). */\n    outboundAddress: string\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      newValidatorAddress,\n      publicKey,\n      inboundAddress,\n      outboundAddress,\n      ...rest\n    } = parameters\n    const callData = update.call({\n      newValidatorAddress,\n      publicKey,\n      inboundAddress,\n      outboundAddress,\n    })\n    return (await action(client, {\n      ...rest,\n      ...callData,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `updateValidator` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'viem/chains'\n   * import { Actions } from 'viem/tempo'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.validator.update.call({\n   *       newValidatorAddress: '0x...',\n   *       publicKey: '0x...',\n   *       inboundAddress: '192.168.1.1:8080',\n   *       outboundAddress: '192.168.1.1:8080',\n   *     }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { newValidatorAddress, publicKey, inboundAddress, outboundAddress } =\n      args\n    return defineCall({\n      address: Addresses.validator,\n      abi: Abis.validator,\n      args: [newValidatorAddress, publicKey, inboundAddress, outboundAddress],\n      functionName: 'updateValidator',\n    })\n  }\n}\n\n/**\n * Updates validator information and waits for the transaction receipt.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'viem/tempo'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.validator.updateSync(client, {\n *   newValidatorAddress: '0x...',\n *   publicKey: '0x...',\n *   inboundAddress: '192.168.1.1:8080',\n *   outboundAddress: '192.168.1.1:8080',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function updateSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: updateSync.Parameters<chain, account>,\n): Promise<updateSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await update.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace updateSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = update.Parameters<chain, account>\n\n  export type Args = update.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n  }\n}\n", "export {};\n//# sourceMappingURL=Capabilities.js.map", "import type { Account } from '../accounts/types.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { Chain } from '../types/chain.js'\nimport * as ammActions from './actions/amm.js'\nimport * as dexActions from './actions/dex.js'\nimport * as faucetActions from './actions/faucet.js'\nimport * as feeActions from './actions/fee.js'\nimport * as nonceActions from './actions/nonce.js'\nimport * as policyActions from './actions/policy.js'\nimport * as rewardActions from './actions/reward.js'\nimport * as tokenActions from './actions/token.js'\nimport * as validatorActions from './actions/validator.js'\n\nexport type Decorator<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  amm: {\n    /**\n     * Gets the reserves for a liquidity pool.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c...001' }),\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const pool = await client.amm.getPool({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The pool reserves.\n     */\n    getPool: (\n      parameters: ammActions.getPool.Parameters,\n    ) => Promise<ammActions.getPool.ReturnValue>\n    /**\n     * Gets the LP token balance for an account in a specific pool.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const poolId = await client.amm.getPoolId({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     * })\n     *\n     * const balance = await client.amm.getLiquidityBalance({\n     *   poolId,\n     *   address: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The LP token balance.\n     */\n    getLiquidityBalance: (\n      parameters: ammActions.getLiquidityBalance.Parameters,\n    ) => Promise<ammActions.getLiquidityBalance.ReturnValue>\n    /**\n     * Removes liquidity from a pool.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.amm.burn({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     *   liquidity: 50n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    burn: (\n      parameters: ammActions.burn.Parameters<chain, account>,\n    ) => Promise<ammActions.burn.ReturnValue>\n    /**\n     * Removes liquidity from a pool and waits for confirmation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt, ...result } = await client.amm.burnSync({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     *   liquidity: 50n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    burnSync: (\n      parameters: ammActions.burnSync.Parameters<chain, account>,\n    ) => Promise<ammActions.burnSync.ReturnValue>\n    /**\n     * Adds liquidity to a pool.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.amm.mint({\n     *   userTokenAddress: '0x...',\n     *   validatorTokenAddress: '0x...',\n     *   validatorTokenAmount: 100n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    mint: (\n      parameters: ammActions.mint.Parameters<chain, account>,\n    ) => Promise<ammActions.mint.ReturnValue>\n    /**\n     * Adds liquidity to a pool.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.amm.mintSync({\n     *   userTokenAddress: '0x...',\n     *   validatorTokenAddress: '0x...',\n     *   validatorTokenAmount: 100n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    mintSync: (\n      parameters: ammActions.mintSync.Parameters<chain, account>,\n    ) => Promise<ammActions.mintSync.ReturnValue>\n    /**\n     * Swaps tokens during a rebalance operation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.amm.rebalanceSwap({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     *   amountOut: 100n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    rebalanceSwap: (\n      parameters: ammActions.rebalanceSwap.Parameters<chain, account>,\n    ) => Promise<ammActions.rebalanceSwap.ReturnValue>\n    /**\n     * Swaps tokens during a rebalance operation and waits for confirmation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt, ...result } = await client.amm.rebalanceSwapSync({\n     *   userToken: '0x...',\n     *   validatorToken: '0x...',\n     *   amountOut: 100n,\n     *   to: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    rebalanceSwapSync: (\n      parameters: ammActions.rebalanceSwapSync.Parameters<chain, account>,\n    ) => Promise<ammActions.rebalanceSwapSync.ReturnValue>\n    /**\n     * Watches for burn (liquidity removal) events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.amm.watchBurn({\n     *   onBurn: (args, log) => {\n     *     console.log('Liquidity removed:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchBurn: (parameters: ammActions.watchBurn.Parameters) => () => void\n    /**\n     * Watches for liquidity mint events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.amm.watchMint({\n     *   onMint: (args, log) => {\n     *     console.log('Liquidity added:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchMint: (parameters: ammActions.watchMint.Parameters) => () => void\n    /**\n     * Watches for rebalance swap events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.amm.watchRebalanceSwap({\n     *   onRebalanceSwap: (args, log) => {\n     *     console.log('Rebalance swap:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchRebalanceSwap: (\n      parameters: ammActions.watchRebalanceSwap.Parameters,\n    ) => () => void\n  }\n  dex: {\n    /**\n     * Buys a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.buy({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountOut: 100n,\n     *   maxAmountIn: 105n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    buy: (\n      parameters: dexActions.buy.Parameters<chain, account>,\n    ) => Promise<dexActions.buy.ReturnValue>\n    /**\n     * Buys a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.buySync({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountOut: 100n,\n     *   maxAmountIn: 105n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    buySync: (\n      parameters: dexActions.buySync.Parameters<chain, account>,\n    ) => Promise<dexActions.buySync.ReturnValue>\n    /**\n     * Cancels an order from the orderbook.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.cancel({\n     *   orderId: 123n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    cancel: (\n      parameters: dexActions.cancel.Parameters<chain, account>,\n    ) => Promise<dexActions.cancel.ReturnValue>\n    /**\n     * Cancels an order from the orderbook.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.cancelSync({\n     *   orderId: 123n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    cancelSync: (\n      parameters: dexActions.cancelSync.Parameters<chain, account>,\n    ) => Promise<dexActions.cancelSync.ReturnValue>\n    /**\n     * Cancels a stale order from the orderbook.\n     *\n     * A stale order is one where the maker has been blacklisted by a TIP-403 policy.\n     * Anyone can cancel stale orders.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.cancelStale({\n     *   orderId: 123n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    cancelStale: (\n      parameters: dexActions.cancelStale.Parameters<chain, account>,\n    ) => Promise<dexActions.cancelStale.ReturnValue>\n    /**\n     * Cancels a stale order from the orderbook and waits for confirmation.\n     *\n     * A stale order is one where the maker has been blacklisted by a TIP-403 policy.\n     * Anyone can cancel stale orders.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.cancelStaleSync({\n     *   orderId: 123n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    cancelStaleSync: (\n      parameters: dexActions.cancelStaleSync.Parameters<chain, account>,\n    ) => Promise<dexActions.cancelStaleSync.ReturnValue>\n    /**\n     * Creates a new trading pair on the DEX.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.createPair({\n     *   base: '0x20c...11',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    createPair: (\n      parameters: dexActions.createPair.Parameters<chain, account>,\n    ) => Promise<dexActions.createPair.ReturnValue>\n    /**\n     * Creates a new trading pair on the DEX.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.createPairSync({\n     *   base: '0x20c...11',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    createPairSync: (\n      parameters: dexActions.createPairSync.Parameters<chain, account>,\n    ) => Promise<dexActions.createPairSync.ReturnValue>\n    /**\n     * Gets a user's token balance on the DEX.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const balance = await client.dex.getBalance({\n     *   account: '0x...',\n     *   token: '0x20c...11',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The user's token balance on the DEX.\n     */\n    getBalance: (\n      parameters: dexActions.getBalance.Parameters<account>,\n    ) => Promise<dexActions.getBalance.ReturnValue>\n    /**\n     * Gets the quote for buying a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const amountIn = await client.dex.getBuyQuote({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountOut: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The amount of tokenIn needed to buy the specified amountOut.\n     */\n    getBuyQuote: (\n      parameters: dexActions.getBuyQuote.Parameters,\n    ) => Promise<dexActions.getBuyQuote.ReturnValue>\n    /**\n     * Gets an order's details from the orderbook.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const order = await client.dex.getOrder({\n     *   orderId: 123n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The order details.\n     */\n    getOrder: (\n      parameters: dexActions.getOrder.Parameters,\n    ) => Promise<dexActions.getOrder.ReturnValue>\n    /**\n     * Gets the price level information at a specific tick.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions, Tick } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const level = await client.dex.getTickLevel({\n     *   base: '0x20c...11',\n     *   tick: Tick.fromPrice('1.001'),\n     *   isBid: true,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The price level information.\n     */\n    getTickLevel: (\n      parameters: dexActions.getTickLevel.Parameters,\n    ) => Promise<dexActions.getTickLevel.ReturnValue>\n    /**\n     * Gets the quote for selling a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const amountOut = await client.dex.getSellQuote({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountIn: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The amount of tokenOut received for selling the specified amountIn.\n     */\n    getSellQuote: (\n      parameters: dexActions.getSellQuote.Parameters,\n    ) => Promise<dexActions.getSellQuote.ReturnValue>\n    /**\n     * Places a limit order on the orderbook.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions, Tick } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.place({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     *   type: 'buy',\n     *   tick: Tick.fromPrice('0.99'),\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    place: (\n      parameters: dexActions.place.Parameters<chain, account>,\n    ) => Promise<dexActions.place.ReturnValue>\n    /**\n     * Places a limit order on the orderbook.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions, Tick } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.placeSync({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     *   type: 'buy',\n     *   tick: Tick.fromPrice('0.99'),\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    placeSync: (\n      parameters: dexActions.placeSync.Parameters<chain, account>,\n    ) => Promise<dexActions.placeSync.ReturnValue>\n    /**\n     * Places a flip order that automatically flips when filled.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions, Tick } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.placeFlip({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     *   type: 'buy',\n     *   tick: Tick.fromPrice('0.99'),\n     *   flipTick: Tick.fromPrice('1.01'),\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    placeFlip: (\n      parameters: dexActions.placeFlip.Parameters<chain, account>,\n    ) => Promise<dexActions.placeFlip.ReturnValue>\n    /**\n     * Places a flip order that automatically flips when filled.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions, Tick } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.placeFlipSync({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     *   type: 'buy',\n     *   tick: Tick.fromPrice('0.99'),\n     *   flipTick: Tick.fromPrice('1.01'),\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    placeFlipSync: (\n      parameters: dexActions.placeFlipSync.Parameters<chain, account>,\n    ) => Promise<dexActions.placeFlipSync.ReturnValue>\n    /**\n     * Sells a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.sell({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountIn: 100n,\n     *   minAmountOut: 95n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    sell: (\n      parameters: dexActions.sell.Parameters<chain, account>,\n    ) => Promise<dexActions.sell.ReturnValue>\n    /**\n     * Sells a specific amount of tokens.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.sellSync({\n     *   tokenIn: '0x20c...11',\n     *   tokenOut: '0x20c...20',\n     *   amountIn: 100n,\n     *   minAmountOut: 95n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    sellSync: (\n      parameters: dexActions.sellSync.Parameters<chain, account>,\n    ) => Promise<dexActions.sellSync.ReturnValue>\n    /**\n     * Withdraws tokens from the DEX to the caller's wallet.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.dex.withdraw({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    withdraw: (\n      parameters: dexActions.withdraw.Parameters<chain, account>,\n    ) => Promise<dexActions.withdraw.ReturnValue>\n    /**\n     * Withdraws tokens from the DEX to the caller's wallet.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.dex.withdrawSync({\n     *   token: '0x20c...11',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    withdrawSync: (\n      parameters: dexActions.withdrawSync.Parameters<chain, account>,\n    ) => Promise<dexActions.withdrawSync.ReturnValue>\n    /**\n     * Watches for flip order placed events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.dex.watchFlipOrderPlaced({\n     *   onFlipOrderPlaced: (args, log) => {\n     *     console.log('Flip order placed:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchFlipOrderPlaced: (\n      parameters: dexActions.watchFlipOrderPlaced.Parameters,\n    ) => () => void\n    /**\n     * Watches for order cancelled events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.dex.watchOrderCancelled({\n     *   onOrderCancelled: (args, log) => {\n     *     console.log('Order cancelled:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchOrderCancelled: (\n      parameters: dexActions.watchOrderCancelled.Parameters,\n    ) => () => void\n    /**\n     * Watches for order filled events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.dex.watchOrderFilled({\n     *   onOrderFilled: (args, log) => {\n     *     console.log('Order filled:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchOrderFilled: (\n      parameters: dexActions.watchOrderFilled.Parameters,\n    ) => () => void\n    /**\n     * Watches for order placed events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.dex.watchOrderPlaced({\n     *   onOrderPlaced: (args, log) => {\n     *     console.log('Order placed:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchOrderPlaced: (\n      parameters: dexActions.watchOrderPlaced.Parameters,\n    ) => () => void\n  }\n  faucet: {\n    /**\n     * Funds an account with an initial amount of set token(s)\n     * on Tempo's testnet.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hashes = await client.faucet.fund({\n     *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hashes.\n     */\n    fund: (\n      parameters: faucetActions.fund.Parameters,\n    ) => Promise<faucetActions.fund.ReturnValue>\n    /**\n     * Funds an account with an initial amount of set token(s)\n     * on Tempo's testnet. Waits for the transactions to be included\n     * on a block before returning a response.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const receipts = await client.faucet.fundSync({\n     *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipts.\n     */\n    fundSync: (\n      parameters: faucetActions.fundSync.Parameters,\n    ) => Promise<faucetActions.fundSync.ReturnValue>\n  }\n  nonce: {\n    /**\n     * Gets the nonce for an account and nonce key.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const nonce = await client.nonce.getNonce({\n     *   account: '0x...',\n     *   nonceKey: 1n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The nonce value.\n     */\n    getNonce: (\n      parameters: nonceActions.getNonce.Parameters,\n    ) => Promise<nonceActions.getNonce.ReturnValue>\n    /**\n     * Watches for nonce incremented events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.nonce.watchNonceIncremented({\n     *   onNonceIncremented: (args, log) => {\n     *     console.log('Nonce incremented:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchNonceIncremented: (\n      parameters: nonceActions.watchNonceIncremented.Parameters,\n    ) => () => void\n  }\n  fee: {\n    /**\n     * Gets the user's default fee token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { address, id } = await client.token.getUserToken()\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    getUserToken: (\n      ...parameters: account extends Account\n        ? [feeActions.getUserToken.Parameters<account>] | []\n        : [feeActions.getUserToken.Parameters<account>]\n    ) => Promise<feeActions.getUserToken.ReturnValue>\n    /**\n     * Sets the user's default fee token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.setUserToken({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setUserToken: (\n      parameters: feeActions.setUserToken.Parameters<chain, account>,\n    ) => Promise<feeActions.setUserToken.ReturnValue>\n    /**\n     * Sets the user's default fee token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.fee.setUserTokenSync({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    setUserTokenSync: (\n      parameters: feeActions.setUserTokenSync.Parameters<chain, account>,\n    ) => Promise<feeActions.setUserTokenSync.ReturnValue>\n    /**\n     * Watches for user token set events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchSetUserToken({\n     *   onUserTokenSet: (args, log) => {\n     *     console.log('User token set:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchSetUserToken: (\n      parameters: feeActions.watchSetUserToken.Parameters,\n    ) => () => void\n  }\n  policy: {\n    /**\n     * Creates a new policy.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.policy.create({\n     *   admin: '0x...',\n     *   type: 'whitelist',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    create: (\n      parameters: policyActions.create.Parameters<chain, account>,\n    ) => Promise<policyActions.create.ReturnValue>\n    /**\n     * Creates a new policy.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.policy.createSync({\n     *   admin: '0x...',\n     *   type: 'whitelist',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    createSync: (\n      parameters: policyActions.createSync.Parameters<chain, account>,\n    ) => Promise<policyActions.createSync.ReturnValue>\n    /**\n     * Sets the admin for a policy.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.policy.setAdmin({\n     *   policyId: 2n,\n     *   admin: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setAdmin: (\n      parameters: policyActions.setAdmin.Parameters<chain, account>,\n    ) => Promise<policyActions.setAdmin.ReturnValue>\n    /**\n     * Sets the admin for a policy.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.policy.setAdminSync({\n     *   policyId: 2n,\n     *   admin: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    setAdminSync: (\n      parameters: policyActions.setAdminSync.Parameters<chain, account>,\n    ) => Promise<policyActions.setAdminSync.ReturnValue>\n    /**\n     * Modifies a policy whitelist.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.policy.modifyWhitelist({\n     *   policyId: 2n,\n     *   address: '0x...',\n     *   allowed: true,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    modifyWhitelist: (\n      parameters: policyActions.modifyWhitelist.Parameters<chain, account>,\n    ) => Promise<policyActions.modifyWhitelist.ReturnValue>\n    /**\n     * Modifies a policy whitelist.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.policy.modifyWhitelistSync({\n     *   policyId: 2n,\n     *   address: '0x...',\n     *   allowed: true,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    modifyWhitelistSync: (\n      parameters: policyActions.modifyWhitelistSync.Parameters<chain, account>,\n    ) => Promise<policyActions.modifyWhitelistSync.ReturnValue>\n    /**\n     * Modifies a policy blacklist.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.policy.modifyBlacklist({\n     *   policyId: 2n,\n     *   address: '0x...',\n     *   restricted: true,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    modifyBlacklist: (\n      parameters: policyActions.modifyBlacklist.Parameters<chain, account>,\n    ) => Promise<policyActions.modifyBlacklist.ReturnValue>\n    /**\n     * Modifies a policy blacklist.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.policy.modifyBlacklistSync({\n     *   policyId: 2n,\n     *   address: '0x...',\n     *   restricted: true,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    modifyBlacklistSync: (\n      parameters: policyActions.modifyBlacklistSync.Parameters<chain, account>,\n    ) => Promise<policyActions.modifyBlacklistSync.ReturnValue>\n    /**\n     * Gets policy data.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const data = await client.policy.getData({\n     *   policyId: 2n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The policy data.\n     */\n    getData: (\n      parameters: policyActions.getData.Parameters,\n    ) => Promise<policyActions.getData.ReturnValue>\n    /**\n     * Checks if a user is authorized by a policy.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const authorized = await client.policy.isAuthorized({\n     *   policyId: 2n,\n     *   user: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns Whether the user is authorized.\n     */\n    isAuthorized: (\n      parameters: policyActions.isAuthorized.Parameters,\n    ) => Promise<policyActions.isAuthorized.ReturnValue>\n    /**\n     * Watches for policy creation events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.policy.watchCreate({\n     *   onPolicyCreated: (args, log) => {\n     *     console.log('Policy created:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchCreate: (\n      parameters: policyActions.watchCreate.Parameters,\n    ) => () => void\n    /**\n     * Watches for policy admin update events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.policy.watchAdminUpdated({\n     *   onAdminUpdated: (args, log) => {\n     *     console.log('Policy admin updated:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchAdminUpdated: (\n      parameters: policyActions.watchAdminUpdated.Parameters,\n    ) => () => void\n    /**\n     * Watches for whitelist update events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.policy.watchWhitelistUpdated({\n     *   onWhitelistUpdated: (args, log) => {\n     *     console.log('Whitelist updated:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchWhitelistUpdated: (\n      parameters: policyActions.watchWhitelistUpdated.Parameters,\n    ) => () => void\n    /**\n     * Watches for blacklist update events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.policy.watchBlacklistUpdated({\n     *   onBlacklistUpdated: (args, log) => {\n     *     console.log('Blacklist updated:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchBlacklistUpdated: (\n      parameters: policyActions.watchBlacklistUpdated.Parameters,\n    ) => () => void\n  }\n  reward: {\n    /**\n     * Claims accumulated rewards for a recipient.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.reward.claim({\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    claim: (\n      parameters: rewardActions.claim.Parameters<chain, account>,\n    ) => Promise<rewardActions.claim.ReturnValue>\n    /**\n     * Claims accumulated rewards for a recipient and waits for confirmation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.reward.claimSync({\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The amount claimed and transaction receipt.\n     */\n    claimSync: (\n      parameters: rewardActions.claimSync.Parameters<chain, account>,\n    ) => Promise<rewardActions.claimSync.ReturnValue>\n    /**\n     * Distributes rewards to opted-in token holders.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.reward.distribute({\n     *   amount: 100000000000000000000n,\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    distribute: (\n      parameters: rewardActions.distribute.Parameters<chain, account>,\n    ) => Promise<rewardActions.distribute.ReturnValue>\n    /**\n     * Distributes rewards to opted-in token holders and waits for confirmation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { funder, amount, receipt } = await client.reward.distributeSync({\n     *   amount: 100000000000000000000n,\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The funder, amount, and transaction receipt.\n     */\n    distributeSync: (\n      parameters: rewardActions.distributeSync.Parameters<chain, account>,\n    ) => Promise<rewardActions.distributeSync.ReturnValue>\n    /**\n     * Gets the reward information for a specific account.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const info = await client.reward.getUserRewardInfo({\n     *   token: '0x20c0000000000000000000000000000000000001',\n     *   account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The user's reward information (recipient, rewardPerToken, rewardBalance).\n     */\n    getUserRewardInfo: (\n      parameters: rewardActions.getUserRewardInfo.Parameters,\n    ) => Promise<rewardActions.getUserRewardInfo.ReturnValue>\n    /**\n     * Sets or changes the reward recipient for a token holder.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.reward.setRecipient({\n     *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setRecipient: (\n      parameters: rewardActions.setRecipient.Parameters<chain, account>,\n    ) => Promise<rewardActions.setRecipient.ReturnValue>\n    /**\n     * Sets or changes the reward recipient for a token holder and waits for confirmation.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.reward.setRecipientSync({\n     *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n     *   token: '0x20c0000000000000000000000000000000000001',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    setRecipientSync: (\n      parameters: rewardActions.setRecipientSync.Parameters<chain, account>,\n    ) => Promise<rewardActions.setRecipientSync.ReturnValue>\n    /**\n     * Watches for reward distributed events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.reward.watchRewardDistributed({\n     *   token: '0x20c0000000000000000000000000000000000001',\n     *   onRewardDistributed: (args, log) => {\n     *     console.log('Reward distributed:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchRewardDistributed: (\n      parameters: rewardActions.watchRewardDistributed.Parameters,\n    ) => () => void\n    /**\n     * Watches for reward recipient set events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.reward.watchRewardRecipientSet({\n     *   token: '0x20c0000000000000000000000000000000000001',\n     *   onRewardRecipientSet: (args, log) => {\n     *     console.log('Reward recipient set:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchRewardRecipientSet: (\n      parameters: rewardActions.watchRewardRecipientSet.Parameters,\n    ) => () => void\n  }\n  token: {\n    /**\n     * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.approve({\n     *   spender: '0x...',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    approve: (\n      parameters: tokenActions.approve.Parameters<chain, account>,\n    ) => Promise<tokenActions.approve.ReturnValue>\n    /**\n     * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.approveSync({\n     *   spender: '0x...',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    approveSync: (\n      parameters: tokenActions.approveSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.approveSync.ReturnValue>\n    /**\n     * Burns TIP20 tokens from a blocked address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.burnBlocked({\n     *   from: '0x...',\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    burnBlocked: (\n      parameters: tokenActions.burnBlocked.Parameters<chain, account>,\n    ) => Promise<tokenActions.burnBlocked.ReturnValue>\n    /**\n     * Burns TIP20 tokens from a blocked address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.burnBlockedSync({\n     *   from: '0x...',\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    burnBlockedSync: (\n      parameters: tokenActions.burnBlockedSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.burnBlockedSync.ReturnValue>\n    /**\n     * Burns TIP20 tokens from the caller's balance.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.burn({\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    burn: (\n      parameters: tokenActions.burn.Parameters<chain, account>,\n    ) => Promise<tokenActions.burn.ReturnValue>\n    /**\n     * Burns TIP20 tokens from the caller's balance.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.burnSync({\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    burnSync: (\n      parameters: tokenActions.burnSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.burnSync.ReturnValue>\n    /**\n     * Changes the transfer policy ID for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.changeTransferPolicy({\n     *   token: '0x...',\n     *   policyId: 1n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    changeTransferPolicy: (\n      parameters: tokenActions.changeTransferPolicy.Parameters<chain, account>,\n    ) => Promise<tokenActions.changeTransferPolicy.ReturnValue>\n    /**\n     * Changes the transfer policy ID for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.changeTransferPolicySync({\n     *   token: '0x...',\n     *   policyId: 1n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    changeTransferPolicySync: (\n      parameters: tokenActions.changeTransferPolicySync.Parameters<\n        chain,\n        account\n      >,\n    ) => Promise<tokenActions.changeTransferPolicySync.ReturnValue>\n    /**\n     * Creates a new TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { hash, id, address } = await client.token.create({\n     *   name: 'My Token',\n     *   symbol: 'MTK',\n     *   currency: 'USD',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    create: (\n      parameters: tokenActions.create.Parameters<chain, account>,\n    ) => Promise<tokenActions.create.ReturnValue>\n    /**\n     * Creates a new TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.createSync({\n     *   name: 'My Token',\n     *   symbol: 'MTK',\n     *   currency: 'USD',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    createSync: (\n      parameters: tokenActions.createSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.createSync.ReturnValue>\n    /**\n     * Gets TIP20 token allowance.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const allowance = await client.token.getAllowance({\n     *   spender: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The token allowance.\n     */\n    getAllowance: (\n      parameters: tokenActions.getAllowance.Parameters,\n    ) => Promise<tokenActions.getAllowance.ReturnValue>\n    /**\n     * Gets TIP20 token balance for an address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const balance = await client.token.getBalance()\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The token balance.\n     */\n    getBalance: (\n      parameters: tokenActions.getBalance.Parameters<account>,\n    ) => Promise<tokenActions.getBalance.ReturnValue>\n    /**\n     * Gets TIP20 token metadata including name, symbol, currency, decimals, and total supply.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const metadata = await client.token.getMetadata({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The token metadata.\n     */\n    getMetadata: (\n      parameters: tokenActions.getMetadata.Parameters,\n    ) => Promise<tokenActions.getMetadata.ReturnValue>\n    /**\n     * Gets the admin role for a specific role in a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const adminRole = await client.token.getRoleAdmin({\n     *   role: 'issuer',\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The admin role hash.\n     */\n    getRoleAdmin: (\n      parameters: tokenActions.getRoleAdmin.Parameters,\n    ) => Promise<tokenActions.getRoleAdmin.ReturnValue>\n    /**\n     * Checks if an account has a specific role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hasRole = await client.token.hasRole({\n     *   token: '0x...',\n     *   role: 'issuer',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns Whether the account has the role.\n     */\n    hasRole: (\n      parameters: tokenActions.hasRole.Parameters<account>,\n    ) => Promise<tokenActions.hasRole.ReturnValue>\n    /**\n     * Grants a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.grantRoles({\n     *   token: '0x...',\n     *   to: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    grantRoles: (\n      parameters: tokenActions.grantRoles.Parameters<chain, account>,\n    ) => Promise<tokenActions.grantRoles.ReturnValue>\n    /**\n     * Grants a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.grantRolesSync({\n     *   token: '0x...',\n     *   to: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    grantRolesSync: (\n      parameters: tokenActions.grantRolesSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.grantRolesSync.ReturnValue>\n    /**\n     * Mints TIP20 tokens to an address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.mint({\n     *   to: '0x...',\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    mint: (\n      parameters: tokenActions.mint.Parameters<chain, account>,\n    ) => Promise<tokenActions.mint.ReturnValue>\n    /**\n     * Mints TIP20 tokens to an address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.mintSync({\n     *   to: '0x...',\n     *   amount: 100n,\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    mintSync: (\n      parameters: tokenActions.mintSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.mintSync.ReturnValue>\n    /**\n     * Pauses a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.pause({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    pause: (\n      parameters: tokenActions.pause.Parameters<chain, account>,\n    ) => Promise<tokenActions.pause.ReturnValue>\n    /**\n     * Pauses a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.pauseSync({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    pauseSync: (\n      parameters: tokenActions.pauseSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.pauseSync.ReturnValue>\n    /**\n     * Renounces a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.renounceRoles({\n     *   token: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    renounceRoles: (\n      parameters: tokenActions.renounceRoles.Parameters<chain, account>,\n    ) => Promise<tokenActions.renounceRoles.ReturnValue>\n    /**\n     * Renounces a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.renounceRolesSync({\n     *   token: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    renounceRolesSync: (\n      parameters: tokenActions.renounceRolesSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.renounceRolesSync.ReturnValue>\n    /**\n     * Revokes a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.revokeRoles({\n     *   token: '0x...',\n     *   from: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    revokeRoles: (\n      parameters: tokenActions.revokeRoles.Parameters<chain, account>,\n    ) => Promise<tokenActions.revokeRoles.ReturnValue>\n    /**\n     * Revokes a role for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.revokeRolesSync({\n     *   token: '0x...',\n     *   from: '0x...',\n     *   roles: ['issuer'],\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    revokeRolesSync: (\n      parameters: tokenActions.revokeRolesSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.revokeRolesSync.ReturnValue>\n    /**\n     * Sets the supply cap for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.setSupplyCap({\n     *   token: '0x...',\n     *   supplyCap: 1000000n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setSupplyCap: (\n      parameters: tokenActions.setSupplyCap.Parameters<chain, account>,\n    ) => Promise<tokenActions.setSupplyCap.ReturnValue>\n    /**\n     * Sets the supply cap for a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.setSupplyCapSync({\n     *   token: '0x...',\n     *   supplyCap: 1000000n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    setSupplyCapSync: (\n      parameters: tokenActions.setSupplyCapSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.setSupplyCapSync.ReturnValue>\n    /**\n     * Sets the admin role for a specific role in a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.setRoleAdmin({\n     *   token: '0x...',\n     *   role: 'issuer',\n     *   adminRole: 'admin',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setRoleAdmin: (\n      parameters: tokenActions.setRoleAdmin.Parameters<chain, account>,\n    ) => Promise<tokenActions.setRoleAdmin.ReturnValue>\n    /**\n     * Sets the admin role for a specific role in a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.setRoleAdminSync({\n     *   token: '0x...',\n     *   role: 'issuer',\n     *   adminRole: 'admin',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    setRoleAdminSync: (\n      parameters: tokenActions.setRoleAdminSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.setRoleAdminSync.ReturnValue>\n    /**\n     * Transfers TIP20 tokens to another address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.transfer({\n     *   to: '0x...',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    transfer: (\n      parameters: tokenActions.transfer.Parameters<chain, account>,\n    ) => Promise<tokenActions.transfer.ReturnValue>\n    /**\n     * Transfers TIP20 tokens to another address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.transferSync({\n     *   to: '0x...',\n     *   amount: 100n,\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    transferSync: (\n      parameters: tokenActions.transferSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.transferSync.ReturnValue>\n    /**\n     * Unpauses a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.token.unpause({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    unpause: (\n      parameters: tokenActions.unpause.Parameters<chain, account>,\n    ) => Promise<tokenActions.unpause.ReturnValue>\n    /**\n     * Unpauses a TIP20 token.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const result = await client.token.unpauseSync({\n     *   token: '0x...',\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns The transaction receipt and event data.\n     */\n    unpauseSync: (\n      parameters: tokenActions.unpauseSync.Parameters<chain, account>,\n    ) => Promise<tokenActions.unpauseSync.ReturnValue>\n    /**\n     * Watches for TIP20 token approval events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchApprove({\n     *   onApproval: (args, log) => {\n     *     console.log('Approval:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchApprove: (\n      parameters: tokenActions.watchApprove.Parameters,\n    ) => () => void\n    /**\n     * Watches for TIP20 token burn events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchBurn({\n     *   onBurn: (args, log) => {\n     *     console.log('Burn:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchBurn: (parameters: tokenActions.watchBurn.Parameters) => () => void\n    /**\n     * Watches for new TIP20 tokens created.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchCreate({\n     *   onTokenCreated: (args, log) => {\n     *     console.log('Token created:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchCreate: (parameters: tokenActions.watchCreate.Parameters) => () => void\n    /**\n     * Watches for TIP20 token mint events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchMint({\n     *   onMint: (args, log) => {\n     *     console.log('Mint:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchMint: (parameters: tokenActions.watchMint.Parameters) => () => void\n    /**\n     * Watches for TIP20 token role admin updates.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchAdminRole({\n     *   onRoleAdminUpdated: (args, log) => {\n     *     console.log('Role admin updated:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchAdminRole: (\n      parameters: tokenActions.watchAdminRole.Parameters,\n    ) => () => void\n    /**\n     * Watches for TIP20 token role membership updates.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchRole({\n     *   onRoleUpdated: (args, log) => {\n     *     console.log('Role updated:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchRole: (parameters: tokenActions.watchRole.Parameters) => () => void\n    /**\n     * Watches for TIP20 token transfer events.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const unwatch = client.token.watchTransfer({\n     *   onTransfer: (args, log) => {\n     *     console.log('Transfer:', args)\n     *   },\n     * })\n     * ```\n     *\n     * @param client - Client.\n     * @param parameters - Parameters.\n     * @returns A function to unsubscribe from the event.\n     */\n    watchTransfer: (\n      parameters: tokenActions.watchTransfer.Parameters,\n    ) => () => void\n  }\n  validator: {\n    /**\n     * Adds a new validator (owner only).\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.validator.add({\n     *   newValidatorAddress: '0x...',\n     *   publicKey: '0x...',\n     *   active: true,\n     *   inboundAddress: '192.168.1.1:8080',\n     *   outboundAddress: '192.168.1.1:8080',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    add: (\n      parameters: validatorActions.add.Parameters<chain, account>,\n    ) => Promise<validatorActions.add.ReturnValue>\n    /**\n     * Adds a new validator (owner only) and waits for the transaction receipt.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt } = await client.validator.addSync({\n     *   newValidatorAddress: '0x...',\n     *   publicKey: '0x...',\n     *   active: true,\n     *   inboundAddress: '192.168.1.1:8080',\n     *   outboundAddress: '192.168.1.1:8080',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    addSync: (\n      parameters: validatorActions.addSync.Parameters<chain, account>,\n    ) => Promise<validatorActions.addSync.ReturnValue>\n    /**\n     * Changes the owner of the validator config precompile.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.validator.changeOwner({\n     *   newOwner: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    changeOwner: (\n      parameters: validatorActions.changeOwner.Parameters<chain, account>,\n    ) => Promise<validatorActions.changeOwner.ReturnValue>\n    /**\n     * Changes the owner of the validator config precompile and waits for the transaction receipt.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt } = await client.validator.changeOwnerSync({\n     *   newOwner: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    changeOwnerSync: (\n      parameters: validatorActions.changeOwnerSync.Parameters<chain, account>,\n    ) => Promise<validatorActions.changeOwnerSync.ReturnValue>\n    /**\n     * Changes validator active status (owner only).\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.validator.changeStatus({\n     *   validator: '0x...',\n     *   active: false,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    changeStatus: (\n      parameters: validatorActions.changeStatus.Parameters<chain, account>,\n    ) => Promise<validatorActions.changeStatus.ReturnValue>\n    /**\n     * Changes validator active status and waits for the transaction receipt.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt } = await client.validator.changeStatusSync({\n     *   validator: '0x...',\n     *   active: false,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    changeStatusSync: (\n      parameters: validatorActions.changeStatusSync.Parameters<chain, account>,\n    ) => Promise<validatorActions.changeStatusSync.ReturnValue>\n    /**\n     * Gets validator information by address.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const validator = await client.validator.get({\n     *   validator: '0x...',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The validator information.\n     */\n    get: (\n      parameters: validatorActions.get.Parameters,\n    ) => Promise<validatorActions.get.ReturnValue>\n    /**\n     * Gets validator address by index.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const validatorAddress = await client.validator.getByIndex({\n     *   index: 0n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The validator address at the given index.\n     */\n    getByIndex: (\n      parameters: validatorActions.getByIndex.Parameters,\n    ) => Promise<validatorActions.getByIndex.ReturnValue>\n    /**\n     * Gets the total number of validators.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const count = await client.validator.getCount()\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The total number of validators.\n     */\n    getCount: (\n      parameters?: validatorActions.getCount.Parameters,\n    ) => Promise<validatorActions.getCount.ReturnValue>\n    /**\n     * Gets the next epoch for a full DKG ceremony.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const epoch = await client.validator.getNextFullDkgCeremony()\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The epoch number for the next full DKG ceremony.\n     */\n    getNextFullDkgCeremony: (\n      parameters?: validatorActions.getNextFullDkgCeremony.Parameters,\n    ) => Promise<validatorActions.getNextFullDkgCeremony.ReturnValue>\n    /**\n     * Gets the contract owner.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const owner = await client.validator.getOwner()\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The owner address.\n     */\n    getOwner: (\n      parameters?: validatorActions.getOwner.Parameters,\n    ) => Promise<validatorActions.getOwner.ReturnValue>\n    /**\n     * Gets the complete set of validators.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const validators = await client.validator.list()\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns Array of all validators with their information.\n     */\n    list: (\n      parameters?: validatorActions.list.Parameters,\n    ) => Promise<validatorActions.list.ReturnValue>\n    /**\n     * Sets the next epoch for a full DKG ceremony.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.validator.setNextFullDkgCeremony({\n     *   epoch: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    setNextFullDkgCeremony: (\n      parameters: validatorActions.setNextFullDkgCeremony.Parameters<\n        chain,\n        account\n      >,\n    ) => Promise<validatorActions.setNextFullDkgCeremony.ReturnValue>\n    /**\n     * Sets the next epoch for a full DKG ceremony and waits for the transaction receipt.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt } = await client.validator.setNextFullDkgCeremonySync({\n     *   epoch: 100n,\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    setNextFullDkgCeremonySync: (\n      parameters: validatorActions.setNextFullDkgCeremonySync.Parameters<\n        chain,\n        account\n      >,\n    ) => Promise<validatorActions.setNextFullDkgCeremonySync.ReturnValue>\n    /**\n     * Updates validator information (only callable by the validator themselves).\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const hash = await client.validator.update({\n     *   newValidatorAddress: '0x...',\n     *   publicKey: '0x...',\n     *   inboundAddress: '192.168.1.1:8080',\n     *   outboundAddress: '192.168.1.1:8080',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction hash.\n     */\n    update: (\n      parameters: validatorActions.update.Parameters<chain, account>,\n    ) => Promise<validatorActions.update.ReturnValue>\n    /**\n     * Updates validator information and waits for the transaction receipt.\n     *\n     * @example\n     * ```ts\n     * import { createClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { tempo } from 'viem/chains'\n     * import { tempoActions } from 'viem/tempo'\n     *\n     * const client = createClient({\n     *   account: privateKeyToAccount('0x...'),\n     *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n     *   transport: http(),\n     * }).extend(tempoActions())\n     *\n     * const { receipt } = await client.validator.updateSync({\n     *   newValidatorAddress: '0x...',\n     *   publicKey: '0x...',\n     *   inboundAddress: '192.168.1.1:8080',\n     *   outboundAddress: '192.168.1.1:8080',\n     * })\n     * ```\n     *\n     * @param parameters - Parameters.\n     * @returns The transaction receipt.\n     */\n    updateSync: (\n      parameters: validatorActions.updateSync.Parameters<chain, account>,\n    ) => Promise<validatorActions.updateSync.ReturnValue>\n  }\n}\n\nexport function decorator() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Decorator<chain, account> => {\n    return {\n      amm: {\n        getPool: (parameters) => ammActions.getPool(client, parameters),\n        getLiquidityBalance: (parameters) =>\n          ammActions.getLiquidityBalance(client, parameters),\n        burn: (parameters) => ammActions.burn(client, parameters),\n        burnSync: (parameters) => ammActions.burnSync(client, parameters),\n        mint: (parameters) => ammActions.mint(client, parameters),\n        mintSync: (parameters) => ammActions.mintSync(client, parameters),\n        rebalanceSwap: (parameters) =>\n          ammActions.rebalanceSwap(client, parameters),\n        rebalanceSwapSync: (parameters) =>\n          ammActions.rebalanceSwapSync(client, parameters),\n        watchBurn: (parameters) => ammActions.watchBurn(client, parameters),\n        watchMint: (parameters) => ammActions.watchMint(client, parameters),\n        watchRebalanceSwap: (parameters) =>\n          ammActions.watchRebalanceSwap(client, parameters),\n      },\n      dex: {\n        buy: (parameters) => dexActions.buy(client, parameters),\n        buySync: (parameters) => dexActions.buySync(client, parameters),\n        cancel: (parameters) => dexActions.cancel(client, parameters),\n        cancelSync: (parameters) => dexActions.cancelSync(client, parameters),\n        cancelStale: (parameters) => dexActions.cancelStale(client, parameters),\n        cancelStaleSync: (parameters) =>\n          dexActions.cancelStaleSync(client, parameters),\n        createPair: (parameters) => dexActions.createPair(client, parameters),\n        createPairSync: (parameters) =>\n          dexActions.createPairSync(client, parameters),\n        getBalance: (parameters) => dexActions.getBalance(client, parameters),\n        getBuyQuote: (parameters) => dexActions.getBuyQuote(client, parameters),\n        getOrder: (parameters) => dexActions.getOrder(client, parameters),\n        getTickLevel: (parameters) =>\n          dexActions.getTickLevel(client, parameters),\n        getSellQuote: (parameters) =>\n          dexActions.getSellQuote(client, parameters),\n        place: (parameters) => dexActions.place(client, parameters),\n        placeSync: (parameters) => dexActions.placeSync(client, parameters),\n        placeFlip: (parameters) => dexActions.placeFlip(client, parameters),\n        placeFlipSync: (parameters) =>\n          dexActions.placeFlipSync(client, parameters),\n        sell: (parameters) => dexActions.sell(client, parameters),\n        sellSync: (parameters) => dexActions.sellSync(client, parameters),\n        withdraw: (parameters) => dexActions.withdraw(client, parameters),\n        withdrawSync: (parameters) =>\n          dexActions.withdrawSync(client, parameters),\n        watchFlipOrderPlaced: (parameters) =>\n          dexActions.watchFlipOrderPlaced(client, parameters),\n        watchOrderCancelled: (parameters) =>\n          dexActions.watchOrderCancelled(client, parameters),\n        watchOrderFilled: (parameters) =>\n          dexActions.watchOrderFilled(client, parameters),\n        watchOrderPlaced: (parameters) =>\n          dexActions.watchOrderPlaced(client, parameters),\n      },\n      faucet: {\n        fund: (parameters) => faucetActions.fund(client, parameters),\n        fundSync: (parameters) => faucetActions.fundSync(client, parameters),\n      },\n      nonce: {\n        getNonce: (parameters) => nonceActions.getNonce(client, parameters),\n        watchNonceIncremented: (parameters) =>\n          nonceActions.watchNonceIncremented(client, parameters),\n      },\n      fee: {\n        // @ts-expect-error\n        getUserToken: (parameters) =>\n          // @ts-expect-error\n          feeActions.getUserToken(client, parameters),\n        setUserToken: (parameters) =>\n          feeActions.setUserToken(client, parameters),\n        setUserTokenSync: (parameters) =>\n          feeActions.setUserTokenSync(client, parameters),\n        watchSetUserToken: (parameters) =>\n          feeActions.watchSetUserToken(client, parameters),\n      },\n      policy: {\n        create: (parameters) => policyActions.create(client, parameters),\n        createSync: (parameters) =>\n          policyActions.createSync(client, parameters),\n        setAdmin: (parameters) => policyActions.setAdmin(client, parameters),\n        setAdminSync: (parameters) =>\n          policyActions.setAdminSync(client, parameters),\n        modifyWhitelist: (parameters) =>\n          policyActions.modifyWhitelist(client, parameters),\n        modifyWhitelistSync: (parameters) =>\n          policyActions.modifyWhitelistSync(client, parameters),\n        modifyBlacklist: (parameters) =>\n          policyActions.modifyBlacklist(client, parameters),\n        modifyBlacklistSync: (parameters) =>\n          policyActions.modifyBlacklistSync(client, parameters),\n        getData: (parameters) => policyActions.getData(client, parameters),\n        isAuthorized: (parameters) =>\n          policyActions.isAuthorized(client, parameters),\n        watchCreate: (parameters) =>\n          policyActions.watchCreate(client, parameters),\n        watchAdminUpdated: (parameters) =>\n          policyActions.watchAdminUpdated(client, parameters),\n        watchWhitelistUpdated: (parameters) =>\n          policyActions.watchWhitelistUpdated(client, parameters),\n        watchBlacklistUpdated: (parameters) =>\n          policyActions.watchBlacklistUpdated(client, parameters),\n      },\n      reward: {\n        claim: (parameters) => rewardActions.claim(client, parameters),\n        claimSync: (parameters) => rewardActions.claimSync(client, parameters),\n        distribute: (parameters) =>\n          rewardActions.distribute(client, parameters),\n        distributeSync: (parameters) =>\n          rewardActions.distributeSync(client, parameters),\n        getUserRewardInfo: (parameters) =>\n          rewardActions.getUserRewardInfo(client, parameters),\n        setRecipient: (parameters) =>\n          rewardActions.setRecipient(client, parameters),\n        setRecipientSync: (parameters) =>\n          rewardActions.setRecipientSync(client, parameters),\n        watchRewardDistributed: (parameters) =>\n          rewardActions.watchRewardDistributed(client, parameters),\n        watchRewardRecipientSet: (parameters) =>\n          rewardActions.watchRewardRecipientSet(client, parameters),\n      },\n      token: {\n        approve: (parameters) => tokenActions.approve(client, parameters),\n        approveSync: (parameters) =>\n          tokenActions.approveSync(client, parameters),\n        burnBlocked: (parameters) =>\n          tokenActions.burnBlocked(client, parameters),\n        burnBlockedSync: (parameters) =>\n          tokenActions.burnBlockedSync(client, parameters),\n        burn: (parameters) => tokenActions.burn(client, parameters),\n        burnSync: (parameters) => tokenActions.burnSync(client, parameters),\n        changeTransferPolicy: (parameters) =>\n          tokenActions.changeTransferPolicy(client, parameters),\n        changeTransferPolicySync: (parameters) =>\n          tokenActions.changeTransferPolicySync(client, parameters),\n        create: (parameters) => tokenActions.create(client, parameters),\n        createSync: (parameters) => tokenActions.createSync(client, parameters),\n        getAllowance: (parameters) =>\n          tokenActions.getAllowance(client, parameters),\n        getBalance: (parameters) => tokenActions.getBalance(client, parameters),\n        getMetadata: (parameters) =>\n          tokenActions.getMetadata(client, parameters),\n        getRoleAdmin: (parameters) =>\n          tokenActions.getRoleAdmin(client, parameters),\n        hasRole: (parameters) => tokenActions.hasRole(client, parameters),\n        grantRoles: (parameters) => tokenActions.grantRoles(client, parameters),\n        grantRolesSync: (parameters) =>\n          tokenActions.grantRolesSync(client, parameters),\n        mint: (parameters) => tokenActions.mint(client, parameters),\n        mintSync: (parameters) => tokenActions.mintSync(client, parameters),\n        pause: (parameters) => tokenActions.pause(client, parameters),\n        pauseSync: (parameters) => tokenActions.pauseSync(client, parameters),\n        renounceRoles: (parameters) =>\n          tokenActions.renounceRoles(client, parameters),\n        renounceRolesSync: (parameters) =>\n          tokenActions.renounceRolesSync(client, parameters),\n        revokeRoles: (parameters) =>\n          tokenActions.revokeRoles(client, parameters),\n        revokeRolesSync: (parameters) =>\n          tokenActions.revokeRolesSync(client, parameters),\n        setSupplyCap: (parameters) =>\n          tokenActions.setSupplyCap(client, parameters),\n        setSupplyCapSync: (parameters) =>\n          tokenActions.setSupplyCapSync(client, parameters),\n        setRoleAdmin: (parameters) =>\n          tokenActions.setRoleAdmin(client, parameters),\n        setRoleAdminSync: (parameters) =>\n          tokenActions.setRoleAdminSync(client, parameters),\n        transfer: (parameters) => tokenActions.transfer(client, parameters),\n        transferSync: (parameters) =>\n          tokenActions.transferSync(client, parameters),\n        unpause: (parameters) => tokenActions.unpause(client, parameters),\n        unpauseSync: (parameters) =>\n          tokenActions.unpauseSync(client, parameters),\n        watchApprove: (parameters) =>\n          tokenActions.watchApprove(client, parameters),\n        watchBurn: (parameters) => tokenActions.watchBurn(client, parameters),\n        watchCreate: (parameters) =>\n          tokenActions.watchCreate(client, parameters),\n        watchMint: (parameters) => tokenActions.watchMint(client, parameters),\n        watchAdminRole: (parameters) =>\n          tokenActions.watchAdminRole(client, parameters),\n        watchRole: (parameters) => tokenActions.watchRole(client, parameters),\n        watchTransfer: (parameters) =>\n          tokenActions.watchTransfer(client, parameters),\n      },\n      validator: {\n        add: (parameters) => validatorActions.add(client, parameters),\n        addSync: (parameters) => validatorActions.addSync(client, parameters),\n        changeOwner: (parameters) =>\n          validatorActions.changeOwner(client, parameters),\n        changeOwnerSync: (parameters) =>\n          validatorActions.changeOwnerSync(client, parameters),\n        changeStatus: (parameters) =>\n          validatorActions.changeStatus(client, parameters),\n        changeStatusSync: (parameters) =>\n          validatorActions.changeStatusSync(client, parameters),\n        get: (parameters) => validatorActions.get(client, parameters),\n        getByIndex: (parameters) =>\n          validatorActions.getByIndex(client, parameters),\n        getCount: (parameters) => validatorActions.getCount(client, parameters),\n        getNextFullDkgCeremony: (parameters) =>\n          validatorActions.getNextFullDkgCeremony(client, parameters),\n        getOwner: (parameters) => validatorActions.getOwner(client, parameters),\n        list: (parameters) => validatorActions.list(client, parameters),\n        setNextFullDkgCeremony: (parameters) =>\n          validatorActions.setNextFullDkgCeremony(client, parameters),\n        setNextFullDkgCeremonySync: (parameters) =>\n          validatorActions.setNextFullDkgCeremonySync(client, parameters),\n        update: (parameters) => validatorActions.update(client, parameters),\n        updateSync: (parameters) =>\n          validatorActions.updateSync(client, parameters),\n      },\n    }\n  }\n}\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport { randomPrivateKey } from 'ox/P256'\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport { randomPrivateKey } from 'ox/Secp256k1'\n", "export const pathUsd = 0n\n", "import * as Address from 'ox/Address'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport * as Provider from 'ox/Provider'\nimport * as RpcRequest from 'ox/RpcRequest'\nimport type { LocalAccount } from '../accounts/types.js'\nimport { getTransactionReceipt } from '../actions/public/getTransactionReceipt.js'\nimport { sendTransaction } from '../actions/wallet/sendTransaction.js'\nimport { sendTransactionSync } from '../actions/wallet/sendTransactionSync.js'\nimport { createClient } from '../clients/createClient.js'\nimport {\n  createTransport,\n  type Transport,\n} from '../clients/transports/createTransport.js'\nimport type { Chain } from '../types/chain.js'\nimport type { ChainConfig } from './chainConfig.js'\nimport * as Transaction from './Transaction.js'\n\nexport type FeePayer = Transport<typeof withFeePayer.type>\n\n/**\n * Creates a fee payer transport that routes requests between\n * the default transport or the fee payer transport.\n *\n * The policy parameter controls how the fee payer handles transactions:\n * - `'sign-only'`: Fee payer co-signs the transaction and returns it to the client transport, which then broadcasts it via the default transport\n * - `'sign-and-broadcast'`: Fee payer co-signs and broadcasts the transaction directly\n *\n * @param defaultTransport - The default transport to use.\n * @param feePayerTransport - The fee payer transport to use.\n * @param parameters - Configuration parameters.\n * @returns A relay transport.\n */\nexport function withFeePayer(\n  defaultTransport: Transport,\n  relayTransport: Transport,\n  parameters?: withFeePayer.Parameters,\n): withFeePayer.ReturnValue {\n  const { policy = 'sign-only' } = parameters ?? {}\n\n  return (config) => {\n    const transport_default = defaultTransport(config)\n    const transport_relay = relayTransport(config)\n\n    return createTransport({\n      key: withFeePayer.type,\n      name: 'Relay Proxy',\n      async request({ method, params }, options) {\n        if (\n          method === 'eth_sendRawTransactionSync' ||\n          method === 'eth_sendRawTransaction'\n        ) {\n          const serialized = (params as any)[0] as `0x76${string}`\n          const transaction = Transaction.deserialize(serialized)\n\n          // If the transaction is intended to be sponsored, forward it to the relay.\n          if (transaction.feePayerSignature === null) {\n            // For 'sign-and-broadcast', relay signs and broadcasts\n            if (policy === 'sign-and-broadcast')\n              return transport_relay.request(\n                { method, params },\n                options,\n              ) as never\n\n            // For 'sign-only', request signature from relay using eth_signRawTransaction\n            {\n              // Request signature from relay using eth_signRawTransaction\n              const signedTransaction = await transport_relay.request(\n                {\n                  method: 'eth_signRawTransaction',\n                  params: [serialized],\n                },\n                options,\n              )\n\n              // Broadcast the signed transaction via the default transport\n              return transport_default.request(\n                { method, params: [signedTransaction] },\n                options,\n              ) as never\n            }\n          }\n        }\n        return (await transport_default.request(\n          { method, params },\n          options,\n        )) as never\n      },\n      type: withFeePayer.type,\n    })\n  }\n}\n\nexport declare namespace withFeePayer {\n  export const type = 'feePayer'\n\n  export type Parameters = {\n    /** Policy for how the fee payer should handle transactions. Defaults to `'sign-only'`. */\n    policy?: 'sign-only' | 'sign-and-broadcast' | undefined\n  }\n\n  export type ReturnValue = FeePayer\n}\n\n/**\n * Creates a transport that instruments a compatibility layer for\n * `wallet_` RPC actions (`sendCalls`, `getCallsStatus`, etc).\n *\n * @param transport - Transport to wrap.\n * @returns Transport.\n */\nexport function walletNamespaceCompat(\n  transport: Transport,\n  options: walletNamespaceCompat.Parameters,\n): Transport {\n  const { account } = options\n\n  const sendCallsMagic = Hash.keccak256(Hex.fromString('TEMPO_5792'))\n\n  return (options) => {\n    const t = transport(options)\n\n    const chain = options.chain as Chain & ChainConfig\n\n    return {\n      ...t,\n      async request(args: never) {\n        const request = RpcRequest.from(args)\n\n        const client = createClient({\n          chain,\n          transport,\n        })\n\n        if (request.method === 'wallet_sendCalls') {\n          const params = request.params[0] ?? {}\n          const { capabilities, chainId, from } = params\n          const { sync, ...properties } = capabilities ?? {}\n\n          if (!chainId) throw new Provider.UnsupportedChainIdError()\n          if (Number(chainId) !== client.chain.id)\n            throw new Provider.UnsupportedChainIdError()\n          if (from && !Address.isEqual(from, account.address))\n            throw new Provider.DisconnectedError()\n\n          const calls = (params.calls ?? []).map((call) => ({\n            to: call.to,\n            value: call.value ? BigInt(call.value) : undefined,\n            data: call.data,\n          }))\n\n          const hash = await (async () => {\n            if (!sync)\n              return sendTransaction(client, {\n                account,\n                ...(properties ? properties : {}),\n                calls,\n              })\n\n            const { transactionHash } = await sendTransactionSync(client, {\n              account,\n              ...(properties ? properties : {}),\n              calls,\n            })\n            return transactionHash\n          })()\n\n          const id = Hex.concat(hash, Hex.padLeft(chainId, 32), sendCallsMagic)\n\n          return {\n            capabilities: { sync },\n            id,\n          }\n        }\n\n        if (request.method === 'wallet_getCallsStatus') {\n          const [id] = request.params ?? []\n          if (!id) throw new Error('`id` not found')\n          if (!id.endsWith(sendCallsMagic.slice(2)))\n            throw new Error('`id` not supported')\n          Hex.assert(id)\n\n          const hash = Hex.slice(id, 0, 32)\n          const chainId = Hex.slice(id, 32, 64)\n\n          const receipt = await getTransactionReceipt(client, { hash })\n          return {\n            atomic: true,\n            chainId: Number(chainId),\n            id,\n            receipts: [receipt],\n            status: receipt.status === 'success' ? 200 : 500,\n            version: '2.0.0',\n          }\n        }\n\n        return t.request(args)\n      },\n    } as never\n  }\n}\n\nexport declare namespace walletNamespaceCompat {\n  export type Parameters = {\n    account: LocalAccount\n  }\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "import type { Errors, RpcRequest } from '../index.js'\nimport type {\n  Compute,\n  IsNarrowable,\n  IsNever,\n  OneOf,\n  UnionPartialBy,\n} from './internal/types.js'\n\n/** A JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcResponse<\n  result = unknown,\n  error extends ErrorObject = ErrorObject,\n> = Compute<\n  {\n    id: number\n    jsonrpc: '2.0'\n  } & OneOf<{ result: result } | { error: error }>\n>\n\n/** JSON-RPC error object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object). */\nexport type ErrorObject = {\n  code: number\n  message: string\n  data?: unknown | undefined\n}\n\n/**\n * A type-safe interface to instantiate a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object).\n *\n * @example\n * ### Instantiating a Response Object\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * @example\n * ### Type-safe Instantiation\n *\n * If you have a JSON-RPC request object, you can use it to strongly-type the response. If a `request` is provided,\n * then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function from<\n  request extends RpcRequest.RpcRequest | undefined = undefined,\n  const response =\n    | (request extends RpcRequest.RpcRequest\n        ? request['_returnType']\n        : RpcResponse)\n    | unknown,\n>(\n  response: from.Response<request, response>,\n  options?: from.Options<request>,\n): Compute<from.ReturnType<response>>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(response: RpcResponse, options: any = {}): RpcResponse {\n  const { request } = options\n  return {\n    ...response,\n    id: response.id ?? request?.id,\n    jsonrpc: response.jsonrpc ?? request.jsonrpc,\n  }\n}\n\nexport declare namespace from {\n  type Response<\n    request extends RpcRequest.RpcRequest | undefined = undefined,\n    response = unknown,\n  > = response &\n    (request extends RpcRequest.RpcRequest\n      ? UnionPartialBy<RpcResponse<request['_returnType']>, 'id' | 'jsonrpc'>\n      : RpcResponse)\n\n  type Options<\n    request extends RpcRequest.RpcRequest | undefined =\n      | RpcRequest.RpcRequest\n      | undefined,\n  > = {\n    request?: request | RpcRequest.RpcRequest | undefined\n  }\n\n  type ReturnType<response> = IsNarrowable<response, RpcResponse> extends true\n    ? RpcResponse\n    : response & Readonly<{ id: number; jsonrpc: '2.0' }>\n}\n\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function parse<\n  const response extends RpcResponse | unknown,\n  returnType,\n  raw extends boolean = false,\n>(\n  response: response,\n  options: parse.Options<returnType, raw> = {},\n): parse.ReturnType<\n  unknown extends response\n    ? returnType\n    : response extends RpcResponse\n      ? response extends { result: infer result }\n        ? result\n        : never\n      : returnType,\n  raw\n> {\n  const { raw = false } = options\n  const response_ = response as RpcResponse\n  if (raw) return response as never\n  if (response_.error) throw parseError(response_.error)\n  return response_.result as never\n}\n\nexport declare namespace parse {\n  type Options<returnType, raw extends boolean = false> = {\n    /**\n     * JSON-RPC Method that was used to make the request. Used for typing the response.\n     */\n    request?:\n      | {\n          _returnType: returnType\n        }\n      | RpcRequest.RpcRequest\n      | undefined\n    /**\n     * Enables raw mode  responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n     *\n     * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n     * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n     *\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  }\n\n  type ReturnType<returnType, raw extends boolean = false> = Compute<\n    raw extends true ? RpcResponse<returnType> : returnType\n  >\n\n  type ErrorType =\n    | ParseError\n    | InvalidInputError\n    | ResourceNotFoundError\n    | ResourceUnavailableError\n    | TransactionRejectedError\n    | MethodNotSupportedError\n    | LimitExceededError\n    | VersionNotSupportedError\n    | InvalidRequestError\n    | MethodNotFoundError\n    | InvalidParamsError\n    | InternalError\n    | BaseErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nexport function parseError<const error extends Error | ErrorObject | unknown>(\n  error: error | Error | ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = error as Error | ErrorObject\n\n  if (error_ instanceof Error && !('code' in error_))\n    return new InternalError({\n      cause: error_,\n      data: error_,\n      message: error_.message,\n      stack: error_.stack,\n    }) as never\n\n  const { code } = error_\n  if (code === InternalError.code)\n    return new InternalError(error_ as never) as never\n  if (code === InvalidInputError.code)\n    return new InvalidInputError(error_) as never\n  if (code === InvalidParamsError.code)\n    return new InvalidParamsError(error_) as never\n  if (code === InvalidRequestError.code)\n    return new InvalidRequestError(error_) as never\n  if (code === LimitExceededError.code)\n    return new LimitExceededError(error_) as never\n  if (code === MethodNotFoundError.code)\n    return new MethodNotFoundError(error_) as never\n  if (code === MethodNotSupportedError.code)\n    return new MethodNotSupportedError(error_) as never\n  if (code === ParseError.code) return new ParseError(error_) as never\n  if (code === ResourceNotFoundError.code)\n    return new ResourceNotFoundError(error_) as never\n  if (code === ResourceUnavailableError.code)\n    return new ResourceUnavailableError(error_) as never\n  if (code === TransactionRejectedError.code)\n    return new TransactionRejectedError(error_) as never\n  if (code === VersionNotSupportedError.code)\n    return new VersionNotSupportedError(error_) as never\n  return new InternalError({\n    cause: error_ instanceof Error ? error_ : undefined,\n    data: error_,\n    message: error_.message,\n    stack: error_ instanceof Error ? error_.stack : undefined,\n  }) as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends ErrorObject | unknown,\n    //\n    error = errorObject extends ErrorObject\n      ?\n          | (errorObject['code'] extends InternalError['code']\n              ? InternalError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InternalError\n              : never)\n          | (errorObject['code'] extends InvalidInputError['code']\n              ? InvalidInputError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidInputError\n              : never)\n          | (errorObject['code'] extends ResourceNotFoundError['code']\n              ? ResourceNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceNotFoundError\n              : never)\n          | (errorObject['code'] extends ResourceUnavailableError['code']\n              ? ResourceUnavailableError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceUnavailableError\n              : never)\n          | (errorObject['code'] extends TransactionRejectedError['code']\n              ? TransactionRejectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? TransactionRejectedError\n              : never)\n          | (errorObject['code'] extends ParseError['code']\n              ? ParseError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ParseError\n              : never)\n          | (errorObject['code'] extends MethodNotSupportedError['code']\n              ? MethodNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotSupportedError\n              : never)\n          | (errorObject['code'] extends LimitExceededError['code']\n              ? LimitExceededError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? LimitExceededError\n              : never)\n          | (errorObject['code'] extends VersionNotSupportedError['code']\n              ? VersionNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? VersionNotSupportedError\n              : never)\n          | (errorObject['code'] extends InvalidRequestError['code']\n              ? InvalidRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidRequestError\n              : never)\n          | (errorObject['code'] extends MethodNotFoundError['code']\n              ? MethodNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotFoundError\n              : never)\n          | (errorObject['code'] extends InvalidParamsError['code']\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BaseError\n              : never)\n      : parseError.ReturnType<ErrorObject>,\n  > = IsNever<error> extends true ? BaseError : error\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\n\n/** Thrown when a JSON-RPC error has occurred. */\nexport class BaseError extends Error {\n  override name = 'RpcResponse.BaseError'\n\n  override readonly cause: Error | undefined\n  override readonly stack: string\n  readonly code: number\n  readonly data?: unknown | undefined\n\n  constructor(\n    errorObject: ErrorObject & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    },\n  ) {\n    const { cause, code, message, data, stack } = errorObject\n\n    super(message, { cause })\n\n    this.cause = cause\n    this.code = code\n    this.data = data\n    this.stack = stack ?? ''\n  }\n}\n\n/** Thrown when the input to a JSON-RPC method is invalid. */\nexport class InvalidInputError extends BaseError {\n  static readonly code = -32000\n  override readonly code = -32000\n  override readonly name = 'RpcResponse.InvalidInputError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidInputError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Missing or invalid parameters.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is not found. */\nexport class ResourceNotFoundError extends BaseError {\n  static readonly code = -32001\n  override readonly code = -32001\n  override readonly name = 'RpcResponse.ResourceNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not found.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is unavailable. */\nexport class ResourceUnavailableError extends BaseError {\n  static readonly code = -32002\n  override readonly code = -32002\n  override readonly name = 'RpcResponse.ResourceUnavailableError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceUnavailableError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not available.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC transaction is rejected. */\nexport class TransactionRejectedError extends BaseError {\n  static readonly code = -32003\n  override readonly code = -32003\n  override readonly name = 'RpcResponse.TransactionRejectedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: TransactionRejectedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Transaction creation failed.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not supported. */\nexport class MethodNotSupportedError extends BaseError {\n  static readonly code = -32004\n  override readonly code = -32004\n  override readonly name = 'RpcResponse.MethodNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method is not implemented.',\n    })\n  }\n}\n\n/** Thrown when a rate-limit is exceeded. */\nexport class LimitExceededError extends BaseError {\n  static readonly code = -32005\n  override readonly code = -32005\n  override readonly name = 'RpcResponse.LimitExceededError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: LimitExceededError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Rate limit exceeded.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC version is not supported. */\nexport class VersionNotSupportedError extends BaseError {\n  static readonly code = -32006\n  override readonly code = -32006\n  override readonly name = 'RpcResponse.VersionNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: VersionNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'JSON-RPC version not supported.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC request is invalid. */\nexport class InvalidRequestError extends BaseError {\n  static readonly code = -32600\n  override readonly code = -32600\n  override readonly name = 'RpcResponse.InvalidRequestError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidRequestError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not found. */\nexport class MethodNotFoundError extends BaseError {\n  static readonly code = -32601\n  override readonly code = -32601\n  override readonly name = 'RpcResponse.MethodNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method does not exist.',\n    })\n  }\n}\n\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nexport class InvalidParamsError extends BaseError {\n  static readonly code = -32602\n  override readonly code = -32602\n  override readonly name = 'RpcResponse.InvalidParamsError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidParamsError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Invalid method parameters.',\n    })\n  }\n}\n\n/** Thrown when an internal JSON-RPC error has occurred. */\nexport class InternalError extends BaseError {\n  static readonly code = -32603\n  override readonly code = -32603\n  override readonly name = 'RpcResponse.InternalError'\n\n  constructor(\n    parameters: Partial<Omit<ErrorObject, 'code'>> & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    } = {},\n  ) {\n    super({\n      cause: parameters.cause,\n      code: InternalError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Internal JSON-RPC error.',\n      stack: parameters.stack,\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC response is invalid. */\nexport class ParseError extends BaseError {\n  static readonly code = -32700\n  override readonly code = -32700\n  override readonly name = 'RpcResponse.ParseError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ParseError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n    })\n  }\n}\n", "import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  eventMap extends boolean | Record<string, unknown> = false,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (\n    | (eventMap extends true ? Emitter<EventMap> : never)\n    | (eventMap extends false ? Partial<Emitter<EventMap>> : never)\n    | (eventMap extends Record<string, unknown> ? Emitter<eventMap> : never)\n  )\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = Compute<EventEmitter<EventMap<eventMap>>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n} & (eventMap extends Record<string, unknown> ? eventMap : {})\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/** An error occurred when attempting to switch chain. */\nexport class SwitchChainError extends ProviderRpcError {\n  static readonly code = 4902\n  override readonly code = 4902\n  override readonly name = 'Provider.SwitchChainError'\n\n  constructor({\n    message = 'An error occurred when attempting to switch chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4902, message)\n  }\n}\n\n/** This Wallet does not support a capability that was not marked as optional. */\nexport class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n  static readonly code = 5700\n  override readonly code = 5700\n  override readonly name = 'Provider.UnsupportedNonOptionalCapabilityError'\n\n  constructor({\n    message = 'This Wallet does not support a capability that was not marked as optional.',\n  }: { message?: string | undefined } = {}) {\n    super(5700, message)\n  }\n}\n\n/** This Wallet does not support the requested chain ID. */\nexport class UnsupportedChainIdError extends ProviderRpcError {\n  static readonly code = 5710\n  override readonly code = 5710\n  override readonly name = 'Provider.UnsupportedChainIdError'\n\n  constructor({\n    message = 'This Wallet does not support the requested chain ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5710, message)\n  }\n}\n\n/** There is already a bundle submitted with this ID. */\nexport class DuplicateIdError extends ProviderRpcError {\n  static readonly code = 5720\n  override readonly code = 5720\n  override readonly name = 'Provider.DuplicateIdError'\n\n  constructor({\n    message = 'There is already a bundle submitted with this ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5720, message)\n  }\n}\n\n/** This bundle id is unknown / has not been submitted. */\nexport class UnknownBundleIdError extends ProviderRpcError {\n  static readonly code = 5730\n  override readonly code = 5730\n  override readonly name = 'Provider.UnknownBundleIdError'\n\n  constructor({\n    message = 'This bundle id is unknown / has not been submitted.',\n  }: { message?: string | undefined } = {}) {\n    super(5730, message)\n  }\n}\n\n/** The call bundle is too large for the Wallet to process. */\nexport class BundleTooLargeError extends ProviderRpcError {\n  static readonly code = 5740\n  override readonly code = 5740\n  override readonly name = 'Provider.BundleTooLargeError'\n\n  constructor({\n    message = 'The call bundle is too large for the Wallet to process.',\n  }: { message?: string | undefined } = {}) {\n    super(5740, message)\n  }\n}\n\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nexport class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n  static readonly code = 5750\n  override readonly code = 5750\n  override readonly name = 'Provider.AtomicReadyWalletRejectedUpgradeError'\n\n  constructor({\n    message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',\n  }: { message?: string | undefined } = {}) {\n    super(5750, message)\n  }\n}\n\n/** The wallet does not support atomic execution but the request requires it. */\nexport class AtomicityNotSupportedError extends ProviderRpcError {\n  static readonly code = 5760\n  override readonly code = 5760\n  override readonly name = 'Provider.AtomicityNotSupportedError'\n\n  constructor({\n    message = 'The wallet does not support atomic execution but the request requires it.',\n  }: { message?: string | undefined } = {}) {\n    super(5760, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter<\n  eventMap extends Record<string, unknown> = Record<string, unknown>,\n>(): Emitter<eventMap> {\n  const emitter = new EventEmitter<EventMap<eventMap>>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  options extends Options | undefined,\n  //\n  provider extends from.Value<options> | undefined = undefined,\n>(\n  provider: provider | from.Value<options> | undefined,\n  options?: options | Options,\n): from.ReturnType<options, provider>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, _options: Options = {}): Provider {\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...provider,\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type Value<options extends Options | undefined = undefined> = Partial<\n    Emitter<any>\n  > & {\n    request: (\n      parameters: options extends {\n        schema: infer schema extends RpcSchema.Generic\n      }\n        ? schema['Request']\n        : RpcSchema.Generic['Request'],\n    ) => unknown\n  }\n\n  type ReturnType<\n    options extends Options | undefined = Options | undefined,\n    provider extends from.Value<options> | undefined =\n      | from.Value<options>\n      | undefined,\n  > = Omit<provider, 'request'> & {\n    request: RequestFn<\n      options extends { schema: infer schema extends RpcSchema.Generic }\n        ? schema\n        : RpcSchema.Default\n    >\n  }\n\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const error extends RpcResponse.ErrorObject | Error | unknown,\n>(\n  error: error | Error | RpcResponse.ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = RpcResponse.parseError(error)\n  if (error_ instanceof RpcResponse.InternalError) {\n    if (!error_.data) return error_ as never\n\n    const { code } = error_.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(error_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(error_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(error_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(error_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(error_) as never\n    if (code === SwitchChainError.code)\n      return new SwitchChainError(error_) as never\n    if (code === AtomicReadyWalletRejectedUpgradeError.code)\n      return new AtomicReadyWalletRejectedUpgradeError(error_) as never\n    if (code === AtomicityNotSupportedError.code)\n      return new AtomicityNotSupportedError(error_) as never\n    if (code === BundleTooLargeError.code)\n      return new BundleTooLargeError(error_) as never\n    if (code === UnknownBundleIdError.code)\n      return new UnknownBundleIdError(error_) as never\n    if (code === DuplicateIdError.code)\n      return new DuplicateIdError(error_) as never\n    if (code === UnsupportedChainIdError.code)\n      return new UnsupportedChainIdError(error_) as never\n    if (code === UnsupportedNonOptionalCapabilityError.code)\n      return new UnsupportedNonOptionalCapabilityError(error_) as never\n  }\n  return error_ as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n          | (errorObject['code'] extends SwitchChainError['code']\n              ? SwitchChainError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? SwitchChainError\n              : never)\n          | (errorObject['code'] extends AtomicReadyWalletRejectedUpgradeError['code']\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (errorObject['code'] extends AtomicityNotSupportedError['code']\n              ? AtomicityNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicityNotSupportedError\n              : never)\n          | (errorObject['code'] extends BundleTooLargeError['code']\n              ? BundleTooLargeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BundleTooLargeError\n              : never)\n          | (errorObject['code'] extends UnknownBundleIdError['code']\n              ? UnknownBundleIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnknownBundleIdError\n              : never)\n          | (errorObject['code'] extends DuplicateIdError['code']\n              ? DuplicateIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DuplicateIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedChainIdError['code']\n              ? UnsupportedChainIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedChainIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedNonOptionalCapabilityError['code']\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n", "import type { Errors } from '../index.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** A JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcRequest<schema extends RpcSchema.Generic = RpcSchema.Generic> =\n  Compute<\n    schema extends any\n      ? schema['Request'] & {\n          id: number\n          jsonrpc: '2.0'\n          /** @deprecated internal */\n          _returnType: schema['ReturnType']\n        }\n      : never\n  >\n\n/** JSON-RPC request store type. */\nexport type Store<schema extends RpcSchema.Generic | undefined = undefined> =\n  Compute<{\n    prepare: <methodName extends RpcSchema.MethodNameGeneric>(\n      parameters: Compute<\n        schema extends RpcSchema.Generic\n          ? RpcSchema.ExtractRequest<schema, methodName>\n          : RpcSchema_internal.ExtractRequestOpaque<\n              RpcSchema.Default,\n              methodName\n            >\n      >,\n    ) => Compute<\n      RpcRequest<\n        RpcSchema.ExtractItem<\n          schema extends RpcSchema.Generic ? schema : RpcSchema.Default,\n          methodName\n        >\n      >\n    >\n    readonly id: number\n  }>\n\n/**\n * Creates a JSON-RPC request store to build requests with an incrementing `id`.\n *\n * Returns a type-safe `prepare` function to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using {@link ox#RpcSchema.from}.\n *\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * const schema = RpcSchema.from<{ // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobar' // [!code focus]\n *     params: [number] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * } | { // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobaz' // [!code focus]\n *     params: [string] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * }>() // [!code focus]\n *\n * const store = RpcRequest.createStore({ schema }) // [!code focus]\n *\n * const request = store.prepare({\n *   method: 'eth_foobar', // [!code focus]\n *   // ^?\n *   params: [42],\n * })\n * ```\n *\n * @param options - Request store options.\n * @returns The request store\n */\nexport function createStore<\n  schema extends RpcSchema.Generic | undefined = undefined,\n>(options: createStore.Options<schema> = {}): createStore.ReturnType<schema> {\n  let id = options.id ?? 0\n  return {\n    prepare(options) {\n      return from({\n        id: id++,\n        ...options,\n      } as never) as never\n    },\n    get id() {\n      return id\n    },\n  }\n}\n\nexport declare namespace createStore {\n  type Options<schema extends RpcSchema.Generic | undefined = undefined> = {\n    /** The initial request ID. */\n    id?: number\n    /** RPC Schema to use for the request store. */\n    schema?: schema | RpcSchema.Generic | undefined\n  }\n\n  type ReturnType<schema extends RpcSchema.Generic | undefined = undefined> =\n    Store<schema>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * A type-safe interface to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * :::warning\n *\n * You will likely want to use {@link ox#RpcRequest.(createStore:function)} instead as it will also manage `id`s and uses this function internally.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Build a request object.\n * const request = RpcRequest.from({ // [!code focus]\n *   id: 0, // [!code focus]\n *   method: 'eth_estimateGas', // [!code focus]\n *   params: [ // [!code focus]\n *     { // [!code focus]\n *       from: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]\n *       to: '0x0D44f617435088c947F00B31160f64b074e412B4', // [!code focus]\n *       value: '0x69420', // [!code focus]\n *     }, // [!code focus]\n *   ], // [!code focus]\n * }) // [!code focus]\n *\n * // 2. Send the JSON-RPC request via HTTP.\n * const gas = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 3. Parse the JSON-RPC response into a type-safe result.\n *  .then((response) => RpcResponse.parse(response, { request }))\n * ```\n *\n * @param options - JSON-RPC request options.\n * @returns The fully-formed JSON-RPC request object.\n */\nexport function from<methodName extends RpcSchema.MethodNameGeneric>(\n  options: from.Options<methodName>,\n): from.ReturnType<methodName> {\n  return {\n    ...options,\n    jsonrpc: '2.0',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcSchema_internal.ExtractRequestOpaque<RpcSchema.Default, methodName> & {\n      id: number\n    }\n  >\n\n  type ReturnType<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcRequest<RpcSchema.ExtractItem<RpcSchema.Default, methodName>>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Bytes from 'ox/Bytes'\nimport type * as Hex from 'ox/Hex'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\n\nexport type P256Credential = {\n  id: WebAuthnP256.P256Credential['id']\n  publicKey: Hex.Hex\n  raw: WebAuthnP256.P256Credential['raw']\n}\n\n/**\n * Creates a WebAuthn credential (ie. a passkey).\n *\n * This function returns the credential object, which includes the public key.\n * It is recommended to store the public key against the credential in an external store\n * as it is not possible to extract a public key from a credential after it has been created.\n *\n * @example\n * ```ts\n * import { WebAuthnP256 } from 'viem/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * // {\n * //   id: 'oZ48...',\n * //   publicKey: '0x...',\n * // }\n * ```\n *\n * @param parameters WebAuthnP256 createCredential options.\n * @returns WebAuthn credential.\n */\nexport async function createCredential(\n  parameters: createCredential.Parameters,\n): Promise<createCredential.ReturnValue> {\n  const { createFn, label, rpId, userId } = parameters\n  const credential = await WebAuthnP256.createCredential({\n    ...parameters,\n    authenticatorSelection: {\n      ...parameters.authenticatorSelection,\n      requireResidentKey: true,\n      residentKey: 'required',\n      userVerification: 'required',\n    },\n    createFn,\n    extensions: {\n      ...parameters.extensions,\n      credProps: true,\n    },\n    rp: rpId\n      ? {\n          id: rpId,\n          name: rpId,\n        }\n      : undefined,\n    name: undefined as never,\n    user: {\n      displayName: label,\n      id: new Uint8Array(userId ?? Bytes.fromString(label)),\n      name: label,\n    },\n  })\n  return {\n    id: credential.id,\n    publicKey: PublicKey.toHex(credential.publicKey, {\n      includePrefix: false,\n    }),\n    raw: credential.raw,\n  }\n}\n\nexport declare namespace createCredential {\n  export type Parameters = Omit<\n    WebAuthnP256.createCredential.Options,\n    'rp' | 'user'\n  > & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?: WebAuthnP256.createCredential.Options['createFn'] | undefined\n    /** Label. */\n    label: string\n    /** Relying Party ID. */\n    rpId?: string | undefined\n    /** User ID. */\n    userId?: Bytes.Bytes | undefined\n  }\n\n  export type ReturnValue = P256Credential\n}\n\n/**\n * Gets a WebAuthn credential (ie. a passkey), and optionally signs over a digest/hash.\n *\n * A `getPublicKey` function is required to fetch the public key paired with the credential\n * from an external store. It is not possible to extract a public key from a credential after\n * the credential has been created with `WebAuthnP256.createCredential`.\n *\n * @example\n * ```ts\n * import { WebAuthnP256 } from 'viem/tempo'\n *\n * const credential = await WebAuthnP256.getCredential({\n *   async getPublicKey(credential) {\n *     // Get public key from store\n *     return store.getPublicKey(credential.id)\n *   }\n * })\n * ```\n *\n * @param parameters WebAuthnP256 getCredential options.\n * @returns WebAuthn credential.\n */\nexport async function getCredential(\n  parameters: getCredential.Parameters,\n): Promise<getCredential.ReturnValue> {\n  const { metadata, raw, signature } = await WebAuthnP256.sign({\n    ...parameters,\n    challenge: parameters.hash ?? '0x',\n  })\n  const publicKey = await parameters.getPublicKey(raw)\n  return {\n    id: raw.id,\n    metadata,\n    publicKey,\n    raw,\n    signature,\n  }\n}\n\nexport declare namespace getCredential {\n  export type Parameters = Omit<WebAuthnP256.sign.Options, 'challenge'> & {\n    hash?: Hex.Hex | undefined\n    getPublicKey: (\n      credential: WebAuthnP256.P256Credential['raw'],\n    ) => Promise<Hex.Hex>\n  }\n\n  export type ReturnValue = WebAuthnP256.sign.ReturnType & {\n    id: string\n    publicKey: Hex.Hex\n  }\n}\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport { createKeyPair } from 'ox/WebCryptoP256'\n"],
  "mappings": "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",
  "names": ["EventEmitter", "from", "sign", "getPublicKey", "from", "sign", "toHex", "parameters", "nonce", "address", "feeManager", "stablecoinDex", "tip20Factory", "tip403Registry", "validator", "getPool", "feeManager", "getLiquidityBalance", "rebalanceSwap", "call", "mint", "burn", "buy", "call", "stablecoinDex", "cancel", "cancelStale", "createPair", "getBalance", "getBuyQuote", "getOrder", "getOrderbook", "getTickLevel", "getSellQuote", "place", "placeFlip", "sell", "withdraw", "keccak256", "getUserToken", "feeManager", "setUserToken", "call", "validator", "getValidatorToken", "setValidatorToken", "getNonce", "create", "call", "tip403Registry", "setAdmin", "modifyWhitelist", "modifyBlacklist", "getData", "isAuthorized", "claim", "call", "distribute", "getGlobalRewardPerToken", "getPendingRewards", "getUserRewardInfo", "setRecipient", "burn", "burnSync", "create", "createSync", "getBalance", "mint", "mintSync", "watchBurn", "watchCreate", "watchMint", "approve", "call", "burnBlocked", "from", "burn", "burnSync", "changeTransferPolicy", "create", "tip20Factory", "createSync", "getAllowance", "getBalance", "getRoleAdmin", "hasRole", "grantRoles", "mint", "mintSync", "pause", "renounceRoles", "revokeRoles", "setSupplyCap", "setRoleAdmin", "transfer", "unpause", "prepareUpdateQuoteToken", "updateQuoteToken", "watchBurn", "watchCreate", "watchMint", "add", "validator", "changeOwner", "changeStatus", "getNextFullDkgCeremony", "getOwner", "get", "getByIndex", "getCount", "list", "setNextFullDkgCeremony", "update", "burn", "burnSync", "create", "createSync", "getBalance", "mint", "mintSync", "watchBurn", "watchCreate", "watchMint", "P256_exports", "randomPrivateKey", "Secp256k1_exports", "pathUsd", "from", "keccak256", "fromString", "options", "from", "slice", "WebAuthnP256_exports", "createCredential", "createCredential", "sign", "WebCryptoP256_exports"]
}
